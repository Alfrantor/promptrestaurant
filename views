from django.shortcuts import render, redirect
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
from django.db import connections
from django.contrib.auth import authenticate, login as auth_login, logout
from django.contrib.auth.decorators import login_required
import json
import datetime
from datetime import date, datetime, timedelta
import uuid
import hashlib
import base64
import secrets
import decimal
import pytz
from django.contrib import messages
import logging
from django.db import transaction
from django.views.decorators.http import require_POST
from functools import wraps
from .models import CategoriasProductos, Productos

# Configurar logging
logger = logging.getLogger(__name__)

def grupos_permitidos(grupos=[]):
    """Decorador que verifica si el usuario pertenece a alguno de los grupos especificados"""
    def decorator(view_func):
        @wraps(view_func)
        def wrapper(request, *args, **kwargs):
            user_groups = request.user.groups.values_list('name', flat=True)
            if not any(group in user_groups for group in grupos):
                return JsonResponse({'error': 'Sin permisos'}, status=403)
            return view_func(request, *args, **kwargs)
        return wrapper
    return decorator

# Función para convertir datos de cursor a lista de diccionarios
def dictfetchall(cursor):
    """Return all rows from a cursor as a dict"""
    columns = [col[0] for col in cursor.description]
    return [dict(zip(columns, row)) for row in cursor.fetchall()]

# Función para convertir valores Decimal a float para JSON
def decimal_default(obj):
    if isinstance(obj, decimal.Decimal):
        return float(obj)
    elif isinstance(obj, (date, datetime)):  # Usando los imports directos
        return obj.isoformat()
    elif hasattr(obj, '__dict__'):
        return obj.__dict__
    raise TypeError(f"Object of type {type(obj)} is not JSON serializable")


@login_required
def inicio_view(request):
    print("User authenticated?", request.user.is_authenticated)
    context = {
        'nombre_completo': request.session.get('nombre_completo', ''),
        'rol': request.session.get('rol', ''),
    }
    return render(request, 'inicio.html', context)


# ---------------------------------------------------------------
# VISTAS DE AUTENTICACIÓN Y USUARIOS
# ---------------------------------------------------------------

import logging
logger = logging.getLogger(__name__)

from django.shortcuts import render, redirect

def login_view(request):
    """Vista para iniciar sesión con autenticación nativa de Django"""
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        user = authenticate(request, username=username, password=password)
        
        if user is not None:
            if user.is_active:
                auth_login(request, user)  # Usar auth_login para evitar conflicto con la función
                
                # Obtener información adicional si es necesario
                try:
                    with connections['default'].cursor() as cursor:
                        cursor.execute('''
                            SELECT /*+ MAX_EXECUTION_TIME(25000) */
                                e.id as empleado_id, e.nombre, e.apellidos, 
                                r.id as rol_id, r.nombre as rol_nombre, r.permisos
                            FROM empleados e
                            JOIN roles r ON e.rol_id = r.id
                            WHERE e.numero_django = %s
                        ''', [user.id])

                        
                        empleado = cursor.fetchone()
                        if empleado:
                            request.session['empleado_id'] = empleado[0]
                            request.session['nombre_completo'] = f"{empleado[1]} {empleado[2]}"
                            request.session['rol_id'] = empleado[3]
                            request.session['rol'] = empleado[4]
                            request.session['permisos'] = json.loads(empleado[5]) if empleado[5] else {}
                            
                        # Obtener sucursal activa
                        cursor.execute('''
                            SELECT /*+ MAX_EXECUTION_TIME(25000) */
                                id, nombre 
                            FROM sucursales 
                            WHERE estatus = "activa" 
                            LIMIT 1
                        ''')

                        sucursal = cursor.fetchone()
                        if sucursal:
                            request.session['sucursal_id'] = sucursal[0]
                            request.session['sucursal_nombre'] = sucursal[1]
                    
                    return redirect('index')
                    
                except Exception as e:
                    logger.error(f"Error al obtener datos adicionales: {str(e)}")
                    return render(request, 'login.html', {'error': "Error al iniciar sesión. Por favor contacte al administrador."})
            else:
                return render(request, 'login.html', {'error': "Esta cuenta está desactivada"})
        else:
            return render(request, 'login.html', {'error': "Usuario o contraseña incorrectos"})
    
    # Si es GET, mostrar el formulario de login
    return render(request, 'login.html')

def logout_view(request):
    """Vista para cerrar sesión"""
    logout(request)
    return redirect('/login/')

@login_required
def cambiar_password(request):
    """Vista para cambiar contraseña"""
    if request.method == 'POST':
        password_actual = request.POST.get('password_actual')
        password_nuevo = request.POST.get('password_nuevo')
        password_confirm = request.POST.get('password_confirm')
        
        if password_nuevo != password_confirm:
            return JsonResponse({'error': 'Las contraseñas no coinciden'})
        
        # Verificar contraseña actual
        user = request.user
        if user.check_password(password_actual):
            # Actualizar contraseña
            user.set_password(password_nuevo)
            user.save()
            
            # Actualizar la sesión para evitar desconexión
            login(request, user)
            
            return JsonResponse({'success': 'Contraseña actualizada correctamente'})
        else:
            return JsonResponse({'error': 'Contraseña actual incorrecta'})
    
    return render(request, 'cambiar_password.html')

@login_required
@grupos_permitidos(['Administradores'])
def lista_empleados(request):
    """Vista para listar empleados"""
    with connections['default'].cursor() as cursor:
        cursor.execute('''
            SELECT e.id, e.nombre, e.apellidos, e.telefono, e.email, 
                   r.nombre as rol, e.estatus
            FROM empleados e
            JOIN roles r ON e.rol_id = r.id
            ORDER BY e.apellidos, e.nombre
        ''')
        empleados = dictfetchall(cursor)
    
    return render(request, 'catalogos/empleados/lista.html', {'empleados': empleados})

@login_required
@grupos_permitidos(['Administradores'])
def detalle_empleado(request, empleado_id=None):
    """Vista para ver o editar detalles del empleado"""
    # Añadir verificación de superusuario
    is_superuser = request.user.is_superuser
    
    # Obtener usuarios de Django
    from django.contrib.auth.models import User
    all_usuarios_django = User.objects.all().values('id', 'username').order_by('username')
    
    with connections['default'].cursor() as cursor:
        empleado = None
        # Obtener todos los roles para el selector
        cursor.execute('SELECT id, nombre FROM roles ORDER BY nombre')
        roles = dictfetchall(cursor)
        
        # Si es un empleado existente, obtener sus datos primero
        if empleado_id:
            cursor.execute('''
                SELECT e.*, r.nombre as rol_nombre
                FROM empleados e
                JOIN roles r ON e.rol_id = r.id
                WHERE e.id = %s
            ''', [empleado_id])
            empleado = dictfetchall(cursor)[0] if cursor.rowcount > 0 else None
        
        # Obtener TODOS los IDs de Django que ya están asignados a empleados
        cursor.execute('''
            SELECT id, numero_django 
            FROM empleados 
            WHERE numero_django IS NOT NULL
        ''')
        empleados_con_django = dictfetchall(cursor)
        print(empleados_con_django)
        # Crear un conjunto de IDs ya asignados (excepto el del empleado actual)
        ids_django_asignados = set()
        id_django_actual = None
        
        if empleado and empleado.get('numero_django'):
            id_django_actual = str(empleado.get('numero_django'))
        print(id_django_actual)    
        for emp in empleados_con_django:
            # No incluir el ID actual en los asignados (para que aparezca en el selector)
            if str(emp['numero_django']) != id_django_actual:
                ids_django_asignados.add(str(emp['numero_django']))
        
        # Filtrar usuarios de Django: mostrar solo los no asignados + el actual
        usuarios_django = [
            usuario for usuario in all_usuarios_django 
            if str(usuario['id']) not in ids_django_asignados
        ]
        print(usuarios_django)
        # Si es POST, actualizar o crear datos
        if request.method == 'POST':
            nombre = request.POST.get('nombre')
            apellidos = request.POST.get('apellidos')
            telefono = request.POST.get('telefono')
            email = request.POST.get('email')
            rol_id = request.POST.get('rol_id')
            estatus = request.POST.get('estatus', 'activo')  # Valor predeterminado
            fecha_nacimiento = request.POST.get('fecha_nacimiento')
            fecha_contratacion = request.POST.get('fecha_contratacion')
            direccion = request.POST.get('direccion', '')
            
            # Solo permitir cambio de usuario Django si es superusuario o si es nuevo empleado
            if is_superuser or not empleado_id:
                numero_django = request.POST.get('numero_django', '')
                # Convertir cadena vacía a None (NULL en SQL)
                if numero_django == '':
                    numero_django = None
            else:
                # Mantener el mismo usuario si no es superusuario
                numero_django = empleado['numero_django'] if empleado else None
            
            # Genera el PIN de 5 dígitos si está vacío
            pin_acceso = request.POST.get('pin_acceso', '')
            if not pin_acceso:
                import random
                pin_acceso = ''.join(random.choices('0123456789', k=5))
            
            # Si empleado_id existe, ACTUALIZAR
            if empleado_id:
                cursor.execute('''
                    UPDATE empleados 
                    SET nombre = %s, apellidos = %s, telefono = %s,
                        email = %s, rol_id = %s, estatus = %s,
                        fecha_nacimiento = %s, fecha_contratacion = %s,
                        direccion = %s, numero_django = %s, pin_acceso = %s
                    WHERE id = %s
                ''', [nombre, apellidos, telefono, email, rol_id, estatus, 
                     fecha_nacimiento, fecha_contratacion, direccion, 
                     numero_django, pin_acceso, empleado_id])
            else:
                # Si no hay empleado_id, INSERTAR nuevo
                cursor.execute('''
                    INSERT INTO empleados (rol_id, nombre, apellidos, telefono, email, 
                                          fecha_nacimiento, fecha_contratacion, direccion,
                                          numero_django, pin_acceso, estatus, creado_en, actualizado_en)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, NOW(), NOW())
                ''', [rol_id, nombre, apellidos, telefono, email, 
                     fecha_nacimiento, fecha_contratacion, direccion,
                     numero_django, pin_acceso, estatus])
            
            return redirect('lista_empleados')
    
    # Pasar información adicional al template
    return render(request, 'catalogos/empleados/detalle.html', {
        'empleado': empleado,
        'roles': roles,
        'usuarios_django': usuarios_django,
        'all_usuarios_django': all_usuarios_django, 
        'is_superuser': is_superuser
    })

from django.http import JsonResponse
from django.views.decorators.http import require_http_methods

@login_required
@grupos_permitidos(['Administradores'])
@require_http_methods(["DELETE"])
def eliminar_empleado(request, empleado_id):
    try:
        with connections['default'].cursor() as cursor:
            cursor.execute("DELETE FROM empleados WHERE id = %s", [empleado_id])
        return JsonResponse({'success': True})
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)}, status=400)


# ---------------------------------------------------------------
# VISTAS DE DASHBOARD Y PUNTO DE VENTA
# ---------------------------------------------------------------

@login_required
@grupos_permitidos(['Administradores'])
def dashboard(request):
    """Vista del dashboard principal mejorado con datos reales"""
    # Obtener fechas de filtro (por defecto última semana)
    fecha_fin = request.GET.get('fecha_fin', datetime.now().strftime('%Y-%m-%d'))
    fecha_inicio = request.GET.get('fecha_inicio', (datetime.now() - timedelta(days=7)).strftime('%Y-%m-%d'))
    
    # Convertir a objetos date para cálculos
    fecha_fin_obj = datetime.strptime(fecha_fin, '%Y-%m-%d').date()
    fecha_inicio_obj = datetime.strptime(fecha_inicio, '%Y-%m-%d').date()
    
    with connections['default'].cursor() as cursor:
        # Estadísticas del día actual
        today = datetime.now().strftime('%Y-%m-%d')
        
        # Ventas del día
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT COUNT(*) as total_ordenes, 
                   SUM(total) as venta_total
            FROM ordenes 
            WHERE DATE(fecha_apertura) = %s 
            AND estatus IN ('cerrada', 'entregada')
        ''', [today])
        ventas_hoy = dictfetchall(cursor)[0]
        
        # Mesas ocupadas vs disponibles
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT 
                SUM(CASE WHEN estatus = 'ocupada' THEN 1 ELSE 0 END) as ocupadas,
                SUM(CASE WHEN estatus = 'disponible' THEN 1 ELSE 0 END) as disponibles,
                COUNT(*) as total
            FROM mesas
        ''')
        mesas_stats = dictfetchall(cursor)[0]
        
        # NUEVO: Calcular porcentaje de ocupación
        ocupadas = mesas_stats.get('ocupadas', 0) or 0
        total_mesas = mesas_stats.get('total', 0) or 1  # Evitar división por cero
        porcentaje_ocupacion = round((ocupadas / total_mesas) * 100)
        mesas_stats['porcentaje'] = porcentaje_ocupacion
        
        # NUEVO: Todas las órdenes pendientes (sin filtro de fecha)
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT o.id, o.codigo_orden, ts.nombre as tipo_servicio,
                   m.numero as mesa_numero, 
                   o.fecha_apertura,
                   o.estatus, o.total, CONCAT(e.nombre, ' ', e.apellidos) as empleado,
                   TIMESTAMPDIFF(MINUTE, o.fecha_apertura, NOW()) as minutos_desde_apertura
            FROM ordenes o
            JOIN tipos_servicio ts ON o.tipo_servicio_id = ts.id
            LEFT JOIN mesas m ON o.mesa_id = m.id
            JOIN empleados e ON o.empleado_id = e.id
            WHERE o.estatus NOT IN ('cerrada', 'entregada', 'cancelada')
            ORDER BY o.fecha_apertura ASC
        ''')
        ordenes_pendientes = dictfetchall(cursor)
        
        # NUEVO: Entregas a domicilio pendientes
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT COUNT(*) as total
            FROM ordenes
            WHERE tipo_servicio_id = 3 
            AND estatus NOT IN ('cerrada', 'entregada', 'cancelada')
        ''')
        domicilios_pendientes = cursor.fetchone()[0]
        
        print(fecha_inicio,fecha_fin)
        # NUEVO: Ventas por día para el rango de fechas (gráfico)
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT 
                DATE(fecha_apertura) as fecha,
                SUM(total) as venta_total,
                COUNT(*) as num_ordenes
            FROM ordenes
            WHERE DATE(fecha_apertura) BETWEEN %s AND %s
            AND estatus IN ('cerrada', 'entregada')
            GROUP BY DATE(fecha_apertura)
            ORDER BY fecha
        ''', [fecha_inicio, fecha_fin])
        ventas_por_dia = dictfetchall(cursor)
        
        # NUEVO: Ventas por tipo de servicio para el período
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT ts.nombre as tipo_servicio, 
                   COUNT(o.id) as cantidad,
                   SUM(o.total) as total
            FROM ordenes o
            JOIN tipos_servicio ts ON o.tipo_servicio_id = ts.id
            WHERE DATE(o.fecha_apertura) BETWEEN %s AND %s
            AND o.estatus IN ('cerrada', 'entregada')
            GROUP BY ts.id
            ORDER BY total DESC
        ''', [fecha_inicio, fecha_fin])
        ventas_por_tipo = dictfetchall(cursor)
        
        # NUEVO: Ventas por método de pago para el período
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT mp.nombre as metodo_pago,
                   COUNT(p.id) as cantidad,
                   SUM(p.monto) as total
            FROM pagos p
            JOIN metodos_pago mp ON p.metodo_pago_id = mp.id
            JOIN ordenes o ON p.orden_id = o.id
            WHERE DATE(o.fecha_apertura) BETWEEN %s AND %s
            AND p.estatus = 'completado'
            GROUP BY mp.id
            ORDER BY total DESC
        ''', [fecha_inicio, fecha_fin])
        ventas_por_metodo = dictfetchall(cursor)
        
        # Productos más vendidos del período
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT p.nombre, SUM(od.cantidad) as cantidad, SUM(od.total) as total
            FROM orden_detalles od
            JOIN productos p ON od.producto_id = p.id
            JOIN ordenes o ON od.orden_id = o.id
            WHERE DATE(o.fecha_apertura) BETWEEN %s AND %s
            AND o.estatus IN ('cerrada', 'entregada')
            GROUP BY p.id
            ORDER BY cantidad DESC
            LIMIT 10
        ''', [fecha_inicio, fecha_fin])
        productos_top = dictfetchall(cursor)
        
        # NUEVO: Resumen de cortes de caja para el período
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT 
                DATE(cc.fecha_apertura) as fecha,
                COUNT(cc.id) as cantidad_cortes,
                SUM(
                    (SELECT COALESCE(SUM(p.monto), 0) 
                    FROM pagos p 
                    JOIN ordenes o ON p.orden_id = o.id 
                    WHERE o.corte_caja_id = cc.id 
                    AND p.estatus = 'completado')
                ) as venta_total,
                SUM(cc.diferencia) as diferencia_total
            FROM cortes_caja cc
            WHERE DATE(cc.fecha_apertura) BETWEEN %s AND %s
            AND cc.estatus = 'cerrado'
            GROUP BY DATE(cc.fecha_apertura)
            ORDER BY fecha DESC
            LIMIT 15
        ''', [fecha_inicio, fecha_fin])
        resumen_cortes = dictfetchall(cursor)
        
        # NUEVO: Cajas disponibles para el selector
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT id, nombre
            FROM cajas
            ORDER BY nombre
        ''')
        cajas = dictfetchall(cursor)
        
        # NUEVO: Empleados (cajeros) para el selector
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT id, CONCAT(nombre, ' ', apellidos) as nombre_completo
            FROM empleados
            WHERE rol_id IN (SELECT id FROM roles WHERE nombre LIKE '%cajero%' OR nombre LIKE '%caja%')
            ORDER BY nombre, apellidos
        ''')
        cajeros = dictfetchall(cursor)
    
    # Preparar datos para gráficos JavaScript
    fechas = []
    montos = []
    ordenes = []
    
    # Generar todas las fechas en el rango
    current_date = fecha_inicio_obj
    datos_ventas = {}
    
    # Crear diccionario con datos de ventas por fecha
    for venta in ventas_por_dia:
        fecha_str = venta['fecha'].strftime('%Y-%m-%d')
        datos_ventas[fecha_str] = venta
    
    # Llenar el array con todas las fechas del rango
    while current_date <= fecha_fin_obj:
        fecha_str = current_date.strftime('%Y-%m-%d')
        fechas.append(current_date.strftime('%d/%m'))
        
        # Si hay datos para esta fecha, usarlos; si no, poner 0
        if fecha_str in datos_ventas:
            montos.append(float(datos_ventas[fecha_str]['venta_total']))
            ordenes.append(int(datos_ventas[fecha_str]['num_ordenes']))
        else:
            montos.append(0)
            ordenes.append(0)
            
        current_date += timedelta(days=1)
    
    # Preparar datos para el gráfico de distribución
    tipos_servicio = []
    totales_tipo = []
    colores_tipo = ['rgba(66, 153, 225, 0.7)', 'rgba(72, 187, 120, 0.7)', 'rgba(237, 137, 54, 0.7)', 'rgba(159, 122, 234, 0.7)']
    
    for i, tipo in enumerate(ventas_por_tipo):
        tipos_servicio.append(tipo['tipo_servicio'])
        totales_tipo.append(float(tipo['total']))
    
    return render(request, 'dashboard.html', {
        'ventas_hoy': ventas_hoy,
        'mesas_stats': mesas_stats,
        'ordenes_pendientes': ordenes_pendientes,
        'productos_top': productos_top,
        'domicilios_pendientes': domicilios_pendientes,
        'ventas_por_dia': ventas_por_dia,
        'ventas_por_tipo': ventas_por_tipo,
        'ventas_por_metodo': ventas_por_metodo,
        'resumen_cortes': resumen_cortes,
        'cajas': cajas,
        'cajeros': cajeros,
        'fecha_inicio': fecha_inicio,
        'fecha_fin': fecha_fin,
        'fechas_graph': json.dumps(fechas),
        'montos_graph': json.dumps(montos),
        'ordenes_graph': json.dumps(ordenes),
        'tipos_servicio_graph': json.dumps(tipos_servicio),
        'totales_tipo_graph': json.dumps(totales_tipo),
        'colores_tipo': json.dumps(colores_tipo),
    })

@login_required
def detalle_cortes_fecha(request):
    """Vista para obtener detalle de cortes por fecha (AJAX)"""
    fecha = request.GET.get('fecha')
    
    if not fecha:
        return JsonResponse({'error': 'Fecha no especificada'}, status=400)
    
    with connections['pagoda'].cursor() as cursor:
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT cc.id, c.nombre as caja, 
                   CONCAT(e.nombre, ' ', e.apellidos) as cajero,
                   cc.fecha_apertura,
                   cc.fecha_cierre,
                   cc.monto_inicial, cc.monto_final, cc.diferencia,
                   (SELECT SUM(p.monto) 
                    FROM pagos p 
                    JOIN ordenes o ON p.orden_id = o.id 
                    WHERE o.corte_caja_id = cc.id 
                    AND p.estatus = 'completado') as total_ventas,
                   (SELECT COUNT(DISTINCT o.id) 
                    FROM ordenes o 
                    WHERE o.corte_caja_id = cc.id 
                    AND o.estatus IN ('cerrada', 'entregada')) as total_ordenes
            FROM cortes_caja cc
            JOIN cajas c ON cc.caja_id = c.id
            JOIN empleados e ON cc.empleado_id = e.id
            WHERE DATE(cc.fecha_apertura) = %s
            ORDER BY c.nombre
        ''', [fecha])
        
        cortes = dictfetchall(cursor)
        
        # Calcular diferencia total correctamente
        diferencia_total = 0
        for corte in cortes:
            if corte['diferencia'] is not None:
                diferencia_total += decimal.Decimal(corte['diferencia'])
        
        # Obtener órdenes para cada corte
        for corte in cortes:
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT o.id, o.codigo_orden, o.fecha_apertura,
                       o.total, ts.nombre as tipo_servicio,
                       (SELECT COUNT(*) FROM orden_detalles WHERE orden_id = o.id) as num_items
                FROM ordenes o
                JOIN tipos_servicio ts ON o.tipo_servicio_id = ts.id
                WHERE o.corte_caja_id = %s
                AND o.estatus IN ('cerrada', 'entregada')
                ORDER BY o.fecha_apertura
                LIMIT 30
            ''', [corte['id']])
            corte['ordenes'] = dictfetchall(cursor)
            
            # NUEVO: Obtener desglose por método de pago para este corte
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT mp.nombre as metodo, mp.id as metodo_id, 
                       COUNT(p.id) as cantidad, 
                       SUM(p.monto) as total
                FROM pagos p
                JOIN metodos_pago mp ON p.metodo_pago_id = mp.id
                JOIN ordenes o ON p.orden_id = o.id
                WHERE o.corte_caja_id = %s
                AND p.estatus = 'completado'
                GROUP BY mp.id
                ORDER BY total DESC
            ''', [corte['id']])
            corte['pagos_por_metodo'] = dictfetchall(cursor)
    
        # NUEVO: Agregar desglose global por método de pago
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT mp.nombre as metodo, mp.id as metodo_id, 
                   COUNT(p.id) as cantidad, 
                   SUM(p.monto) as total
            FROM pagos p
            JOIN metodos_pago mp ON p.metodo_pago_id = mp.id
            JOIN ordenes o ON p.orden_id = o.id
            JOIN cortes_caja cc ON o.corte_caja_id = cc.id
            WHERE DATE(cc.fecha_apertura) = %s
            AND p.estatus = 'completado'
            GROUP BY mp.id
            ORDER BY total DESC
        ''', [fecha])
        pagos_por_metodo_global = dictfetchall(cursor)
    
    # Calcular totales
    total_ventas = sum(float(corte.get('total_ventas', 0) or 0) for corte in cortes)
    total_ordenes = sum(corte.get('total_ordenes', 0) or 0 for corte in cortes)
    
    return JsonResponse({
        'cortes': cortes,
        'fecha': fecha,
        'total_ventas': float(total_ventas),
        'total_ordenes': total_ordenes,
        'diferencia_total': float(diferencia_total),
        'pagos_por_metodo': pagos_por_metodo_global  # NUEVO: Desglose global por método de pago
    }, safe=False, json_dumps_params={'default': decimal_default})


@login_required
@grupos_permitidos(['Administradores', 'Meseros','Delivery','Operadores','Rapidos'])
def punto_venta(request):
    """Vista que valida el PIN y redirecciona"""
    
    # Verificar si ya hay una sesión activa, si es así, ir directamente al POS
    if 'pos_empleado_id' in request.session:
        return redirect('render_pos')
    
    if request.method == 'POST':
        pin = request.POST.get('pin')
        
        if pin:
            with connections['pagoda'].cursor() as cursor:
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT 
                        e.id as empleado_id,
                        concat(e.nombre," ", e.apellidos) AS nombre, 
                        r.nombre as rol_nombre, 
                        r.id as rol_id
                    FROM empleados e
                    JOIN roles r ON e.rol_id = r.id
                    WHERE pin_acceso = %s AND e.estatus = 'activo' AND e.rol_id IN(1,4,7,9,10)
                ''', [pin])
                
                empleado = dictfetchone(cursor)
                
                if empleado:
                    # Almacenar temporalmente en sesión
                    request.session['pos_empleado_id'] = empleado['empleado_id']
                    request.session['pos_empleado_nombre'] = empleado['nombre']
                    request.session['pos_empleado_rol_id'] = empleado['rol_id']
                    
                    # IMPORTANTE: Establecer tiempo de expiración corto
                    request.session.set_expiry(60000)  # 10 minutos
                    
                    # Redireccionar al dashboard - esto convierte POST a GET
                    return redirect('render_pos')
                else:
                    messages.error(request, 'PIN incorrecto o empleado inactivo')
    
    # Mostrar pantalla de PIN
    return render(request, 'pos/pin_acceso.html')

@login_required
@grupos_permitidos(['Administradores', 'Meseros','Delivery','Operadores','Rapidos'])
def render_pos(request):
    """Vista del punto de venta (POS)"""
    
    # Verificar si hay datos de empleado en la sesión
    if 'pos_empleado_id' not in request.session:
        return redirect('pos')  # Redirigir a pantalla de PIN
    
    # Extraer datos de la sesión
    empleado_id = request.session['pos_empleado_id']
    empleado_nombre = request.session['pos_empleado_nombre']
    rol_id = request.session['pos_empleado_rol_id']
    
    # Resto del código para cargar datos del POS
    sucursal_id = 1
    
    with connections['pagoda'].cursor() as cursor:
        # Obtener áreas y mesas (solo si el rol es mesero - rol_id = 4)
        areas = []
        if rol_id == 4:  # Solo meseros pueden ver mesas
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT a.id, a.nombre, a.descripcion,
                    (SELECT COUNT(*) FROM mesas m WHERE m.area_id = a.id) as total_mesas,
                    (SELECT COUNT(*) FROM mesas m WHERE m.area_id = a.id AND m.estatus = 'ocupada') as mesas_ocupadas
                FROM areas a
                WHERE a.sucursal_id = %s AND a.estatus = 'activa'
                ORDER BY a.nombre
            ''', [sucursal_id])
            areas = dictfetchall(cursor)
        
        # Obtener categorías de productos
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT id, nombre, imagen_url, color
            FROM categorias_productos
            WHERE visible_menu = 1
            ORDER BY orden
        ''')
        categorias = dictfetchall(cursor)
        
        # Obtener tipos de servicio según el rol
        tipos_servicio_ids = []
        
        if rol_id == 4:  # Mesero: solo comedor
            tipos_servicio_ids = [1]  # Comedor
        elif rol_id == 7:  # Operador: puede tomar domicilio, para llevar y pedidos programados
            tipos_servicio_ids = [2, 3, 4]  # Para llevar, Domicilio y Pedidos programados
        elif rol_id == 9:  # Solo domicilio
            tipos_servicio_ids = [3]  # Domicilio
        elif rol_id == 10:  # Solo para llevar
            tipos_servicio_ids = [2]  # Para llevar
        else:  # Otros roles podrían ver todos o ninguno según tu lógica
            tipos_servicio_ids = [1, 2, 3, 4]  # Todos
        
        # Convertir lista a tupla para SQL
        tipos_servicio_ids_tuple = tuple(tipos_servicio_ids)
        
        # Formatear la consulta SQL según la cantidad de IDs
        if len(tipos_servicio_ids) == 1:
            query = '''
                SET STATEMENT max_statement_time = 25 FOR SELECT id, nombre, costo_adicional
                FROM tipos_servicio
                WHERE activo = 1 AND id = %s
            '''
            cursor.execute(query, [tipos_servicio_ids[0]])
        else:
            query = '''
                SET STATEMENT max_statement_time = 25 FOR SELECT id, nombre, costo_adicional
                FROM tipos_servicio
                WHERE activo = 1 AND id IN %s
            '''
            cursor.execute(query, [tipos_servicio_ids_tuple])
            
        tipos_servicio = dictfetchall(cursor)
        
        # Obtener métodos de pago
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT id, nombre, requiere_comprobacion
            FROM metodos_pago
            WHERE activo = 1
        ''')
        metodos_pago = dictfetchall(cursor)

        # Obtener parámetros del sistema
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT imp_tk_cocina, permite_cobrar
            FROM parametros
            WHERE sucursal_id = %s
            LIMIT 1
        ''', [sucursal_id])
        
        parametros_row = cursor.fetchone()
        parametros = {
            'imp_tk_cocina': parametros_row[0] if parametros_row else 1,
            'permite_cobrar': parametros_row[1] if parametros_row else 1
        }
    
    return render(request, 'pos/index.html', {
        'areas': areas,
        'categorias': categorias,
        'tipos_servicio': tipos_servicio,
        'metodos_pago': metodos_pago,
        'empleado_id': empleado_id,
        'empleado_nombre': empleado_nombre,
        'rol_id': rol_id,
        'parametros': parametros 
    })


@login_required
def cerrar_sesion_pos(request):
    """Vista para cerrar sesión del POS"""
    # Limpiar solo las variables de sesión del POS
    if 'pos_empleado_id' in request.session:
        del request.session['pos_empleado_id']
    if 'pos_empleado_nombre' in request.session:
        del request.session['pos_empleado_nombre']
    if 'pos_empleado_rol_id' in request.session:
        del request.session['pos_empleado_rol_id']
    
    # Redirigir a la pantalla de PIN
    return redirect('pos')

@login_required
def mesas_area(request, area_id):
    """Vista para obtener mesas de un área específica (AJAX)"""
    # Obtener datos del empleado desde los parámetros de la solicitud
    empleado_id = request.GET.get('empleado_id')
    rol_id = request.GET.get('rol_id')
    
    # Validar que existan los parámetros
    if not empleado_id or not rol_id:
        return JsonResponse({"error": "Datos de empleado no proporcionados"}, status=403)
    
    # Convertir rol_id a entero
    try:
        empleado_id = int(empleado_id)
        rol_id = int(rol_id)
    except (ValueError, TypeError):
        return JsonResponse({"error": "Parámetros inválidos"}, status=400)
    
    # Solo los meseros (rol_id = 4) pueden ver mesas
    if rol_id != 4:
        return JsonResponse({"error": "No tiene permisos para ver mesas"}, status=403)
    
    with connections['pagoda'].cursor() as cursor:
        # Obtener todas las mesas del área
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT id, numero, capacidad, estatus, posicion_x, posicion_y, forma
            FROM mesas
            WHERE area_id = %s
            ORDER BY numero
        ''', [area_id])
        mesas = dictfetchall(cursor)
        
        # Para cada mesa ocupada o por_liberar, obtener información de la orden
        for mesa in mesas:
            # IMPORTANTE: Verificar ambos estados 'ocupada' y 'por_liberar'
            if mesa['estatus'] in ('ocupada', 'por_liberar'):
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT o.id, o.codigo_orden, o.fecha_apertura,
                           e.nombre as mesero, o.personas,
                           e.id as mesero_id,
                           TIME_TO_SEC(TIMEDIFF(NOW(), o.fecha_apertura))/60 as minutos_ocupada,
                           o.estatus as orden_estatus
                    FROM ordenes o
                    JOIN empleados e ON o.empleado_id = e.id
                    WHERE o.mesa_id = %s AND (o.estatus = 'abierta' OR o.estatus = 'por_cobrar')
                    ORDER BY o.fecha_apertura DESC
                    LIMIT 1
                ''', [mesa['id']])
                
                orden_data = cursor.fetchall()
                if orden_data:
                    # Convertir a diccionario
                    orden = {}
                    columns = [col[0] for col in cursor.description]
                    for i, col in enumerate(columns):
                        orden[col] = orden_data[0][i]
                    
                    # Agregar a la mesa
                    mesa['orden'] = orden
                    # Determinar si la mesa es atendida por este empleado
                    mesa['atendida_por_empleado'] = (orden['mesero_id'] == empleado_id)
                    
                    # Agregar para depuración
                    mesa['debug_info'] = f"Mesa ID: {mesa['id']}, Estado: {mesa['estatus']}, Orden ID: {orden['id']}, Mesero ID: {orden['mesero_id']}, Empleado actual: {empleado_id}"

    
    return JsonResponse(mesas, safe=False, json_dumps_params={'default': decimal_default})

@csrf_exempt
@login_required
def productos_categoria(request, categoria_id):
    """Vista para obtener productos de una categoría (AJAX)"""
    with connections['pagoda'].cursor() as cursor:
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT id, nombre, descripcion, precio_venta, imagen_url, dias_disponibles, 
                iva_incluido, porcentaje_iva, control_inventario, stock_actual
            FROM productos
            WHERE categoria_id = %s 
                 AND visible_menu = 1 
                 AND estatus = 'activo'
                AND (
                    dias_disponibles IS NULL 
                     OR FIND_IN_SET(
                        CASE DAYOFWEEK(NOW())
                            WHEN 1 THEN 7
                            WHEN 2 THEN 1
                            WHEN 3 THEN 2
                            WHEN 4 THEN 3
                            WHEN 5 THEN 4
                            WHEN 6 THEN 5
                            WHEN 7 THEN 6
                        END,
                        dias_disponibles
                    ) > 0
                )
            ORDER BY orden, nombre
        ''', [categoria_id])
        productos = dictfetchall(cursor)
        
        return JsonResponse(productos, safe=False, json_dumps_params={'default': decimal_default})

@csrf_exempt
@login_required
@grupos_permitidos(['Administradores', 'Meseros','Delivery','Operadores','Rapidos'])
def detalle_producto(request, producto_id):
    """Vista para obtener detalle de un producto incluyendo modificadores (AJAX)"""
    with connections['pagoda'].cursor() as cursor:
        # Obtener datos del producto
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT p.id, p.nombre, p.descripcion, p.precio_venta, p.imagen_url,
                   c.nombre as categoria, um.nombre as unidad_medida
            FROM productos p
            LEFT JOIN categorias_productos c ON p.categoria_id = c.id
            LEFT JOIN unidades_medida um ON p.unidad_medida_id = um.id
            WHERE p.id = %s
        ''', [producto_id])
        producto = dictfetchall(cursor)[0] if cursor.rowcount > 0 else None
        
        if producto:
            # Obtener modificadores del producto
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT m.id, m.nombre, m.descripcion, m.precio_adicional, 
                       m.maximo_selecciones, pm.obligatorio
                FROM producto_modificadores pm
                JOIN modificadores m ON pm.modificador_id = m.id
                WHERE pm.producto_id = %s
            ''', [producto_id])
            modificadores = dictfetchall(cursor)
            
            # Para cada modificador, obtener sus opciones
            for mod in modificadores:
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT id, nombre, precio_adicional
                    FROM opciones_modificador
                    WHERE modificador_id = %s AND disponible = 1
                    ORDER BY orden
                ''', [mod['id']])
                mod['opciones'] = dictfetchall(cursor)
            
            producto['modificadores'] = modificadores
    
    return JsonResponse(producto, safe=False, json_dumps_params={'default': decimal_default})

@login_required
def pin_acceso(request):
    """Vista para pantalla de ingreso de PIN"""
    if request.method == 'POST':
        pin = request.POST.get('pin')
        
        if not pin:
            messages.error(request, 'Debe ingresar un PIN de acceso')
            return render(request, 'pos/pin_acceso.html')
        
        with connections['pagoda'].cursor() as cursor:
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT 
                    e.id as empleado_id,
                    concat(e.nombre," ", e.apellidos) AS nombre, 
                    r.nombre as rol_nombre, 
                    r.id as rol_id
                FROM empleados e
                JOIN roles r ON e.rol_id = r.id
                WHERE pin_acceso = %s AND e.estatus = 'activo'
            ''', [pin])
            
            empleado = dictfetchone(cursor)
            
            if not empleado:
                messages.error(request, 'PIN incorrecto o empleado inactivo')
                return render(request, 'pos/pin_acceso.html')
            
            # Guardar datos del empleado en sesión
            request.session['pos_empleado_id'] = empleado['empleado_id']
            request.session['pos_empleado_nombre'] = empleado['nombre']
            request.session['pos_empleado_rol_id'] = empleado['rol_id']
            request.session['pos_empleado_rol'] = empleado['rol_nombre']
            
            # Redirigir al POS
            return redirect('pos')
    
    # Limpiar sesión de POS en caso de que exista
    if 'pos_empleado_id' in request.session:
        del request.session['pos_empleado_id']
        del request.session['pos_empleado_nombre']
        del request.session['pos_empleado_rol_id']
        del request.session['pos_empleado_rol']
    
    return render(request, 'pos/pin_acceso.html')

@csrf_exempt
@login_required
def verificar_pin_empleado(request):
    """Verificar PIN del empleado antes de procesar una acción"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        pin = data.get('pin')
        
        if not pin:
            return JsonResponse({'error': 'PIN requerido'}, status=400)
        
        # Verificar si el PIN corresponde al empleado en sesión
        with connections['pagoda'].cursor() as cursor:
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT id
                FROM empleados
                WHERE id = %s AND pin_acceso = %s AND estatus = 'activo'
            ''', [request.session.get('pos_empleado_id'), pin])
            
            empleado = cursor.fetchone()
            
            if not empleado:
                return JsonResponse({
                    'success': False,
                    'error': 'PIN incorrecto o no autorizado'
                }, status=401)
            
            return JsonResponse({
                'success': True,
                'empleado_id': empleado[0]
            })
            
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Formato JSON inválido'}, status=400)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@csrf_exempt
@login_required
def verificar_pin_empleado_detalles(request):
    """Verificar PIN del empleado antes de procesar una acción"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        pin = data.get('pin')
        orden_id = data.get('orden_id')
        
        if not pin or not orden_id:
            return JsonResponse({'error': 'PIN y orden_id son requeridos'}, status=400)
        
        # Verificar si el PIN corresponde al empleado que hizo esa orden
        with connections['pagoda'].cursor() as cursor:
            # Primero obtener el empleado_id de la orden
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT empleado_id
                FROM ordenes
                WHERE id = %s
            ''', [orden_id])
            
            orden = cursor.fetchone()
            if not orden:
                return JsonResponse({
                    'success': False,
                    'error': 'Orden no encontrada'
                }, status=404)
                
            empleado_id = orden[0]
            
            # Verificar el PIN del empleado
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT id
                FROM empleados
                WHERE id = %s AND pin_acceso = %s AND estatus = 'activo'
            ''', [empleado_id, pin])
            
            empleado = cursor.fetchone()
            
            if not empleado:
                return JsonResponse({
                    'success': False,
                    'error': 'PIN incorrecto o no autorizado'
                }, status=401)
            
            return JsonResponse({
                'success': True,
                'empleado_id': empleado[0]
            })
            
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Formato JSON inválido'}, status=400)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)        


from django.contrib.auth.decorators import login_required
from django.db import connections
from django.http import JsonResponse
import logging

logger = logging.getLogger(__name__)

@login_required
def cliente_ordenes_hoy(request, cliente_id):
    """
    Endpoint API para verificar si un cliente tiene órdenes del día actual
    """
    try:
        with connections['pagoda'].cursor() as cursor:
            # Consulta SQL para obtener órdenes del cliente hoy
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR 
                SELECT 
                    o.id, 
                    o.fecha_apertura AS fecha,
                    ts.nombre as tipo_servicio,
                    CONCAT(c.nombre, ' ', IFNULL(c.apellidos, '')) as cliente,
                    o.programado,
                    o.fecha_programado,
                    o.estatus AS estatus_cobro,
                    IFNULL(o.estatus_preparacion, 'por preparar') as estatus_preparacion,
                    o.estatus_entrega
                FROM ordenes o
                LEFT JOIN mesas m ON o.mesa_id = m.id
                LEFT JOIN clientes c ON o.cliente_id = c.id
                JOIN empleados e ON o.empleado_id = e.id
                JOIN tipos_servicio ts ON o.tipo_servicio_id = ts.id
                WHERE o.cliente_id = %s
                AND DATE(o.fecha_apertura) = CURDATE()
                AND o.estatus NOT IN ('cerrada', 'cancelada')
                AND o.cliente_id <> 1
            ''', [cliente_id])
            
            # Obtener resultados
            ordenes = []
            for row in cursor.fetchall():
                ordenes.append({
                    'id': row[0],
                    'fecha': row[1],
                    'tipo_servicio': row[2],
                    'cliente': row[3],
                    'programado': row[4],
                    'fecha_programado': row[5],
                    'estatus_cobro': row[6],
                    'estatus_preparacion': row[7],
                    'estatus_entrega': row[8]
                })
            
            return JsonResponse({
                'success': True,
                'ordenes': ordenes
            })
            
    except Exception as e:
        logger.error(f"Error al obtener órdenes del cliente: {str(e)}", exc_info=True)
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)

@login_required
def cliente_forma_pago_predeterminada(request, cliente_id):
    """
    Endpoint API para obtener la forma de pago predeterminada de un cliente
    """
    try:
        with connections['pagoda'].cursor() as cursor:
            # Consulta SQL para obtener la forma de pago predeterminada
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT 
                    forma_pago_predeterminada
                FROM clientes 
                WHERE id = %s
            ''', [cliente_id])
            
            # Obtener el resultado
            result = cursor.fetchone()
            
            if result:
                forma_pago_predeterminada = result[0]
            else:
                forma_pago_predeterminada = None
            
            return JsonResponse({
                'success': True,
                'forma_pago_predeterminada': forma_pago_predeterminada
            })
            
    except Exception as e:
        logger.error(f"Error al obtener forma de pago del cliente: {str(e)}", exc_info=True)
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)


@csrf_exempt
@login_required
@grupos_permitidos(['Administradores', 'Meseros','Delivery','Operadores','Rapidos'])
def crear_orden(request):
    """Vista para crear una nueva orden con logging detallado"""
    logger.info("Iniciando creación de orden")
    
    # Verificar si hay sesión de empleado POS activa
    if 'pos_empleado_id' not in request.session:
        logger.error("Sesión de empleado no válida")
        return JsonResponse({'error': 'Sesión de empleado no válida'}, status=403)
    
    empleado_id = request.session['pos_empleado_id']
    rol_id = request.session['pos_empleado_rol_id']
    
    if request.method != 'POST':
        logger.error("Método no permitido")
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        logger.debug("Parseando JSON del request")
        data = json.loads(request.body)
        
        # Extraer datos con valores por defecto
        tipo_servicio_id = data.get('tipo_servicio_id')
        mesa_id = data.get('mesa_id')
        cliente_id = data.get('cliente_id')
        direccion_id = data.get('direccion_id')
        personas = data.get('personas', 1)
        costo_entrega_manual = data.get('costo_entrega_manual')
        cubiertos = data.get('cubiertos', 0)
        programado = data.get('programado', 0)
        fecha_programado = data.get('fecha_programado')
        items = data.get('items', [])
        pagos = data.get('pagos', [])  # NUEVO: Extraer datos de pagos
        pin_verificado = data.get('pin_verificado', False)
        nombre_tk = data.get('nombre_tk')  # Capturar el nombre de referencia
        
        # Si es tipo de servicio 4 (comedor programado), ajustar valores automáticos
        if tipo_servicio_id == 4:
            programado = 1  # Siempre es programado
            cliente_id = 1  # Siempre cliente genérico (público en general)
            es_reserva = 1  # Siempre es reserva
            
            # Validar que tenga fecha programada
            if not fecha_programado:
                logger.error("Falta fecha_programado para pedido de comedor programado")
                return JsonResponse({'error': 'La fecha programada es obligatoria para pedidos de comedor programados'}, status=400)
                
            # Validar que tenga nombre de referencia
            if not nombre_tk:
                logger.error("Falta nombre_tk para pedido de comedor programado")
                return JsonResponse({'error': 'El nombre de referencia es obligatorio para pedidos de comedor programados'}, status=400)
        else:
            es_reserva = 0  # Para otros tipos, no es reserva por defecto
        
        # Verificar PIN si no se ha verificado
        if not pin_verificado:
            logger.error("Orden sin verificación de PIN")
            return JsonResponse({
                'error': 'Verificación de PIN requerida',
                'require_pin': True
            }, status=400)
        
        # Validar permisos según grupo del usuario en lugar de rol_id
        grupos_usuario = request.user.groups.values_list('name', flat=True)
        tiene_permiso = False
        
        # Validar permisos según rol
        if tipo_servicio_id == 1:  # Comedor
            if 'Administradores' in grupos_usuario or 'Meseros' in grupos_usuario:
                tiene_permiso = True
        elif tipo_servicio_id == 2:  # Para llevar
            if 'Rapidos' in grupos_usuario or 'Administradores' in grupos_usuario or 'Operadores' in grupos_usuario:
                tiene_permiso = True
        elif tipo_servicio_id == 3:  # Domicilio
            if 'Delivery' in grupos_usuario or 'Administradores' in grupos_usuario or 'Operadores' in grupos_usuario:
                tiene_permiso = True
        elif tipo_servicio_id == 4:  # Pedidos de comedor programados
            if 'Administradores' in grupos_usuario or 'Operadores' in grupos_usuario:
                tiene_permiso = True
                
        if not tiene_permiso:
            logger.error(f"Usuario sin permisos para tipo de servicio {tipo_servicio_id}")
            return JsonResponse({
                'success': False,
                'error': 'sin_permisos',
                'message': f'No tiene permiso para ejecutar esta acción en órdenes de tipo {tipo_servicio_id}'
            }, status=403)
        
        logger.debug(
            "Datos recibidos: \n" +
            f"  tipo_servicio_id: {tipo_servicio_id}\n" +
            f"  mesa_id: {mesa_id}\n" +
            f"  cliente_id: {cliente_id}\n" +
            f"  direccion_id: {direccion_id}\n" +
            f"  personas: {personas}\n" +
            f"  programado: {programado}\n" +
            f"  fecha_programado: {fecha_programado}\n" +
            f"  items_count: {len(items)}\n" +
            f"  pagos_count: {len(pagos)}\n" +  # NUEVO: Log de pagos
            f"  es_reserva: {es_reserva}"      # NUEVO: Log de es_reserva
        )

        # Validaciones básicas
        if not tipo_servicio_id:
            logger.error("Falta tipo_servicio_id")
            return JsonResponse({'error': 'Falta especificar el tipo de servicio'}, status=400)
        
        if not items:
            logger.error("No hay items en la orden")
            return JsonResponse({'error': 'La orden no contiene productos'}, status=400)
        
        # NUEVO: Validar pagos para tipos 2 y 3
        if tipo_servicio_id in [2, 3] and not pagos:
            logger.error("No hay pagos registrados para orden de tipo 2 o 3")
            return JsonResponse({'error': 'Para órdenes de este tipo debe registrar al menos una forma de pago'}, status=400)
        
        sucursal_id = 1  # TODO: Debería venir de la sesión o perfil del usuario
        
        logger.info(f"Empleado ID: {empleado_id}, Sucursal ID: {sucursal_id}")

        with connections['pagoda'].cursor() as cursor:
            try:
                # 1. Verificar corte de caja abierto - SOLO SI HAY PAGOS REGISTRADOS
                if pagos:
                    logger.debug("Verificando corte de caja abierto")
                    cursor.execute('''
                        SET STATEMENT max_statement_time = 25 FOR SELECT id, empleado_id FROM cortes_caja 
                        WHERE estatus = 'abierto' AND caja_id IN 
                            (SELECT id FROM cajas WHERE sucursal_id = %s)
                        LIMIT 1
                    ''', [sucursal_id])
                    
                    corte = cursor.fetchone()
                    if not corte:
                        logger.error("No hay corte de caja abierto")
                        
                
                # 2. Verificar disponibilidad de mesa si aplica (no aplica para tipo 4)
                if mesa_id and tipo_servicio_id != 4:
                    logger.debug(f"Verificando mesa ID: {mesa_id}")
                    cursor.execute('''
                        SET STATEMENT max_statement_time = 25 FOR SELECT id, numero, estatus FROM mesas WHERE id = %s
                    ''', [mesa_id])
                    
                    mesa = cursor.fetchone()
                    if not mesa:
                        logger.error(f"Mesa {mesa_id} no encontrada")
                        return JsonResponse({'error': 'Mesa no encontrada'}, status=404)
                    
                    if mesa[2] != 'disponible':
                        logger.error(f"Mesa {mesa_id} no disponible. Estatus: {mesa[2]}")
                        return JsonResponse({
                            'error': f'Mesa {mesa[1]} no está disponible (estado: {mesa[2]})'
                        }, status=400)

                # 3. Verificación de stock con bloqueo (FOR UPDATE)
                productos_sin_stock = []
                logger.debug("Iniciando verificación de stock")
                
                for item in items:
                    producto_id = item.get('producto_id')
                    cantidad = item.get('cantidad', 1)
                    
                    logger.debug(f"Verificando producto ID: {producto_id}, cantidad: {cantidad}")
                    
                    cursor.execute('''
                        SET STATEMENT max_statement_time = 25 FOR SELECT id, nombre, stock_actual, control_inventario 
                        FROM productos 
                        WHERE id = %s FOR UPDATE
                    ''', [producto_id])
                    
                    producto = cursor.fetchone()
                    if not producto:
                        logger.error(f"Producto {producto_id} no encontrado")
                        productos_sin_stock.append({
                            'producto_id': producto_id,
                            'error': 'Producto no encontrado'
                        })
                        continue
                    
                    if producto[3]:  # Si control_inventario es True
                        stock_actual = producto[2] or 0
                        if stock_actual < cantidad:
                            logger.warning(f"Stock insuficiente: Producto {producto_id} ({producto[1]}). Stock: {stock_actual}, Solicitado: {cantidad}")
                            productos_sin_stock.append({
                                'producto_id': producto_id,
                                'nombre': producto[1],
                                'stock_actual': stock_actual,
                                'cantidad_solicitada': cantidad
                            })
                
                if productos_sin_stock:
                    logger.error("Stock insuficiente para algunos productos")
                    return JsonResponse({
                        'success': False,
                        'error': 'stock_insuficiente',
                        'message': 'Algunos productos no tienen suficiente stock',
                        'productos_sin_stock': [{
                            'producto_id': p['producto_id'],
                            'nombre': p.get('nombre', 'Producto desconocido'),
                            'stock_actual': float(p.get('stock_actual', 0)),
                            'cantidad_solicitada': p.get('cantidad_solicitada', 0)
                        } for p in productos_sin_stock]
                    }, status=400)

                # 4. Generar código de orden
                cursor.execute('SET STATEMENT max_statement_time = 25 FOR SELECT MAX(id) FROM ordenes')
                ultimo_id = cursor.fetchone()[0] or 0
                nuevo_id = ultimo_id + 1
                codigo_orden = f"ORD-{nuevo_id:06d}"
                
                logger.info(f"Creando orden ID: {nuevo_id}, Código: {codigo_orden}")

                # Iniciar transacción
                cursor.execute('START TRANSACTION')
                logger.debug("Transacción iniciada")

                try:
                    # 5. Crear la orden - Añadir campo es_reserva
                    cursor.execute('''
                        INSERT INTO ordenes (
                            id, sucursal_id, tipo_servicio_id, mesa_id, 
                            cliente_id, empleado_id, direccion_entrega_id, codigo_orden, 
                            personas, estatus, fecha_apertura, programado, fecha_programado, nombre_tk, cubiertos, es_reserva
                        ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, NOW(), %s, %s, %s, %s, %s)
                    ''', [
                        nuevo_id, sucursal_id, tipo_servicio_id, mesa_id,
                        cliente_id, empleado_id, direccion_id, codigo_orden,
                        personas, 'abierta', programado, fecha_programado, nombre_tk, cubiertos, es_reserva
                    ])
                    
                    orden_id = nuevo_id
                    logger.debug(f"Orden creada ID: {orden_id}")

                    # 6. Registrar cambio de estado
                    cursor.execute('''
                        INSERT INTO orden_historial_estados (
                            orden_id, estado_anterior, estado_nuevo, empleado_id, motivo
                        ) VALUES (%s, NULL, 'abierta', %s, 'Creación de orden')
                    ''', [orden_id, empleado_id])
                    logger.debug("Historial de estado registrado")

                    # 7. Actualizar estado de la mesa si aplica (no para tipo 4)
                    if mesa_id and tipo_servicio_id != 4:
                        cursor.execute('''
                            UPDATE mesas SET estatus = 'ocupada' WHERE id = %s
                        ''', [mesa_id])
                        logger.debug(f"Mesa {mesa_id} actualizada a 'ocupada'")

                    # 8. Procesar items y actualizar stock
                    subtotal = decimal.Decimal(0)
                    impuestos = decimal.Decimal(0)
                    
                    logger.debug(f"Procesando {len(items)} items")
                    
                    for item in items:
                        producto_id = item.get('producto_id')
                        cantidad = item.get('cantidad', 1)
                        notas = item.get('notas', '')
                        modificadores = item.get('modificadores', [])
                        
                        logger.debug(f"Procesando item - Producto ID: {producto_id}, Cantidad: {cantidad}")

                        # Obtener datos del producto
                        cursor.execute('''
                            SET STATEMENT max_statement_time = 25 FOR SELECT precio_venta, iva_incluido, porcentaje_iva, control_inventario
                            FROM productos WHERE id = %s
                        ''', [producto_id])
                        producto = cursor.fetchone()
                        
                        precio_unitario = producto[0]
                        iva_incluido = producto[1]
                        porcentaje_iva = producto[2] or 0  # Usar 0 si es NULL
                        control_inventario = producto[3]
                        
                        # Actualizar stock si es necesario
                        if control_inventario:
                            # 1. Primero actualizar el stock
                            cursor.execute('''
                                UPDATE productos 
                                SET stock_actual = stock_actual - %s 
                                WHERE id = %s AND control_inventario = 1
                            ''', [cantidad, producto_id])
                            
                            # 2. Luego verificar el nuevo stock
                            cursor.execute('''
                                SET STATEMENT max_statement_time = 25 FOR SELECT stock_actual FROM productos WHERE id = %s
                            ''', [producto_id])
                            
                            nuevo_stock = cursor.fetchone()[0]
                            
                            if nuevo_stock < 0:
                                cursor.execute('ROLLBACK')
                                logger.error(f"Stock insuficiente después de actualizar - Producto ID: {producto_id}")
                                
                                # Calcular la cantidad total solicitada para este producto en la orden
                                total_solicitado = sum(item['cantidad'] for item in items if item.get('producto_id') == producto_id)
                                
                                # Obtener información detallada del producto para mostrar al cliente
                                cursor.execute('''
                                    SET STATEMENT max_statement_time = 25 FOR SELECT id, nombre, stock_actual FROM productos WHERE id = %s
                                ''', [producto_id])
                                producto_info = cursor.fetchone()
                                
                                return JsonResponse({
                                    'success': False,
                                    'error': 'stock_insuficiente',
                                    'message': 'Algunos productos no tienen suficiente stock',
                                    'productos_sin_stock': [{
                                        'producto_id': producto_info[0],
                                        'nombre': producto_info[1],
                                        'stock_actual': float(producto_info[2]),
                                        'cantidad_solicitada': total_solicitado  # Mostrar la suma total solicitada
                                    }]
                                }, status=400)
                            
                            logger.debug(f"Stock actualizado - Producto ID: {producto_id}, Nuevo stock: {nuevo_stock}")

                        # Procesar modificadores
                        precio_modificadores = decimal.Decimal(0)
                        for mod in modificadores:
                            opcion_id = mod.get('opcion_id')
                            cursor.execute('''
                                SET STATEMENT max_statement_time = 25 FOR SELECT precio_adicional FROM opciones_modificador WHERE id = %s
                            ''', [opcion_id])
                            precio_add = cursor.fetchone()[0] or 0
                            precio_modificadores += decimal.Decimal(str(precio_add))
                        
                        precio_final = decimal.Decimal(str(precio_unitario)) + precio_modificadores
                        
                        # MODIFICACIÓN CRÍTICA: Calcular subtotal e impuestos correctamente
                        # Precio final es el precio que paga el cliente (con o sin impuestos)
                        precio_total_item = precio_final * decimal.Decimal(str(cantidad))
                        
                        # NUEVA INTERPRETACIÓN:
                        # Si iva_incluido = 0: El producto NO CAUSA impuestos (está exento)
                        # Si iva_incluido = 1: El producto CAUSA impuestos y el precio YA INCLUYE el IVA
                        
                        if iva_incluido == 1 and porcentaje_iva > 0:
                            # El producto CAUSA impuestos y el precio YA INCLUYE el IVA
                            # Calcular cuánto del precio total es IVA (para contabilidad)
                            iva_factor = decimal.Decimal(str(porcentaje_iva)) / 100 + 1
                            precio_sin_iva = precio_final / iva_factor
                            subtotal_item = precio_sin_iva * decimal.Decimal(str(cantidad))
                            iva_item = precio_total_item - subtotal_item
                            logger.debug(f"Item con IVA incluido - Precio: {precio_final}, Subtotal: {subtotal_item}, IVA: {iva_item}")
                        else:
                            # El producto NO CAUSA impuestos (está exento)
                            # O el porcentaje de IVA es 0
                            subtotal_item = precio_total_item
                            iva_item = decimal.Decimal(0)
                            logger.debug(f"Item exento de IVA - Precio: {precio_final}, Subtotal: {subtotal_item}")
                        
                        # Insertar detalle de orden (actualizado con los cálculos correctos)
                        cursor.execute('''
                            INSERT INTO orden_detalles (
                                orden_id, producto_id, cantidad, precio_unitario,
                                subtotal, iva, total, notas
                            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                        ''', [
                            orden_id, producto_id, cantidad, float(precio_final),
                            float(subtotal_item), float(iva_item), 
                            float(precio_total_item),  # Total es el precio final que ve el cliente
                            notas
                        ])
                        
                        detalle_id = cursor.lastrowid
                        logger.debug(f"Detalle de orden creado ID: {detalle_id}")

                        # Insertar modificadores
                        for mod in modificadores:
                            opcion_id = mod.get('opcion_id')
                            cursor.execute('''
                                SET STATEMENT max_statement_time = 25 FOR SELECT precio_adicional FROM opciones_modificador WHERE id = %s
                            ''', [opcion_id])
                            precio_mod = cursor.fetchone()[0] or 0
                            
                            cursor.execute('''
                                INSERT INTO orden_producto_modificadores (
                                    orden_detalle_id, opcion_modificador_id, cantidad, precio
                                ) VALUES (%s, %s, %s, %s)
                            ''', [detalle_id, opcion_id, 1, precio_mod])
                        
                        # Acumular totales
                        subtotal += subtotal_item
                        impuestos += iva_item

                    # 9. Calcular costo de entrega si es domicilio
                    costo_entrega = decimal.Decimal(0)
                    if int(tipo_servicio_id) == 3:  # Domicilio
                        if costo_entrega_manual is not None:
                            # Usar el costo de entrega manual del frontend
                            costo_entrega = decimal.Decimal(str(costo_entrega_manual))
                        else:
                            # Usar el costo por defecto del tipo de servicio
                            cursor.execute('''
                                SET STATEMENT max_statement_time = 25 FOR SELECT costo_adicional FROM tipos_servicio WHERE id = %s
                            ''', [tipo_servicio_id])
                            costo_entrega = decimal.Decimal(str(cursor.fetchone()[0] or 0))
                        logger.debug(f"Costo de entrega: {costo_entrega}")

                    # 10. Actualizar totales de la orden
                    total = subtotal + impuestos + costo_entrega
                    logger.debug(f"Totales calculados: Subtotal={subtotal}, Impuestos={impuestos}, Costo entrega={costo_entrega}, Total={total}")
                    
                    cursor.execute('''
                        UPDATE ordenes SET 
                            subtotal = %s, 
                            impuestos = %s, 
                            costo_entrega = %s, 
                            total = %s
                        WHERE id = %s
                    ''', [
                        float(subtotal), 
                        float(impuestos), 
                        float(costo_entrega), 
                        float(total), 
                        orden_id
                    ])
                    
                    logger.info(f"Totales actualizados - Subtotal: {subtotal}, Impuestos: {impuestos}, Total: {total}")

                    # NUEVO: Procesar los pagos registrados si los hay
                    if pagos:
                        # Validar total de pagos
                        total_pagos = sum(decimal.Decimal(str(pago.get('monto', 0))) for pago in pagos)
                        
                        if abs(total_pagos - total) > decimal.Decimal('0.01'):
                            cursor.execute('ROLLBACK')
                            logger.error(f"Total de pagos ({total_pagos}) no coincide con total de orden ({total})")
                            
                            return JsonResponse({
                                'success': False,
                                'error': 'total_pagos_incorrecto',
                                'message': f'El total de pagos registrados ({total_pagos}) no coincide con el total de la orden ({total})'
                            }, status=400)
                        
                        # Registrar pagos
                        logger.debug(f"Procesando {len(pagos)} pagos")
                        
                        for pago in pagos:
                            metodo_pago_id = pago.get('metodo_pago_id')
                            monto = pago.get('monto')
                            referencia = pago.get('referencia', '')
                            
                            if not metodo_pago_id or not monto:
                                continue
                            
                            cursor.execute('''
                                INSERT INTO pagos (
                                    orden_id, metodo_pago_id, empleado_id, caja_id, corte_caja_id,
                                    monto, referencia, estatus, fecha_pago
                                ) VALUES (%s, %s, %s, NULL, NULL, %s, %s, %s, NOW())
                            ''', [
                                orden_id, metodo_pago_id, empleado_id, monto, referencia, 'completado'
                            ])
                            
                            logger.debug(f"Pago registrado: Método {metodo_pago_id}, Monto {monto}, Referencia: {referencia}")

                    # Determinar estatus entrega cuando es Domicilio o para Llevar
                    if int(tipo_servicio_id) == 3 or int(tipo_servicio_id) == 2:  # Domicilio o Rápidos
                        cursor.execute('''
                            UPDATE ordenes SET estatus_entrega = %s WHERE id = %s
                        ''', ['abierta', orden_id])

                        cursor.execute('''
                            UPDATE ordenes SET estatus = 'por_cobrar' WHERE id = %s
                        ''', [orden_id])
                    
                    # Para pedidos de comedor programados, establecer estatus preparación
                    if int(tipo_servicio_id) == 4:  # Comedor programado
                        cursor.execute('''
                            UPDATE ordenes SET estatus_preparacion = NULL WHERE id = %s
                        ''', [orden_id])

                    # Confirmar transacción
                    cursor.execute('COMMIT')
                    logger.info("Transacción confirmada")

                    return JsonResponse({
                        'success': True,
                        'orden_id': orden_id,
                        'codigo_orden': codigo_orden,
                        'totales': {
                            'subtotal': float(subtotal),
                            'impuestos': float(impuestos),
                            'costo_entrega': float(costo_entrega),
                            'total': float(total)
                        }
                    })
                    
                except Exception as e:
                    cursor.execute('ROLLBACK')
                    logger.error(f"Error en transacción: {str(e)}", exc_info=True)
                    return JsonResponse({
                        'error': 'Error al procesar la orden',
                        'detalle': str(e)
                    }, status=500)
                    
            except Exception as e:
                logger.error(f"Error general: {str(e)}", exc_info=True)
                return JsonResponse({
                    'error': 'Error al procesar la solicitud',
                    'detalle': str(e)
                }, status=500)
                
    except json.JSONDecodeError as e:
        logger.error(f"Error decodificando JSON: {str(e)}")
        return JsonResponse({
            'error': 'Formato JSON inválido',
            'detalle': str(e)
        }, status=400)
    except Exception as e:
        logger.error(f"Error inesperado: {str(e)}", exc_info=True)
        return JsonResponse({
            'error': 'Error interno del servidor',
            'detalle': str(e)
        }, status=500)
    
@csrf_exempt
@login_required
def detalle_orden(request, orden_id):
    """Vista para obtener detalle de una orden"""
    with connections['pagoda'].cursor() as cursor:
        # Obtener datos de la orden
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT o.*, 
                   ts.nombre as tipo_servicio,
                   m.numero as mesa_numero,
                   CONCAT(c.nombre, ' ', IFNULL(c.apellidos, '')) as cliente,
                   CONCAT(e.nombre, ' ', e.apellidos) as empleado,
                   CASE
                       WHEN o.tipo_servicio_id = 3 THEN
                           (SELECT CONCAT(calle, ' ', numero_exterior, ', ', colonia)
                            FROM direcciones_cliente
                            WHERE id = o.direccion_entrega_id)
                       ELSE NULL
                   END as direccion_entrega
            FROM ordenes o
            LEFT JOIN tipos_servicio ts ON o.tipo_servicio_id = ts.id
            LEFT JOIN mesas m ON o.mesa_id = m.id
            LEFT JOIN clientes c ON o.cliente_id = c.id
            JOIN empleados e ON o.empleado_id = e.id
            WHERE o.id = %s
        ''', [orden_id])
        
        orden = dictfetchall(cursor)[0] if cursor.rowcount > 0 else None
        
        if orden:
            # Obtener items de la orden
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT od.*, p.nombre as producto, p.imagen_url
                FROM orden_detalles od
                JOIN productos p ON od.producto_id = p.id
                WHERE od.orden_id = %s
            ''', [orden_id])
            
            items = dictfetchall(cursor)
            
            # Para cada item, obtener sus modificadores
            for item in items:
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT opm.*, om.nombre
                    FROM orden_producto_modificadores opm
                    JOIN opciones_modificador om ON opm.opcion_modificador_id = om.id
                    WHERE opm.orden_detalle_id = %s
                ''', [item['id']])
                item['modificadores'] = dictfetchall(cursor)
            
            orden['items'] = items
            
            # Obtener pagos de la orden
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT p.*, mp.nombre as metodo_pago
                FROM pagos p
                JOIN metodos_pago mp ON p.metodo_pago_id = mp.id
                WHERE p.orden_id = %s
                And p.estatus = 'completado'
            ''', [orden_id])
            
            orden['pagos'] = dictfetchall(cursor)
    
    return JsonResponse(orden, safe=False, json_dumps_params={'default': decimal_default})

@csrf_exempt
@login_required
def orden_items_ajax(request, orden_id):
    """Endpoint para obtener los items de una orden vía AJAX"""
    if request.method != 'GET':
        return JsonResponse({'success': False, 'error': 'Método no permitido'})
        
    with connections['pagoda'].cursor() as cursor:
        # Primero verificar si la orden existe
        cursor.execute('''
            SELECT id, subtotal, impuestos, total, costo_entrega, estatus
            FROM ordenes 
            WHERE id = %s
        ''', [orden_id])
        
        orden_data = dictfetchall(cursor)
        if not orden_data:
            return JsonResponse({'success': False, 'error': 'Orden no encontrada'})
            
        orden = orden_data[0]
        
        # Obtener items de la orden
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT od.*, p.nombre as producto, p.imagen_url
            FROM orden_detalles od
            JOIN productos p ON od.producto_id = p.id
            WHERE od.orden_id = %s
        ''', [orden_id])
        
        items = dictfetchall(cursor)
        
        # Para cada item, obtener sus modificadores
        for item in items:
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT opm.*, om.nombre
                FROM orden_producto_modificadores opm
                JOIN opciones_modificador om ON opm.opcion_modificador_id = om.id
                WHERE opm.orden_detalle_id = %s
            ''', [item['id']])
            item['modificadores'] = dictfetchall(cursor)
        
        # Obtener datos de totales
        totales = {
            'subtotal': float(orden['subtotal']),
            'impuestos': float(orden['impuestos']),
            'total': float(orden['total']),
            'costo_entrega': float(orden['costo_entrega']) if orden['costo_entrega'] else 0
        }
        
        return JsonResponse({
            'success': True,
            'items': items,
            'totales': totales,
            'estatus': orden['estatus']
        }, json_dumps_params={'default': decimal_default})


@csrf_exempt
@login_required
def actualizar_estado_orden(request, orden_id):
    """Vista para actualizar el estado de una orden"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        nuevo_estado = data.get('estado')
        motivo = data.get('motivo', '')
        
        if not nuevo_estado:
            return JsonResponse({'error': 'Estado no especificado'}, status=400)
        
        empleado_id = request.session.get('empleado_id')
        
        with connections['pagoda'].cursor() as cursor:
            # Obtener estado actual
            cursor.execute('SET STATEMENT max_statement_time = 25 FOR SELECT estatus, mesa_id FROM ordenes WHERE id = %s', [orden_id])
            result = cursor.fetchone()
            if not result:
                return JsonResponse({'error': 'Orden no encontrada'}, status=404)
            
            estado_actual = result[0]
            mesa_id = result[1]
            
            # Iniciar transacción
            cursor.execute('START TRANSACTION')
            
            try:
                # Actualizar estado
                cursor.execute('''
                    UPDATE ordenes 
                    SET estatus = %s
                    WHERE id = %s
                ''', [nuevo_estado, orden_id])
                
                # Registrar historial de cambio
                cursor.execute('''
                    INSERT INTO orden_historial_estados (
                        orden_id, estado_anterior, estado_nuevo, empleado_id, motivo
                    ) VALUES (%s, %s, %s, %s, %s)
                ''', [orden_id, estado_actual, nuevo_estado, empleado_id, motivo])
                
                # Si se cierra o cancela la orden y tiene mesa, liberar la mesa
                if nuevo_estado in ('cerrada', 'cancelada') and mesa_id:
                    cursor.execute('UPDATE mesas SET estatus = %s WHERE id = %s', 
                                   ['disponible', mesa_id])
                
                # Actualizar campos específicos según el estado
                if nuevo_estado == 'entregada':
                    cursor.execute('''
                        UPDATE ordenes 
                        SET fecha_entrega = NOW()
                        WHERE id = %s
                    ''', [orden_id])
                elif nuevo_estado == 'cerrada':
                    cursor.execute('''
                        UPDATE ordenes 
                        SET fecha_cierre = NOW()
                        WHERE id = %s
                    ''', [orden_id])
                
                # Confirmar transacción
                cursor.execute('COMMIT')
                
                return JsonResponse({'success': True})
                
            except Exception as e:
                cursor.execute('ROLLBACK')
                return JsonResponse({'error': str(e)}, status=500)
    
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Formato JSON inválido'}, status=400)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)
    

@login_required
@grupos_permitidos(['Administradores', 'Cajeros'])
def actualizar_pagos_orden(request):
    """Vista para actualizar pagos de una orden en formato tabla"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        orden_id = data.get('orden_id')
        pagos = data.get('pagos', [])
        
        # Validaciones básicas
        if not orden_id:
            return JsonResponse({'error': 'ID de orden no proporcionado'}, status=400)
        
        if not pagos:
            return JsonResponse({'error': 'No se proporcionaron pagos'}, status=400)
        
        if len(pagos) > 2:
            return JsonResponse({'error': 'Solo se permiten máximo 2 formas de pago'}, status=400)
        
        # Obtener empleado actual
        empleado_id = request.session.get('empleado_id')
        if not empleado_id:
            return JsonResponse({'error': 'Sesión de empleado no válida'}, status=401)
        
        with connections['pagoda'].cursor() as cursor:
            # Iniciar transacción
            cursor.execute('START TRANSACTION')
            
            try:
                # 1. Verificar que la orden existe y está en estado correcto
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT estatus, total
                    FROM ordenes 
                    WHERE id = %s
                ''', [orden_id])
                
                orden_info = cursor.fetchone()
                if not orden_info:
                    cursor.execute('ROLLBACK')
                    return JsonResponse({'error': 'Orden no encontrada'}, status=404)
                
                # Validar estado de la orden
                orden_estatus, orden_total = orden_info
                if orden_estatus != 'por_cobrar':
                    cursor.execute('ROLLBACK')
                    return JsonResponse({
                        'error': 'La orden debe estar en estado "por_cobrar" para actualizar pagos'
                    }, status=400)
                
                # 2. Verificar que el total coincide
                total_pagos = sum(float(pago.get('monto', 0)) for pago in pagos)
                if abs(total_pagos - float(orden_total)) > 0.01:  # Tolerancia de 1 centavo
                    cursor.execute('ROLLBACK')
                    return JsonResponse({
                        'error': f'El total de pagos ({total_pagos}) no coincide con el total de la orden ({orden_total})'
                    }, status=400)
                
                # 3. Cancelar pagos existentes
                cursor.execute('''
                    UPDATE pagos 
                    SET estatus = 'cancelado', 
                        fecha_cancelacion = NOW()
                    WHERE orden_id = %s 
                    AND estatus = 'completado'
                ''', [orden_id])
                
                # 4. Registrar nuevos pagos
                for pago in pagos:
                    metodo_id = pago.get('metodo_id')
                    monto = pago.get('monto')
                    referencia = pago.get('referencia', '')
                    
                    # Validar datos
                    if not metodo_id or monto <= 0:
                        continue
                    
                    # Verificar si se requiere referencia
                    cursor.execute('''
                        SET STATEMENT max_statement_time = 25 FOR SELECT requiere_comprobacion
                        FROM metodos_pago
                        WHERE id = %s
                    ''', [metodo_id])
                    
                    requiere_referencia = cursor.fetchone()[0] if cursor.rowcount > 0 else 0
                    
                    if requiere_referencia and not referencia:
                        cursor.execute('ROLLBACK')
                        return JsonResponse({
                            'error': f'Se requiere referencia para la forma de pago #{metodo_id}'
                        }, status=400)
                    
                    # Insertar pago
                    cursor.execute('''
                        INSERT INTO pagos (
                            orden_id, metodo_pago_id, empleado_id,
                            monto, referencia, estatus, fecha_pago
                        ) VALUES (%s, %s, %s, %s, %s, %s, NOW())
                    ''', [
                        orden_id, metodo_id, empleado_id,
                        monto, referencia, 'completado'
                    ])
                
                # 5. Verificar si se completó el pago total y se puede cerrar la orden
                # (Opcional - podría agregarse después)
                
                # Confirmar transacción
                cursor.execute('COMMIT')
                
                return JsonResponse({
                    'success': True,
                    'message': 'Pagos actualizados correctamente'
                })
                
            except Exception as e:
                cursor.execute('ROLLBACK')
                return JsonResponse({'error': str(e)}, status=500)
    
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Formato JSON inválido'}, status=400)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)    

@login_required
@grupos_permitidos(['Administradores', 'Meseros','Delivery','Operadores','Rapidos','Cajeros'])
def registrar_pago(request, orden_id):
    """Vista para registrar pago de una orden con selección de caja"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        metodo_pago_id = data.get('metodo_pago_id')
        monto = data.get('monto')
        referencia = data.get('referencia', '')
        
        
        empleado_id = request.session['empleado_id']
        sucursal_id = 1
        
        with connections['pagoda'].cursor() as cursor:
            # Iniciar transacción
            cursor.execute('START TRANSACTION')
            
            try:
                # 1. Verificar que la orden está en estado correcto y obtener información relevante
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT o.estatus, o.mesa_id, m.estatus as mesa_estatus, 
                           o.tipo_servicio_id, o.estatus_entrega
                    FROM ordenes o
                    LEFT JOIN mesas m ON o.mesa_id = m.id
                    WHERE o.id = %s
                ''', [orden_id])
                
                orden_info = cursor.fetchone()
                if not orden_info:
                    cursor.execute('ROLLBACK')
                    return JsonResponse({'error': 'Orden no encontrada'}, status=404)
                
                orden_estatus = orden_info[0]
                mesa_id = orden_info[1]
                mesa_estatus = orden_info[2] if mesa_id else None
                tipo_servicio = orden_info[3]
                estatus_entrega = orden_info[4]
                
                # 2. Validaciones según tipo_servicio (SIMPLIFICADAS)
                if tipo_servicio == 1:
                    # Tipo 1: Solo validar que esté en por_cobrar
                    if orden_estatus != 'por_cobrar':
                        cursor.execute('ROLLBACK')
                        return JsonResponse({
                            'error': 'La orden debe estar en estado "por_cobrar" para realizar pagos tipo 1'
                        }, status=400)
                
                elif tipo_servicio == 2:
                    # Tipo 2: Solo validar que esté en por_cobrar
                    if orden_estatus != 'por_cobrar':
                        cursor.execute('ROLLBACK')
                        return JsonResponse({
                            'error': 'La orden debe estar en estado "por_cobrar" para realizar pagos tipo 2'
                        }, status=400)
                
                elif tipo_servicio == 3:
                    # Tipo 3: Solo validar condiciones de entrega
                    if not ((estatus_entrega == 'abierta' or estatus_entrega is None) and orden_estatus == 'por_cobrar'):
                        cursor.execute('ROLLBACK')
                        return JsonResponse({
                            'error': 'Para órdenes tipo 3, debe cumplirse: estatus_entrega="abierta" o null y estatus="por_cobrar"'
                        }, status=400)
                
                # Si tiene mesa, verificar que está en estado por_liberar
                if mesa_id and mesa_estatus != 'por_liberar':
                    cursor.execute('ROLLBACK')
                    return JsonResponse({
                        'error': 'La mesa debe estar en estado "por_liberar" para realizar pagos. Por favor, imprima la comanda primero.'
                    }, status=400)
                
                # 3. Verificar que la caja existe y está activa en la sucursal (Anulado)
                
                # 4. Verificar que la caja tiene un corte abierto (Anulado)
                
                # 5. Verificar orden
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT o.total,
                          (SELECT SUM(monto) FROM pagos WHERE orden_id = %s AND estatus = 'completado') as pagado
                    FROM ordenes o WHERE o.id = %s
                ''', [orden_id, orden_id])
                
                result = cursor.fetchone()
                if not result:
                    cursor.execute('ROLLBACK')
                    return JsonResponse({'error': 'Orden no encontrada'}, status=404)
                
                total = result[0] or 0
                pagado = result[1] or 0
                
                # 6. Verificar si el monto no excede lo pendiente
                pendiente = total - pagado
                exceso = decimal.Decimal(monto) - pendiente
                if exceso > decimal.Decimal('0.01'):  # Tolerancia de 1 centavo
                    cursor.execute('ROLLBACK')
                    return JsonResponse({
                        'error': f'El monto ({monto}) excede ({exceso}) el saldo pendiente ({pendiente})'
                    }, status=400)
                
                # 7. Registrar el pago
                cursor.execute('''
                    INSERT INTO pagos (
                        orden_id, metodo_pago_id, empleado_id,
                        monto, referencia, estatus, fecha_pago
                    ) VALUES (%s, %s, %s, %s, %s, %s, NOW())
                ''', [
                    orden_id, metodo_pago_id, empleado_id,
                    monto, referencia, 'completado'
                ])
                
                pago_id = cursor.lastrowid
                
                # 8. Verificar si se completó el pago total
                nuevo_pagado = pagado + decimal.Decimal(monto)
                
                # FIX: Usar una comparación con tolerancia para evitar problemas de precisión decimal
                diferencia = abs(total - nuevo_pagado)
                pago_completo = diferencia < decimal.Decimal('0.01')
                
                # NO actualizar aquí el estado de la orden ni el corte_caja_id
                # Esto se hace en otro lugar
                
                # Confirmar transacción
                cursor.execute('COMMIT')
                
                return JsonResponse({
                    'success': True,
                    'pago_id': pago_id,
                    'total': float(total),
                    'pagado': float(nuevo_pagado),
                    'pendiente': float(max(total - nuevo_pagado, 0)),
                    'orden_cerrada': False,
                    'mesa_liberada': False
                })
                
            except Exception as e:
                cursor.execute('ROLLBACK')
                return JsonResponse({'error': str(e)}, status=500)
    
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Formato JSON inválido'}, status=400)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

# ---------------------------------------------------------------
# VISTAS DE CATÁLOGOS
# ---------------------------------------------------------------

@login_required
@grupos_permitidos(['Administradores'])
def lista_productos(request):
    """Vista para listar productos"""
    with connections['default'].cursor() as cursor:
        cursor.execute('''
            SELECT p.id, p.codigo, p.nombre, p.precio_venta, 
                   c.nombre as categoria, p.estatus, p.dias_disponibles
            FROM productos p
            LEFT JOIN categorias_productos c ON p.categoria_id = c.id
            ORDER BY c.nombre, p.nombre
        ''')
        productos = dictfetchall(cursor)
    
    return render(request, 'catalogos/productos/lista.html', {'productos': productos})

from django.http import JsonResponse
from django.views.decorators.http import require_http_methods

@login_required
@grupos_permitidos(['Administradores'])
@require_http_methods(["DELETE"])
def eliminar_producto(request, producto_id):
    try:
        with connections['default'].cursor() as cursor:
            cursor.execute("DELETE FROM productos WHERE id = %s", [producto_id])
        return JsonResponse({'success': True})
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)}, status=400)


@login_required
@grupos_permitidos(['Administradores'])
def detalle_producto_admin(request, producto_id=None):
    """Vista para crear o editar producto"""
    producto = None
    categorias = []
    unidades = []
    
    with connections['default'].cursor() as cursor:
        # Obtener categorías para selector
        cursor.execute('SELECT id, nombre FROM categorias_productos ORDER BY nombre')
        categorias = dictfetchall(cursor)
        
        # Obtener unidades de medida para selector
        cursor.execute('SELECT id, nombre, abreviatura FROM unidades_medida ORDER BY nombre')
        unidades = dictfetchall(cursor)
        
        if producto_id:
            # Obtener datos del producto para edición
            cursor.execute('''
                SELECT * FROM productos WHERE id = %s
            ''', [producto_id])
            producto = dictfetchall(cursor)[0] if cursor.rowcount > 0 else None
        
        # Procesar formulario POST
        if request.method == 'POST':
            categoria_id = request.POST.get('categoria_id')
            codigo = request.POST.get('codigo')
            nombre = request.POST.get('nombre')
            descripcion = request.POST.get('descripcion', '')
            precio_venta = request.POST.get('precio_venta')
            costo = request.POST.get('costo')
            unidad_medida_id = request.POST.get('unidad_medida_id')
            stock_inicial = request.POST.get('stock_inicial', 0)
            control_inventario = request.POST.get('control_inventario') == 'on'
            visible_menu = request.POST.get('visible_menu') == 'on'
            vista_cocina = request.POST.get('vista_cocina') == 'on'
            permite_descuento = request.POST.get('permite_descuento') == 'on'
            iva_incluido = request.POST.get('iva_incluido') == 'on'
            porcentaje_iva = request.POST.get('porcentaje_iva', 16)
            estatus = request.POST.get('estatus', 'activo')
            stock_actual = request.POST.get('stock_actual', 0)
            
            # Procesar días disponibles
            dias_disponibles = request.POST.getlist('dias_disponibles[]')
            print(categoria_id)
            # Si la categoría es 6, forzar días_disponibles a null
            if categoria_id == "6":
                dias_disponibles_str = None
            else:
                dias_disponibles_str = ','.join(dias_disponibles) if dias_disponibles else None
            
            print(dias_disponibles_str)
            # Manejar imagen subida
            imagen_url = None
            if 'imagen' in request.FILES:
                # Aquí iría la lógica para guardar la imagen
                # imagen_url = guardar_imagen(request.FILES['imagen'])
                pass
            
            if producto_id:
                # Actualizar producto existente
                cursor.execute('''
                    UPDATE productos 
                    SET categoria_id = %s, codigo = %s, nombre = %s, descripcion = %s,
                        precio_venta = %s, costo = %s, unidad_medida_id = %s,
                        stock_inicial = %s, control_inventario = %s, visible_menu = %s,
                        vista_cocina = %s, permite_descuento = %s, iva_incluido = %s, porcentaje_iva = %s,
                        estatus = %s, stock_actual = %s, dias_disponibles = %s
                    WHERE id = %s
                ''', [
                    categoria_id, codigo, nombre, descripcion,
                    precio_venta, costo, unidad_medida_id,
                    stock_inicial, control_inventario, visible_menu,
                    vista_cocina, permite_descuento, iva_incluido, porcentaje_iva,
                    estatus, stock_actual, dias_disponibles_str, producto_id
                ])
                
                if imagen_url:
                    cursor.execute('UPDATE productos SET imagen_url = %s WHERE id = %s', 
                                   [imagen_url, producto_id])
                
            else:
                # Crear nuevo producto
                cursor.execute('''
                    INSERT INTO productos (
                        categoria_id, codigo, nombre, descripcion, precio_venta, costo,
                        imagen_url, unidad_medida_id, stock_inicial, control_inventario,
                        visible_menu, vista_cocina, permite_descuento, iva_incluido, porcentaje_iva, 
                        estatus, stock_actual, dias_disponibles
                    ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                ''', [
                    categoria_id, codigo, nombre, descripcion, precio_venta, costo,
                    imagen_url, unidad_medida_id, stock_inicial, control_inventario,
                    visible_menu, vista_cocina, permite_descuento, iva_incluido, porcentaje_iva, 
                    estatus, stock_actual, dias_disponibles_str
                ])
            
            return redirect('lista_productos')
    
    return render(request, 'catalogos/productos/detalle.html', {
        'producto': producto,
        'categorias': categorias,
        'unidades': unidades
    })

@login_required
@grupos_permitidos(['Administradores'])
def lista_categorias(request):
    """Vista para listar categorías de productos"""
    from django.db.models import Count
    
    categorias = CategoriasProductos.objects.annotate(
        productos_count=Count('productos')
    ).order_by('orden', 'nombre')
    
    # Si necesitas los datos en formato de diccionario
    categorias_data = []
    for categoria in categorias:
        categorias_data.append({
            'id': categoria.id,
            'nombre': categoria.nombre,
            'descripcion': categoria.descripcion,
            'color': categoria.color,
            'productos': categoria.productos_count,
            'visible_menu': categoria.visible_menu
        })
    
    return render(request, 'catalogos/categorias/lista.html', {'categorias': categorias_data})

from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.db import transaction
from .models import CategoriasProductos
from .decorators import grupos_permitidos

@login_required
@grupos_permitidos(['Administradores'])
def detalle_categoria(request, categoria_id=None):
    """Vista para crear o editar categoría"""
    categoria = None
    if categoria_id:
        categoria = get_object_or_404(CategoriasProductos, id=categoria_id)
    
    categorias_padre = CategoriasProductos.objects.all().order_by('nombre')
    
    if request.method == 'POST':
        nombre = request.POST.get('nombre')
        descripcion = request.POST.get('descripcion', '')
        color = request.POST.get('color', '#000000')
        orden = request.POST.get('orden', 0)
        categoria_padre_id = request.POST.get('categoria_padre_id')
        visible_menu = request.POST.get('visible_menu') == 'on'
        
        # Manejar imagen subida
        imagen = request.FILES.get('imagen')
        
        try:
            with transaction.atomic():
                if categoria:
                    # Actualizar categoría existente
                    categoria.nombre = nombre
                    categoria.descripcion = descripcion
                    categoria.color = color
                    categoria.orden = orden
                    categoria.visible_menu = visible_menu
                    
                    if categoria_padre_id:
                        categoria.categoria_padre_id = categoria_padre_id
                    else:
                        categoria.categoria_padre = None
                    
                    if imagen:
                        categoria.imagen = imagen
                    
                    categoria.save()
                else:
                    # Crear nueva categoría
                    categoria = CategoriasProductos(
                        nombre=nombre,
                        descripcion=descripcion,
                        color=color,
                        orden=orden,
                        visible_menu=visible_menu,
                        imagen=imagen if imagen else None
                    )
                    
                    if categoria_padre_id:
                        categoria.categoria_padre_id = categoria_padre_id
                    
                    categoria.save()
            
            return redirect('lista_categorias')
        
        except Exception as e:
            # Manejar errores aquí
            pass
    
    return render(request, 'catalogos/categorias/detalle.html', {
        'categoria': categoria,
        'categorias_padre': categorias_padre
    })

from django.shortcuts import render
from django.contrib.auth.decorators import login_required
from django.db.models import Count
from .models import Areas, Mesas
from .decorators import grupos_permitidos
from django.utils import timezone

@login_required
@grupos_permitidos(['Administradores'])
def lista_mesas(request):
    """Vista para listar mesas por áreas"""
    # Obtener áreas activas con el conteo de mesas
    areas = Areas.objects.filter(estatus='activa').annotate(
        total_mesas=Count('mesas')
    ).order_by('nombre')
    
    # Para cada área, obtener sus mesas
    for area in areas:
        area.mesas = Mesas.objects.filter(area_id=area.id).order_by('numero')
    
    return render(request, 'catalogos/mesas/lista.html', {'areas': areas})


@csrf_exempt
@login_required
@grupos_permitidos(['Administradores'])
def eliminar_mesa(request, mesa_id):
    """Vista para eliminar una mesa"""
    if request.method != 'DELETE' and request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    try:
        mesa = Mesas.objects.get(id=mesa_id)
        mesa.delete()
        
        return JsonResponse({
            'success': True,
            'message': 'Mesa eliminada correctamente'
        })
        
    except Mesas.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'La mesa no existe'
        }, status=404)
        
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': f'Error al eliminar la mesa: {str(e)}'
        }, status=500)

from .models import Areas, Mesas
from django.shortcuts import redirect, render
from django.contrib import messages
from django.utils import timezone

@login_required
@grupos_permitidos(['Administradores'])
def detalle_mesa(request, mesa_id=None):
    areas = Areas.objects.filter(estatus='activa').order_by('nombre')
    mesa = Mesas.objects.get(id=mesa_id) if mesa_id else None
    
    if request.method == 'POST':
        area_id = request.POST.get('area_id')
        numero = request.POST.get('numero').strip()  # Limpiar espacios
        capacidad = request.POST.get('capacidad')
        forma = request.POST.get('forma')
        posicion_x = request.POST.get('posicion_x') or 0
        posicion_y = request.POST.get('posicion_y') or 0
        estatus = request.POST.get('estatus', 'disponible')
        
        # Validar que el número de mesa no esté duplicado en la misma área
        mesa_existente = Mesas.objects.filter(
            area_id=area_id, 
            numero__iexact=numero  # Búsqueda case-insensitive
        ).exclude(id=mesa_id).first()  # Excluir la mesa actual si es edición
        
        if mesa_existente:
            # Mostrar mensaje de error
            messages.error(
                request, 
                f'Ya existe una mesa con el número "{numero}" en esta área. '
                f'Por favor, use un número diferente.'
            )
            
            return render(request, 'catalogos/mesas/detalle.html', {
                'mesa': mesa,
                'areas': areas,
                'form_data': request.POST  # Mantener los datos del formulario
            })
        
        # Validar otros campos obligatorios
        if not all([area_id, numero, capacidad]):
            messages.error(request, 'Todos los campos obligatorios deben ser completados')
            return render(request, 'catalogos/mesas/detalle.html', {
                'mesa': mesa,
                'areas': areas,
                'form_data': request.POST
            })
        
        try:
            if mesa_id:
                # Actualizar mesa existente
                mesa.area_id = area_id
                mesa.numero = numero
                mesa.capacidad = capacidad
                mesa.forma = forma
                mesa.posicion_x = posicion_x
                mesa.posicion_y = posicion_y
                mesa.estatus = estatus
                mesa.actualizado_en = timezone.now()
                mesa.save()
                
                messages.success(request, 'Mesa actualizada correctamente')
            else:
                # Crear nueva mesa
                mesa = Mesas.objects.create(
                    area_id=area_id,
                    numero=numero,
                    capacidad=capacidad,
                    forma=forma,
                    posicion_x=posicion_x,
                    posicion_y=posicion_y,
                    estatus=estatus,
                    creado_en=timezone.now()
                )
                
                messages.success(request, 'Mesa creada correctamente')
            
            return redirect('lista_mesas')
            
        except Exception as e:
            messages.error(request, f'Error al guardar la mesa: {str(e)}')
            return render(request, 'catalogos/mesas/detalle.html', {
                'mesa': mesa,
                'areas': areas,
                'form_data': request.POST
            })
    
    return render(request, 'catalogos/mesas/detalle.html', {
        'mesa': mesa,
        'areas': areas
    })

@login_required
@grupos_permitidos(['Administradores'])
def mapa_mesas(request):
    """Vista para el mapa interactivo de mesas"""
    return render(request, 'catalogos/mesas/mapa.html')


@login_required
@grupos_permitidos(['Administradores', 'Meseros'])
def api_areas(request):
    """API para obtener lista de áreas"""
    try:
        with connections['default'].cursor() as cursor:
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR 
                SELECT id, nombre, descripcion
                FROM areas
                WHERE estatus = 'activa'
                ORDER BY nombre
            ''')
            areas = dictfetchall(cursor)
        
        return JsonResponse(areas, safe=False)
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)}, status=500)


@login_required
@grupos_permitidos(['Administradores'])
def api_mesas_por_area(request, area_id):
    """API para obtener mesas de un área específica"""
    try:
        with connections['default'].cursor() as cursor:
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR
                SELECT id, numero, capacidad, forma, estatus, 
                       posicion_x, posicion_y, area_id
                FROM mesas
                WHERE area_id = %s
                ORDER BY numero
            ''', [area_id])
            mesas = dictfetchall(cursor)
        
        return JsonResponse(mesas, safe=False)
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)}, status=500)


@login_required
@grupos_permitidos(['Administradores'])
def api_actualizar_posicion_mesa(request):
    """API para actualizar posición de mesa"""
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        mesa_id = data.get('mesa_id')
        posicion_x = data.get('posicion_x')
        posicion_y = data.get('posicion_y')
        
        if not all([mesa_id, posicion_x is not None, posicion_y is not None]):
            return JsonResponse({'success': False, 'error': 'Datos incompletos'}, status=400)
        
        with connections['default'].cursor() as cursor:
            cursor.execute('''
                UPDATE mesas 
                SET posicion_x = %s, posicion_y = %s
                WHERE id = %s
            ''', [posicion_x, posicion_y, mesa_id])
        
        return JsonResponse({'success': True})
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)}, status=500)
    

@login_required
@grupos_permitidos(['Administradores','Meseros'])
def api_elementos_mapa_por_area(request, area_id):
    """API para obtener elementos del mapa por área"""
    try:
        with connections['default'].cursor() as cursor:
            cursor.execute('''
                SET STATEMENT max_statement_time = 40 FOR SELECT id, area_id, tipo, subtipo, posicion_x, posicion_y, 
                       rotacion, ancho, alto, propiedades
                FROM elementos_mapa
                WHERE area_id = %s
                ORDER BY tipo, subtipo
            ''', [area_id])
            elementos = dictfetchall(cursor)
        
        return JsonResponse(elementos, safe=False)
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)}, status=500)

@login_required
@grupos_permitidos(['Administradores'])
def api_crear_elemento_mapa(request):
    """API para crear elemento en el mapa"""
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        area_id = data.get('area_id')
        tipo = data.get('tipo')
        subtipo = data.get('subtipo', '')
        posicion_x = data.get('posicion_x', 0)
        posicion_y = data.get('posicion_y', 0)
        rotacion = data.get('rotacion', 0)
        ancho = data.get('ancho', 1)
        alto = data.get('alto', 1)
        propiedades = json.dumps(data.get('propiedades', {}))
        
        with connections['default'].cursor() as cursor:
            cursor.execute('''
                INSERT INTO elementos_mapa (
                    area_id, tipo, subtipo, posicion_x, posicion_y, rotacion, ancho, alto, propiedades
                ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            ''', [
                area_id, tipo, subtipo, posicion_x, posicion_y, rotacion, ancho, alto, propiedades
            ])
            
            # Obtener el ID del elemento creado
            cursor.execute('SELECT LAST_INSERT_ID()')
            elemento_id = cursor.fetchone()[0]
        
        return JsonResponse({'success': True, 'elemento_id': elemento_id})
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)}, status=500)

@login_required
@grupos_permitidos(['Administradores'])
def api_actualizar_posicion_elemento(request):
    """API para actualizar posición de elemento"""
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        elemento_id = data.get('elemento_id')
        posicion_x = data.get('posicion_x')
        posicion_y = data.get('posicion_y')
        rotacion = data.get('rotacion', 0)
        
        with connections['default'].cursor() as cursor:
            cursor.execute('''
                UPDATE elementos_mapa 
                SET posicion_x = %s, posicion_y = %s, rotacion = %s
                WHERE id = %s
            ''', [posicion_x, posicion_y, rotacion, elemento_id])
        
        return JsonResponse({'success': True})
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)}, status=500)

@login_required
@grupos_permitidos(['Administradores'])
def api_eliminar_elemento_mapa(request):
    """API para eliminar elemento del mapa"""
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        elemento_id = data.get('elemento_id')
        
        with connections['default'].cursor() as cursor:
            cursor.execute('DELETE FROM elementos_mapa WHERE id = %s', [elemento_id])
        
        return JsonResponse({'success': True})
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)}, status=500)

@login_required
@grupos_permitidos(['Administradores'])
def api_crear_mesa(request):
    """API for creating a new table"""
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Method not allowed'}, status=405)
    
    try:
        data = json.loads(request.body)
        area_id = data.get('area_id')
        forma = data.get('forma', 'cuadrada')
        capacidad = data.get('capacidad', 4)
        estatus = data.get('estatus', 'disponible')
        posicion_x = data.get('posicion_x', 0)
        posicion_y = data.get('posicion_y', 0)
        
        if not area_id:
            return JsonResponse({'success': False, 'error': 'Area ID is required'}, status=400)
        
        with connections['default'].cursor() as cursor:
            # Get the next available table number for this area
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT MAX(CAST(numero AS UNSIGNED)) 
                FROM mesas 
                WHERE area_id = %s
            ''', [area_id])
            result = cursor.fetchone()
            next_number = 1
            if result[0] is not None:
                next_number = int(result[0]) + 1
            
            # Insert the new table
            cursor.execute('''
                INSERT INTO mesas (
                    area_id, numero, capacidad, forma, estatus, posicion_x, posicion_y
                ) VALUES (%s, %s, %s, %s, %s, %s, %s)
            ''', [
                area_id, str(next_number), capacidad, forma, estatus, posicion_x, posicion_y
            ])
            
            # Get the ID of the created table
            cursor.execute('SELECT LAST_INSERT_ID()')
            mesa_id = cursor.fetchone()[0]
        
        return JsonResponse({
            'success': True, 
            'mesa_id': mesa_id,
            'numero': str(next_number)
        })
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)}, status=500)

@login_required
@grupos_permitidos(['Administradores'])
def api_configuracion_plano(request, area_id):
    """API para obtener configuración del plano por área"""
    try:
        with connections['default'].cursor() as cursor:
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT tamano_cuadricula, mostrar_cuadricula, ajustar_a_cuadricula, color_piso
                FROM configuracion_plano
                WHERE area_id = %s
            ''', [area_id])
            config = dictfetchone(cursor)
        
        if not config:
            # Si no hay configuración para esta área, crear una con valores predeterminados
            with connections['pagoda'].cursor() as cursor:
                cursor.execute('''
                    INSERT INTO configuracion_plano 
                    (area_id, tamano_cuadricula, mostrar_cuadricula, ajustar_a_cuadricula, color_piso)
                    VALUES (%s, 50, 1, 1, '#f8f9fa')
                ''', [area_id])
            
            config = {
                'tamano_cuadricula': 50,
                'mostrar_cuadricula': 1,
                'ajustar_a_cuadricula': 1,
                'color_piso': '#f8f9fa'
            }
        
        return JsonResponse(config)
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)}, status=500)


@login_required
@grupos_permitidos(['Administradores'])
def api_guardar_configuracion_plano(request):
    """API para guardar configuración del plano"""
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        area_id = data.get('area_id')
        tamano_cuadricula = data.get('tamano_cuadricula', 50)
        mostrar_cuadricula = data.get('mostrar_cuadricula', 1)
        ajustar_a_cuadricula = data.get('ajustar_a_cuadricula', 1)
        color_piso = data.get('color_piso', '#f8f9fa')
        
        if not area_id:
            return JsonResponse({'success': False, 'error': 'ID de área requerido'}, status=400)
        
        with connections['default'].cursor() as cursor:
            # Verificar si ya existe configuración para esta área
            cursor.execute('''
                SELECT id FROM configuracion_plano WHERE area_id = %s
            ''', [area_id])
            exists = cursor.fetchone()
            
            if exists:
                # Actualizar configuración existente
                cursor.execute('''
                    UPDATE configuracion_plano 
                    SET tamano_cuadricula = %s, mostrar_cuadricula = %s, 
                        ajustar_a_cuadricula = %s, color_piso = %s
                    WHERE area_id = %s
                ''', [tamano_cuadricula, mostrar_cuadricula, ajustar_a_cuadricula, color_piso, area_id])
            else:
                # Crear nueva configuración
                cursor.execute('''
                    INSERT INTO configuracion_plano 
                    (area_id, tamano_cuadricula, mostrar_cuadricula, ajustar_a_cuadricula, color_piso)
                    VALUES (%s, %s, %s, %s, %s)
                ''', [area_id, tamano_cuadricula, mostrar_cuadricula, ajustar_a_cuadricula, color_piso])
        
        return JsonResponse({'success': True})
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)}, status=500)


@login_required
@grupos_permitidos(['Administradores'])
def api_actualizar_propiedades_mesa(request):
    """API para actualizar propiedades de una mesa"""
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        mesa_id = data.get('mesa_id')
        propiedades = data.get('propiedades', {})
        
        if not mesa_id:
            return JsonResponse({'success': False, 'error': 'ID de mesa requerido'}, status=400)
        
        with connections['default'].cursor() as cursor:
            # Construir la consulta SQL dinámicamente según las propiedades
            campos = []
            valores = []
            
            for key, value in propiedades.items():
                campos.append(f"{key} = %s")
                valores.append(value)
            
            if not campos:
                return JsonResponse({'success': False, 'error': 'No hay propiedades para actualizar'}, status=400)
            
            sql = f"UPDATE mesas SET {', '.join(campos)} WHERE id = %s"
            valores.append(mesa_id)
            
            cursor.execute(sql, valores)
        
        return JsonResponse({'success': True})
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)}, status=500)


@login_required
@grupos_permitidos(['Administradores'])
def api_actualizar_propiedades_elemento(request):
    """API para actualizar propiedades de un elemento del mapa"""
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        elemento_id = data.get('elemento_id')
        propiedades = data.get('propiedades', {})
        
        if not elemento_id:
            return JsonResponse({'success': False, 'error': 'ID de elemento requerido'}, status=400)
        
        with connections['default'].cursor() as cursor:
            # Construir la consulta SQL dinámicamente según las propiedades
            campos = []
            valores = []
            
            for key, value in propiedades.items():
                campos.append(f"{key} = %s")
                valores.append(value)
            
            if not campos:
                return JsonResponse({'success': False, 'error': 'No hay propiedades para actualizar'}, status=400)
            
            sql = f"UPDATE elementos_mapa SET {', '.join(campos)} WHERE id = %s"
            valores.append(elemento_id)
            
            cursor.execute(sql, valores)
        
        return JsonResponse({'success': True})
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)}, status=500)


@login_required
@grupos_permitidos(['Administradores'])
def api_actualizar_rotacion_mesa(request):
    """API para actualizar rotación de una mesa"""
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        mesa_id = data.get('mesa_id')
        rotacion = data.get('rotacion', 0)
        
        if not mesa_id:
            return JsonResponse({'success': False, 'error': 'ID de mesa requerido'}, status=400)
        
        with connections['default'].cursor() as cursor:
            cursor.execute('''
                UPDATE mesas SET rotacion = %s WHERE id = %s
            ''', [rotacion, mesa_id])
        
        return JsonResponse({'success': True})
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)}, status=500)


@login_required
@grupos_permitidos(['Administradores'])
def api_guardar_mapa(request):
    """API para guardar el mapa completo (mesas y elementos)"""
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        area_id = data.get('area_id')
        tables = data.get('tables', [])
        elements = data.get('elements', [])
        
        if not area_id:
            return JsonResponse({'success': False, 'error': 'ID de área requerido'}, status=400)
        
        with connections['default'].cursor() as cursor:
            # Actualizar posiciones y propiedades de mesas
            for table in tables:
                cursor.execute('''
                    UPDATE mesas 
                    SET posicion_x = %s, posicion_y = %s, rotacion = %s, escala = %s
                    WHERE id = %s
                ''', [
                    table.get('posicion_x', 0),
                    table.get('posicion_y', 0),
                    table.get('rotacion', 0),
                    table.get('escala', 1),
                    table.get('id')
                ])
            
            # Actualizar posiciones y propiedades de elementos
            for element in elements:
                cursor.execute('''
                    UPDATE elementos_mapa 
                    SET posicion_x = %s, posicion_y = %s, rotacion = %s,
                        ancho = %s, alto = %s
                    WHERE id = %s
                ''', [
                    element.get('posicion_x', 0),
                    element.get('posicion_y', 0),
                    element.get('rotacion', 0),
                    element.get('ancho', 1),
                    element.get('alto', 1),
                    element.get('id')
                ])
        
        return JsonResponse({'success': True})
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)}, status=500)            

def dictfetchall(cursor):
    """Convierte todas las filas del cursor en una lista de diccionarios"""
    columns = [col[0] for col in cursor.description]
    return [dict(zip(columns, row)) for row in cursor.fetchall()]


def dictfetchone(cursor):
    """Convierte una fila del cursor en un diccionario"""
    columns = [col[0] for col in cursor.description]
    row = cursor.fetchone()
    if row is None:
        return None
    return dict(zip(columns, row))


from django.db.models import Count
from .models import Clientes, DireccionesCliente

@login_required
@grupos_permitidos(['Administradores', 'Meseros','Delivery','Operadores','Rapidos'])
def lista_clientes(request):
    """Vista para listar clientes usando ORM de Django"""
    
    # Obtener clientes con conteo de direcciones usando annotate
    clientes = Clientes.objects.annotate(
        num_direcciones=Count('direcciones')
    ).values(
        'id',
        'nombre',
        'apellidos',
        'telefono',
        'num_direcciones'
    ).order_by('apellidos', 'nombre')
    
    # Formatear los datos para que coincidan con tu estructura anterior
    clientes_formateados = []
    for cliente in clientes:
        clientes_formateados.append({
            'id': cliente['id'],
            'nombre_completo': f"{cliente['nombre']} {cliente['apellidos'] or ''}".strip(),
            'telefono': cliente['telefono'],
            'direcciones': cliente['num_direcciones']
        })
    
    return render(request, 'catalogos/clientes/lista.html', {
        'clientes': clientes_formateados
    })


from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from .models import Clientes, MetodosPago, DireccionesCliente # Asegúrate de importar los 3 modelos

@login_required
def detalle_cliente(request, cliente_id=None):
    """Maneja la creación y edición de clientes, y muestra sus detalles."""

    # Esta consulta se necesita tanto en GET como en POST (en caso de error)
    metodos_pago = MetodosPago.objects.filter(activo=1).values('id', 'nombre')
    
    # --- LÓGICA PARA GUARDAR EL FORMULARIO (POST) ---
    # Tu lógica POST para guardar el cliente ya estaba correcta, se mantiene.
    if request.method == 'POST':
        if not cliente_id:
            telefono = request.POST.get('telefono')
            if Clientes.objects.filter(telefono=telefono).exists() and not request.POST.get('confirmar_telefono'):
                messages.warning(request, f"El teléfono {telefono} ya existe en la base de datos.")
                return render(request, 'catalogos/clientes/detalle.html', {
                    'cliente': None, 'direcciones': [], 'pedidos': [], 'editando': False,
                    'datos_temporales': request.POST.dict(), 'telefono_existe': True, 'metodos_pago': metodos_pago
                })
        
        metodo_pago_obj = None
        metodo_pago_id = request.POST.get('metodo_pago')
        if metodo_pago_id:
            try:
                metodo_pago_obj = MetodosPago.objects.get(id=metodo_pago_id)
            except MetodosPago.DoesNotExist:
                messages.error(request, "El método de pago seleccionado no es válido.")

        data = {
            'nombre': request.POST.get('nombre'),
            'telefono': request.POST.get('telefono'),
            'cubiertos': 1 if request.POST.get('cubiertos') else 0,
            'puntos_acumulados': request.POST.get('puntos_acumulados', 0),
            'nivel_lealtad': request.POST.get('nivel_lealtad', 'bronce'),
            'forma_pago_predeterminada': metodo_pago_obj
        }
        
        try:
            if cliente_id:  # Actualización
                cliente = get_object_or_404(Clientes, id=cliente_id)
                for key, value in data.items():
                    setattr(cliente, key, value)
                cliente.save()
                messages.success(request, "Cliente actualizado correctamente")
                return redirect('lista_clientes')
            else:  # Inserción
                cliente = Clientes.objects.create(**data)
                messages.success(request, "Cliente creado correctamente")
                return redirect('direccion_cliente_nueva', cliente_id=cliente.id)

        except Exception as e:
            messages.error(request, f"Error: {str(e)}")
            return redirect(request.path)

    # --- LÓGICA PARA MOSTRAR LA PÁGINA (GET) ---
    else:
        cliente = None
        direcciones = []
        pedidos = []
        
        # Si estamos viendo un cliente existente (no creando uno nuevo)
        if cliente_id:
            cliente = get_object_or_404(Clientes, id=cliente_id)
            
            # ✨ CAMBIO CLAVE: Obtenemos las direcciones del cliente desde la base de datos.
            # Las ordenamos para que la predeterminada aparezca primero.
            direcciones = cliente.direcciones.order_by('-predeterminada', 'nombre_etiqueta')
            
            # Aquí puedes agregar la lógica para obtener los pedidos del cliente si la tienes
            # pedidos = Ordenes.objects.filter(cliente=cliente)...
        
        return render(request, 'catalogos/clientes/detalle.html', {
            'cliente': cliente,
            'direcciones': direcciones, # ✨ Ahora esta variable contiene los datos correctos
            'pedidos': pedidos,
            'editando': cliente_id is not None,
            'metodos_pago': metodos_pago
        })


# tus_app/views.py
import uuid
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from .models import Clientes, DireccionesCliente # Asegúrate de importar tus modelos

@login_required
def direccion_cliente(request, cliente_id, direccion_id=None):
    """Maneja creación y edición de direcciones usando el ORM de Django."""
    
    # ORM: Obtenemos el objeto del cliente al principio.
    # Si no existe, se generará un error 404 (página no encontrada).
    cliente = get_object_or_404(Clientes, id=cliente_id)
    
    if request.method == 'POST':
        # La lógica para evitar duplicados se mantiene igual, está perfecta.
        if request.session.get('last_direccion_submit_token') == request.POST.get('submit_token'):
            messages.warning(request, "Solicitud duplicada detectada")
            return redirect('detalle_cliente', cliente_id=cliente.id)
        request.session['last_direccion_submit_token'] = request.POST.get('submit_token')
        
        # La recolección y limpieza de datos también se mantiene, está muy bien.
        nombre_etiqueta = request.POST.get('nombre_etiqueta', 'casa').lower()
        if not nombre_etiqueta: # Si el valor es una cadena vacía
            nombre_etiqueta = 'casa'

        # Manejar checkbox 'predeterminada'
        es_predeterminada = request.POST.get('predeterminada') == 'on'
        
        try:
            # ORM: Si se marca como predeterminada, desmarcamos las otras con una sola línea.
            if es_predeterminada:
                DireccionesCliente.objects.filter(cliente=cliente, predeterminada=True).update(predeterminada=False)
            
            if direccion_id:  # --- ACTUALIZACIÓN (EDITAR) ---
                # ORM: Obtenemos la dirección específica que vamos a editar.
                # Se incluye cliente para asegurar que no se edite una dirección de otro cliente.
                direccion_obj = get_object_or_404(DireccionesCliente, id=direccion_id, cliente=cliente)
                
                # Actualizamos los campos del objeto con los datos del formulario.
                direccion_obj.nombre_etiqueta = nombre_etiqueta
                direccion_obj.calle = request.POST.get('calle')
                direccion_obj.numero_exterior = request.POST.get('numero_exterior')
                direccion_obj.numero_interior = request.POST.get('numero_interior') or None
                direccion_obj.colonia = request.POST.get('colonia')
                direccion_obj.codigo_postal = request.POST.get('codigo_postal') or None
                direccion_obj.referencias = request.POST.get('referencias') or None
                direccion_obj.costo_entrega = request.POST.get('costo_entrega') or None
                direccion_obj.predeterminada = es_predeterminada
                
                # Campos condicionales para edificio
                if nombre_etiqueta == 'edificio':
                    direccion_obj.numero_piso = request.POST.get('numero_piso')
                    direccion_obj.area = request.POST.get('area')
                else:
                    direccion_obj.numero_piso = None
                    direccion_obj.area = None
                
                # ORM: Guardamos los cambios en la base de datos.
                direccion_obj.save()
                msg = "Dirección actualizada correctamente"

            else:  # --- INSERCIÓN (CREAR) ---
                # Preparamos los datos para la creación
                datos_para_crear = {
                    'cliente': cliente,
                    'nombre_etiqueta': nombre_etiqueta,
                    'calle': request.POST.get('calle'),
                    'numero_exterior': request.POST.get('numero_exterior'),
                    'numero_interior': request.POST.get('numero_interior') or None,
                    'colonia': request.POST.get('colonia'),
                    'codigo_postal': request.POST.get('codigo_postal') or None,
                    'referencias': request.POST.get('referencias') or None,
                    'costo_entrega': request.POST.get('costo_entrega') or None,
                    'predeterminada': es_predeterminada,
                }
                if nombre_etiqueta == 'edificio':
                    datos_para_crear['numero_piso'] = request.POST.get('numero_piso')
                    datos_para_crear['area'] = request.POST.get('area')
                
                # ORM: Creamos la nueva dirección con una sola línea de código.
                DireccionesCliente.objects.create(**datos_para_crear)
                msg = "Dirección creada correctamente"
            
            messages.success(request, msg)
            return redirect('detalle_cliente', cliente_id=cliente.id)

        except Exception as e:
            # El manejo de errores se mantiene, aunque con el ORM son menos probables.
            print(f"Error al guardar dirección: {e}")
            messages.error(request, f"Error al guardar la dirección: {str(e)}")
            # Redirigir de vuelta al formulario de la dirección en caso de error
            if direccion_id:
                return redirect('direccion_cliente_editar', cliente_id=cliente.id, direccion_id=direccion_id)
            else:
                return redirect('direccion_cliente_nueva', cliente_id=cliente.id)
    
    else:  # --- MÉTODO GET ---
        direccion = None
        if direccion_id:
            # ORM: Obtener la dirección para mostrarla en el formulario de edición.
            direccion = get_object_or_404(DireccionesCliente, id=direccion_id, cliente=cliente)

        # La lógica del token para evitar duplicados se mantiene.
        submit_token = str(uuid.uuid4())
        request.session['submit_token'] = submit_token

        return render(request, 'catalogos/clientes/direccion.html', {
            'direccion': direccion,
            'cliente': cliente, # Pasamos el objeto cliente completo a la plantilla
            'cliente_id': cliente_id, # Mantenemos cliente_id por compatibilidad si lo usas
            'editando': direccion_id is not None,
            'submit_token': submit_token
        })

@login_required
def verificar_telefono(request):
    """Verifica si un teléfono ya existe en la base de datos"""
    telefono = request.GET.get('telefono')
    if not telefono:
        return JsonResponse({'existe': False})
    
    with connections['default'].cursor() as cursor:
        cursor.execute("SELECT COUNT(*) FROM clientes WHERE telefono = %s", [telefono])
        existe = cursor.fetchone()[0] > 0
    
    return JsonResponse({'existe': existe})

# ---------------------------------------------------------------
# VISTAS DE CAJA Y CORTES
# ---------------------------------------------------------------

@login_required
@grupos_permitidos(['Administradores','Cajeros'])
def lista_cajas(request):
    """Vista para listar cajas"""
    with connections['pagoda'].cursor() as cursor:
        # Obtener cajas
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT c.id, c.nombre, c.ubicacion, c.estatus,
                   s.nombre as sucursal,
                   (SELECT fecha_apertura 
                    FROM cortes_caja 
                    WHERE caja_id = c.id AND estatus = 'abierto'
                    LIMIT 1) as fecha_apertura,
                   (SELECT CONCAT(e.nombre, ' ', e.apellidos)
                    FROM cortes_caja cc
                    JOIN empleados e ON cc.empleado_id = e.id
                    WHERE cc.caja_id = c.id AND cc.estatus = 'abierto'
                    LIMIT 1) as cajero
            FROM cajas c
            JOIN sucursales s ON c.sucursal_id = s.id
            ORDER BY s.nombre, c.nombre
        ''')
        cajas = dictfetchall(cursor)

        # Obtener sucursales para el selector
        cursor.execute('SET STATEMENT max_statement_time = 25 FOR SELECT id, nombre FROM sucursales WHERE estatus = "activa" ORDER BY nombre')
        sucursales = dictfetchall(cursor)
    
    return render(request, 'caja/lista_cajas.html', {
        'cajas': cajas,
        'sucursales': sucursales
    })

@login_required
@grupos_permitidos(['Administradores','Cajeros'])
def apertura_caja(request, caja_id):
    """Vista para apertura de caja"""
    empleado_id = request.session.get('empleado_id')
    
    with connections['pagoda'].cursor() as cursor:
        # Verificar si el empleado ya tiene un corte abierto en cualquier caja
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT cc.id, c.nombre 
            FROM cortes_caja cc
            JOIN cajas c ON cc.caja_id = c.id
            WHERE cc.empleado_id = %s AND cc.estatus = 'abierto'
        ''', [empleado_id])
        
        corte_abierto = dictfetchall(cursor)
        
        if corte_abierto:
            messages.error(
                request, 
                f"Ya tiene un corte abierto en la caja {corte_abierto[0]['nombre']}. No puede abrir otra caja hasta cerrar ese corte."
            )
            return redirect('lista_cajas')
        
        # Verificar si la caja ya está abierta por otro empleado
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT cc.id, CONCAT(e.nombre, ' ', e.apellidos) as empleado
            FROM cortes_caja cc
            JOIN empleados e ON cc.empleado_id = e.id
            WHERE cc.caja_id = %s AND cc.estatus = 'abierto'
        ''', [caja_id])
        
        caja_ocupada = dictfetchall(cursor)
        
        if caja_ocupada:
            messages.error(
                request, 
                f"Esta caja ya está siendo utilizada por {caja_ocupada[0]['empleado']}. Por favor seleccione otra caja."
            )
            return redirect('lista_cajas')
        
        # Obtener datos de la caja
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT c.id, c.nombre, c.ubicacion, s.nombre as sucursal
            FROM cajas c
            JOIN sucursales s ON c.sucursal_id = s.id
            WHERE c.id = %s
        ''', [caja_id])
        
        caja = dictfetchall(cursor)[0] if cursor.rowcount > 0 else None
        
        if not caja:
            messages.error(request, "La caja seleccionada no existe.")
            return redirect('lista_cajas')
        
        # Procesar formulario POST
        if request.method == 'POST':
            monto_inicial = request.POST.get('monto_inicial')
            notas = request.POST.get('notas', '')
            
            try:
                # Abrir la caja dentro de una transacción
                with transaction.atomic():
                    # Insertar nuevo corte
                    cursor.execute('''
                        INSERT INTO cortes_caja (
                            caja_id, empleado_id, fecha_apertura, monto_inicial, estatus, notas
                        ) VALUES (%s, %s, NOW(), %s, 'abierto', %s)
                    ''', [caja_id, empleado_id, monto_inicial, notas])
                    
                    # Actualizar estado de la caja
                    cursor.execute('''
                        UPDATE cajas SET estatus = 'abierta' WHERE id = %s
                    ''', [caja_id])
                
                messages.success(request, f"Caja {caja['nombre']} abierta con éxito. ¡Buen trabajo!")
                
                # Redirigir al módulo de caja en lugar de lista de cajas
                return redirect('modulo_caja')
                
            except Exception as e:
                messages.error(request, f"Error al abrir la caja: {str(e)}")
    
    return render(request, 'caja/apertura.html', {'caja': caja})

@login_required
@grupos_permitidos(['Administradores','Cajeros'])
def cierre_caja(request, caja_id):
    """Vista para cierre de caja"""
    with connections['pagoda'].cursor() as cursor:
        try:
            # Iniciar transacción
            cursor.execute("START TRANSACTION")
            
            # Verificar si la caja está abierta
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT cc.id, cc.fecha_apertura, cc.monto_inicial,
                       CONCAT(e.nombre, ' ', e.apellidos) as empleado_apertura
                FROM cortes_caja cc
                JOIN empleados e ON cc.empleado_id = e.id
                WHERE cc.caja_id = %s AND cc.estatus = 'abierto'
            ''', [caja_id])
            
            corte = dictfetchall(cursor)[0] if cursor.rowcount > 0 else None
            
            if not corte:
                # No hay corte abierto, realizar rollback y redirigir
                cursor.execute("ROLLBACK")
                return redirect('lista_cajas')
            
            # Obtener datos de la caja
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT c.id, c.nombre, c.ubicacion, s.nombre as sucursal
                FROM cajas c
                JOIN sucursales s ON c.sucursal_id = s.id
                WHERE c.id = %s
            ''', [caja_id])
            
            caja = dictfetchall(cursor)[0] if cursor.rowcount > 0 else None
            
            # Verificar si hay tickets abiertos
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT COUNT(*) as tickets_abiertos
                FROM ordenes
                WHERE estatus in ('abierta','por_cobrar')
            ''')
            
            tickets_abiertos = cursor.fetchone()[0] or 0
            
            # Obtener totales por método de pago
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT mp.nombre, SUM(p.monto) as total
                FROM pagos p
                JOIN metodos_pago mp ON p.metodo_pago_id = mp.id
                JOIN ordenes o ON p.orden_id = o.id
                WHERE o.corte_caja_id = %s AND p.estatus = 'completado'
                AND o.estatus = 'cerrada'
                GROUP BY mp.id
                ORDER BY mp.nombre
            ''', [corte['id']])
            
            totales_metodo = dictfetchall(cursor)
            
            # Calcular total de ventas
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT SUM(p.monto) as total_ventas
                FROM pagos p
                JOIN ordenes o ON p.orden_id = o.id
                WHERE o.corte_caja_id = %s AND p.estatus = 'completado'
            ''', [corte['id']])
            
            total_ventas = cursor.fetchone()[0] or 0
            
            # Calcular total en efectivo
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT SUM(p.monto) as total_ventas
                FROM pagos p
                JOIN ordenes o ON p.orden_id = o.id
                WHERE o.corte_caja_id = %s AND p.estatus = 'completado' and p.metodo_pago_id = 1
            ''', [corte['id']])
            
            total_efectivo = cursor.fetchone()[0] or 0
            
            # Procesar formulario POST
            if request.method == 'POST':
                # Verificar nuevamente si hay tickets abiertos antes de procesar el cierre
                if tickets_abiertos > 0:
                    # Hay tickets abiertos, realizar rollback
                    cursor.execute("ROLLBACK")
                    messages.error(request, f'No se puede cerrar la caja. Hay {tickets_abiertos} ticket(s) abierto(s).')
                    return render(request, 'caja/cierre.html', {
                        'caja': caja,
                        'corte': corte,
                        'totales_metodo': totales_metodo,
                        'total_ventas': total_ventas,
                        'monto_esperado': float(corte['monto_inicial']) + float(total_efectivo),
                        'tickets_abiertos': tickets_abiertos
                    })
                
                monto_final = request.POST.get('monto_final')
                notas = request.POST.get('notas', '')
                empleado_id = request.session.get('empleado_id')
                
                # Calcular diferencia
                diferencia = decimal.Decimal(monto_final) - (decimal.Decimal(corte['monto_inicial']) + total_efectivo)
                
                # Actualizar corte
                cursor.execute('''
                    UPDATE cortes_caja 
                    SET fecha_cierre = NOW(), monto_final = %s, diferencia = %s,
                        notas = CONCAT(IFNULL(notas, ''), '\n', %s), estatus = 'cerrado'
                    WHERE id = %s
                ''', [monto_final, diferencia, notas, corte['id']])
                
                # Actualizar estado de la caja
                cursor.execute('''
                    UPDATE cajas SET estatus = 'cerrada' WHERE id = %s
                ''', [caja_id])
                
                # Confirmar todos los cambios
                cursor.execute("COMMIT")
                
                return redirect('lista_cajas')
            
            # Si no es una solicitud POST, hacer rollback ya que solo estamos consultando
            cursor.execute("ROLLBACK")
            
            return render(request, 'caja/cierre.html', {
                'caja': caja,
                'corte': corte,
                'totales_metodo': totales_metodo,
                'total_ventas': total_ventas,
                'monto_esperado': float(corte['monto_inicial']) + float(total_efectivo),
                'tickets_abiertos': tickets_abiertos
            })
            
        except Exception as e:
            # En caso de error, hacer rollback y mostrar mensaje
            cursor.execute("ROLLBACK")
            messages.error(request, f'Error al procesar el cierre de caja: {str(e)}')
            return redirect('lista_cajas')
# ---------------------------------------------------------------
# VISTAS DE REPORTES
# ---------------------------------------------------------------

@login_required
def reporte_ventas_diarias(request):
    """Vista para reporte de ventas diarias"""
    fecha_inicio = request.GET.get('fecha_inicio', datetime.now().strftime('%Y-%m-%d'))
    fecha_fin = request.GET.get('fecha_fin', datetime.now().strftime('%Y-%m-%d'))
    
    with connections['pagoda'].cursor() as cursor:
        # Ventas diarias
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT DATE(o.fecha_apertura) as fecha,
                   COUNT(o.id) as ordenes,
                   SUM(o.subtotal) as subtotal,
                   SUM(o.impuestos) as impuestos,
                   SUM(o.costo_entrega) as costo_entrega,
                   SUM(o.descuento) as descuento,
                   SUM(o.propina) as propina,
                   SUM(o.total) as total
            FROM ordenes o
            WHERE DATE(o.fecha_apertura) BETWEEN %s AND %s
            AND o.estatus IN ('cerrada', 'entregada')
            GROUP BY DATE(o.fecha_apertura)
            ORDER BY fecha DESC
        ''', [fecha_inicio, fecha_fin])
        
        ventas_diarias = dictfetchall(cursor)
        
        # Ventas por tipo de servicio
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT ts.nombre as tipo_servicio,
                   COUNT(o.id) as ordenes,
                   SUM(o.total) as total
            FROM ordenes o
            JOIN tipos_servicio ts ON o.tipo_servicio_id = ts.id
            WHERE DATE(o.fecha_apertura) BETWEEN %s AND %s
            AND o.estatus IN ('cerrada', 'entregada')
            GROUP BY ts.id
            ORDER BY total DESC
        ''', [fecha_inicio, fecha_fin])
        
        ventas_tipo_servicio = dictfetchall(cursor)
        
        # Ventas por método de pago
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT mp.nombre as metodo_pago,
                   COUNT(p.id) as pagos,
                   SUM(p.monto) as total
            FROM pagos p
            JOIN metodos_pago mp ON p.metodo_pago_id = mp.id
            JOIN ordenes o ON p.orden_id = o.id
            WHERE DATE(o.fecha_apertura) BETWEEN %s AND %s
            AND p.estatus = 'completado'
            GROUP BY mp.id
            ORDER BY total DESC
        ''', [fecha_inicio, fecha_fin])
        
        ventas_metodo_pago = dictfetchall(cursor)
    
    return render(request, 'reportes/ventas_diarias.html', {
        'fecha_inicio': fecha_inicio,
        'fecha_fin': fecha_fin,
        'ventas_diarias': ventas_diarias,
        'ventas_tipo_servicio': ventas_tipo_servicio,
        'ventas_metodo_pago': ventas_metodo_pago
    })

@login_required
def reporte_productos_vendidos(request):
    """Vista para reporte de productos vendidos"""
    fecha_inicio = request.GET.get('fecha_inicio', datetime.now().strftime('%Y-%m-%d'))
    fecha_fin = request.GET.get('fecha_fin', datetime.now().strftime('%Y-%m-%d'))
    
    with connections['pagoda'].cursor() as cursor:
        # Productos más vendidos
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT p.id, p.nombre, cp.nombre as categoria,
                   SUM(od.cantidad) as cantidad,
                   SUM(od.subtotal) as subtotal,
                   SUM(od.total) as total
            FROM orden_detalles od
            JOIN productos p ON od.producto_id = p.id
            JOIN categorias_productos cp ON p.categoria_id = cp.id
            JOIN ordenes o ON od.orden_id = o.id
            WHERE DATE(o.fecha_apertura) BETWEEN %s AND %s
            AND o.estatus IN ('cerrada', 'entregada')
            AND od.cancelado = 0
            GROUP BY p.id
            ORDER BY cantidad DESC
            LIMIT 50
        ''', [fecha_inicio, fecha_fin])
        
        productos_vendidos = dictfetchall(cursor)
        
        # Ventas por categoría
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT cp.nombre as categoria,
                   COUNT(od.id) as items,
                   SUM(od.cantidad) as cantidad,
                   SUM(od.total) as total
            FROM orden_detalles od
            JOIN productos p ON od.producto_id = p.id
            JOIN categorias_productos cp ON p.categoria_id = cp.id
            JOIN ordenes o ON od.orden_id = o.id
            WHERE DATE(o.fecha_apertura) BETWEEN %s AND %s
            AND o.estatus IN ('cerrada', 'entregada')
            AND od.cancelado = 0
            GROUP BY cp.id
            ORDER BY total DESC
        ''', [fecha_inicio, fecha_fin])
        
        ventas_categoria = dictfetchall(cursor)
    
    return render(request, 'reportes/productos_vendidos.html', {
        'fecha_inicio': fecha_inicio,
        'fecha_fin': fecha_fin,
        'productos_vendidos': productos_vendidos,
        'ventas_categoria': ventas_categoria
    })

@login_required
def reporte_cortes_caja(request):
    """Vista para reporte de cortes de caja"""
    fecha_inicio = request.GET.get('fecha_inicio', datetime.now().strftime('%Y-%m-%d'))
    fecha_fin = request.GET.get('fecha_fin', datetime.now().strftime('%Y-%m-%d'))
    
    with connections['pagoda'].cursor() as cursor:
        # Cortes de caja
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT cc.id, c.nombre as caja, s.nombre as sucursal,
                   CONCAT(e.nombre, ' ', e.apellidos) as empleado,
                   cc.fecha_apertura, cc.fecha_cierre,
                   TIMESTAMPDIFF(HOUR, cc.fecha_apertura, IFNULL(cc.fecha_cierre, NOW())) as horas,
                   cc.monto_inicial, cc.monto_final, cc.diferencia,
                   (SELECT SUM(p.monto) 
                    FROM pagos p 
                    JOIN ordenes o ON p.orden_id = o.id 
                    WHERE o.corte_caja_id = cc.id AND p.estatus = 'completado') as total_ventas
            FROM cortes_caja cc
            JOIN cajas c ON cc.caja_id = c.id
            JOIN sucursales s ON c.sucursal_id = s.id
            JOIN empleados e ON cc.empleado_id = e.id
            WHERE DATE(cc.fecha_apertura) BETWEEN %s AND %s
            ORDER BY cc.fecha_apertura DESC
        ''', [fecha_inicio, fecha_fin])
        
        cortes = dictfetchall(cursor)
    
    return render(request, 'reportes/cortes_caja.html', {
        'fecha_inicio': fecha_inicio,
        'fecha_fin': fecha_fin,
        'cortes': cortes
    })

@csrf_exempt
@login_required
def buscar_cliente(request):
    """Vista para buscar cliente por nombre o teléfono (AJAX)"""
    query = request.GET.get('q', '')
    
    if len(query) < 3:
        return JsonResponse([], safe=False)
    
    with connections['pagoda'].cursor() as cursor:
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT id, CONCAT(nombre, ' ', IFNULL(apellidos, '')) as nombre_completo, 
                   telefono, email, cubiertos
            FROM clientes
            WHERE nombre LIKE %s OR apellidos LIKE %s OR telefono LIKE %s
            LIMIT 20
        ''', [f'%{query}%', f'%{query}%', f'%{query}%'])
        
        clientes = dictfetchall(cursor)
    
    return JsonResponse(clientes, safe=False)

@csrf_exempt
@login_required
def buscar_producto(request):
    """Vista para buscar producto por nombre o código (AJAX)"""
    query = request.GET.get('q', '')
    
    if len(query) < 3:
        return JsonResponse([], safe=False)
    
    with connections['pagoda'].cursor() as cursor:
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT p.id, p.nombre, p.codigo, p.precio_venta, 
                   c.nombre as categoria, p.imagen_url
            FROM productos p
            JOIN categorias_productos c ON p.categoria_id = c.id
            WHERE p.nombre LIKE %s OR p.codigo LIKE %s
            AND p.estatus = 'activo'
            LIMIT 20
        ''', [f'%{query}%', f'%{query}%'])
        
        productos = dictfetchall(cursor)
    
    return JsonResponse(productos, safe=False, json_dumps_params={'default': decimal_default})


import traceback
import logging
from django.db import connections, OperationalError, IntegrityError, DataError

logger = logging.getLogger(__name__)

@csrf_exempt
@login_required
def guardar_area(request):
    """Vista para guardar un área nueva o actualizar una existente"""
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    try:
        print("Iniciando guardar_area")
        data = json.loads(request.body)
        area_id = data.get('id')
        nombre = data.get('nombre')
        descripcion = data.get('descripcion', '')
        capacidad = data.get('capacidad', 0)
        estatus = data.get('estatus', 'activa')
        
        # Imprimir los datos para depuración
        print(f"Datos recibidos: area_id={area_id}, nombre={nombre}, capacidad={capacidad}")
        
        # Validar datos
        if not nombre:
            return JsonResponse({'success': False, 'error': 'El nombre del área es obligatorio'})
        
        # Obtener sucursal_id de la sesión
        sucursal_id = request.session.get('sucursal_id')
        print(f"sucursal_id de sesión: {sucursal_id}")
        
        # Si no hay sucursal_id, usar un valor predeterminado pero loguear
        if not sucursal_id:
            print("ADVERTENCIA: No hay sucursal_id en la sesión, usando valor predeterminado 1")
            sucursal_id = 1
        
        with connections['default'].cursor() as cursor:
            try:
                # Si tiene ID, actualizar área existente
                if area_id:
                    print(f"Actualizando área con ID: {area_id}")
                    query = '''
                        UPDATE areas
                        SET nombre = %s, descripcion = %s, capacidad = %s, estatus = %s, actualizado_en = NOW()
                        WHERE id = %s
                    '''
                    params = [nombre, descripcion, capacidad, estatus, area_id]
                    print(f"Query: {query}")
                    print(f"Params: {params}")
                    
                    cursor.execute(query, params)
                    
                    return JsonResponse({
                        'success': True,
                        'message': 'Área actualizada correctamente',
                        'area_id': area_id
                    })
                else:
                    # Crear nueva área
                    print(f"Creando nueva área para sucursal_id: {sucursal_id}")
                    
                    # Verificar la estructura de la tabla antes de insertar
                    cursor.execute("DESCRIBE areas")
                    table_structure = cursor.fetchall()
                    print(f"Estructura de tabla areas: {table_structure}")
                    
                    query = '''
                        INSERT INTO areas (sucursal_id, nombre, descripcion, capacidad, estatus, creado_en, actualizado_en)
                        VALUES (%s, %s, %s, %s, %s, NOW(), NOW())
                    '''
                    params = [sucursal_id, nombre, descripcion, capacidad, estatus]
                    print(f"Query: {query}")
                    print(f"Params: {params}")
                    
                    cursor.execute(query, params)
                    
                    # Obtener el ID del área creada
                    area_id = cursor.lastrowid
                    print(f"Área creada con ID: {area_id}")
                    
                    return JsonResponse({
                        'success': True,
                        'message': 'Área creada correctamente',
                        'area_id': area_id
                    })
            
            except OperationalError as e:
                error_msg = f"Error de operación en la base de datos: {str(e)}"
                print(error_msg)
                logger.error(error_msg)
                return JsonResponse({'success': False, 'error': error_msg}, status=500)
                
            except IntegrityError as e:
                error_msg = f"Error de integridad en la base de datos: {str(e)}"
                print(error_msg)
                logger.error(error_msg)
                return JsonResponse({'success': False, 'error': error_msg}, status=500)
                
            except DataError as e:
                error_msg = f"Error en los datos enviados: {str(e)}"
                print(error_msg)
                logger.error(error_msg)
                return JsonResponse({'success': False, 'error': error_msg}, status=500)
    
    except json.JSONDecodeError as e:
        error_msg = f"JSON inválido: {str(e)}"
        print(error_msg)
        logger.error(error_msg)
        return JsonResponse({'success': False, 'error': error_msg}, status=400)
        
    except Exception as e:
        error_msg = f"Error inesperado: {str(e)}"
        print(error_msg)
        print(traceback.format_exc())  # Imprimir el traceback completo
        logger.error(error_msg)
        logger.error(traceback.format_exc())
        return JsonResponse({'success': False, 'error': error_msg}, status=500)

@csrf_exempt
@login_required
def guardar_caja(request):
    """Vista para guardar una caja nueva o actualizar una existente"""
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'}, status=405)
    
    try:
        print("Iniciando guardar_caja")
        data = json.loads(request.body)
        caja_id = data.get('id')
        nombre = data.get('nombre')
        ubicacion = data.get('ubicacion', '')
        sucursal_id = data.get('sucursal_id')
        estatus = data.get('estatus', 'cerrada')
        
        # Imprimir los datos para depuración
        print(f"Datos recibidos: caja_id={caja_id}, nombre={nombre}, sucursal_id={sucursal_id}")
        
        # Validar datos
        if not nombre:
            return JsonResponse({'success': False, 'error': 'El nombre de la caja es obligatorio'})
        
        if not sucursal_id:
            return JsonResponse({'success': False, 'error': 'Debe seleccionar una sucursal'})
        
        with connections['pagoda'].cursor() as cursor:
            try:
                # Si tiene ID, actualizar caja existente
                if caja_id:
                    print(f"Actualizando caja con ID: {caja_id}")
                    query = '''
                        UPDATE cajas
                        SET nombre = %s, ubicacion = %s, sucursal_id = %s, estatus = %s, actualizado_en = NOW()
                        WHERE id = %s
                    '''
                    params = [nombre, ubicacion, sucursal_id, estatus, caja_id]
                    print(f"Query: {query}")
                    print(f"Params: {params}")
                    
                    cursor.execute(query, params)
                    
                    return JsonResponse({
                        'success': True,
                        'message': 'Caja actualizada correctamente',
                        'caja_id': caja_id
                    })
                else:
                    # Crear nueva caja
                    print(f"Creando nueva caja para sucursal_id: {sucursal_id}")
                    
                    query = '''
                        INSERT INTO cajas (sucursal_id, nombre, ubicacion, estatus, creado_en, actualizado_en)
                        VALUES (%s, %s, %s, %s, NOW(), NOW())
                    '''
                    params = [sucursal_id, nombre, ubicacion, estatus]
                    print(f"Query: {query}")
                    print(f"Params: {params}")
                    
                    cursor.execute(query, params)
                    
                    # Obtener el ID de la caja creada
                    caja_id = cursor.lastrowid
                    print(f"Caja creada con ID: {caja_id}")
                    
                    return JsonResponse({
                        'success': True,
                        'message': 'Caja creada correctamente',
                        'caja_id': caja_id
                    })
            
            except Exception as e:
                error_msg = f"Error en la base de datos: {str(e)}"
                print(error_msg)
                return JsonResponse({'success': False, 'error': error_msg}, status=500)
    
    except json.JSONDecodeError as e:
        error_msg = f"JSON inválido: {str(e)}"
        print(error_msg)
        return JsonResponse({'success': False, 'error': error_msg}, status=400)
        
    except Exception as e:
        error_msg = f"Error inesperado: {str(e)}"
        print(error_msg)
        print(traceback.format_exc())  # Imprimir el traceback completo
        return JsonResponse({'success': False, 'error': error_msg}, status=500)

@login_required
def cajas_disponibles(request):
    
    """Obtener cajas disponibles para cobro"""
    sucursal_id = 1
    
    with connections['pagoda'].cursor() as cursor:
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT id, nombre, ubicacion 
            FROM cajas 
            WHERE sucursal_id = %s AND estatus = 'abierta'
        ''', [sucursal_id])
        cajas = dictfetchall(cursor)
    
    return JsonResponse(cajas, safe=False)

@csrf_exempt
@login_required
@grupos_permitidos(['Administradores', 'Cajeros'])
def cerrar_orden(request, orden_id):
    """Vista para cerrar una orden y liberar mesa"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    empleado_id = request.session['empleado_id']

    try:
        with connections['pagoda'].cursor() as cursor:
            # Iniciar transacción
            cursor.execute('START TRANSACTION')
            
            try:
                # 0. NUEVO: Verificar que el empleado no tenga más de un corte abierto
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT COUNT(*) FROM cortes_caja 
                    WHERE estatus = 'abierto' AND empleado_id = %s
                ''', [empleado_id])
                
                num_cortes_abiertos = cursor.fetchone()[0] or 0
                
                if num_cortes_abiertos > 1:
                    cursor.execute('ROLLBACK')
                    return JsonResponse({
                        'error': 'Tiene múltiples cortes de caja abiertos. Contacte al administrador del sistema.',
                        'details': f'Se encontraron {num_cortes_abiertos} cortes abiertos para su usuario.'
                    }, status=400)
                
                # 1. Verificar estado actual y datos de la orden
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT o.estatus, o.mesa_id, o.total, o.corte_caja_id, 
                          (SELECT SUM(monto) FROM pagos WHERE orden_id = %s AND estatus = 'completado') as pagado
                    FROM ordenes o
                    WHERE o.id = %s
                ''', [orden_id, orden_id])
                
                orden = cursor.fetchone()
                if not orden:
                    cursor.execute('ROLLBACK')
                    return JsonResponse({'error': 'Orden no encontrada'}, status=404)
                
                estatus = orden[0]
                mesa_id = orden[1]
                total = orden[2] or 0
                corte_caja_id = orden[3]
                pagado = orden[4] or 0
                
                # 2. Verificar que la orden está en estado correcto
                if estatus != 'por_cobrar':
                    cursor.execute('ROLLBACK')
                    return JsonResponse({
                        'error': 'La orden debe estar en estado "por_cobrar" para cerrarla'
                    }, status=400)
                
                # 3. Verificar que el pago está completo
                diferencia = abs(total - pagado)
                if diferencia >= decimal.Decimal('0.01'):  # Más de 1 centavo de diferencia
                    cursor.execute('ROLLBACK')
                    return JsonResponse({
                        'error': f'El pago no está completo. Pendiente: {float(total - pagado)}'
                    }, status=400)
                
                # 4. Verificar que todos los pagos sean del mismo corte
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT COUNT(DISTINCT corte_caja_id) 
                    FROM pagos 
                    WHERE orden_id = %s AND estatus = 'completado' AND corte_caja_id IS NOT NULL
                ''', [orden_id])
                
                num_cortes = cursor.fetchone()[0]
                if num_cortes > 1:
                    cursor.execute('ROLLBACK')
                    return JsonResponse({
                        'error': 'La orden tiene pagos en diferentes cortes de caja'
                    }, status=400)
                
                # 5. Verificar que el empleado del corte de caja coincide con el usuario actual
                if corte_caja_id:
                    cursor.execute('''
                        SET STATEMENT max_statement_time = 25 FOR SELECT empleado_id, caja_id FROM cortes_caja 
                        WHERE id = %s
                    ''', [corte_caja_id])
                    
                    corte_info = cursor.fetchone()
                    if not corte_info:
                        cursor.execute('ROLLBACK')
                        return JsonResponse({
                            'error': 'No se encontró información del corte de caja'
                        }, status=400)
                    
                    corte_empleado_id = corte_info[0]
                    caja_id = corte_info[1]
                    
                    if corte_empleado_id != empleado_id:
                        cursor.execute('ROLLBACK')
                        return JsonResponse({
                            'error': 'Solo el cajero que inició el corte de caja puede cerrar esta orden'
                        }, status=403)
                else:
                    # Buscar un corte de caja abierto para el empleado actual
                    cursor.execute('''
                        SET STATEMENT max_statement_time = 25 FOR SELECT id, caja_id FROM cortes_caja 
                        WHERE estatus = 'abierto' AND empleado_id = %s
                        LIMIT 1
                    ''', [empleado_id])
                    
                    corte_actual = cursor.fetchone()
                    if not corte_actual:
                        cursor.execute('ROLLBACK')
                        return JsonResponse({
                            'error': 'No tiene un corte de caja abierto para asociar a esta orden'
                        }, status=400)
                    
                    corte_caja_id = corte_actual[0]
                    caja_id = corte_actual[1]
                    
                    # Actualizar el corte_caja_id en la orden
                    cursor.execute('''
                        UPDATE ordenes SET corte_caja_id = %s
                        WHERE id = %s
                    ''', [corte_caja_id, orden_id])
                
                # 5b. Actualizar pagos que no tienen corte_caja_id ni caja_id
                cursor.execute('''
                    UPDATE pagos 
                    SET corte_caja_id = %s, caja_id = %s
                    WHERE orden_id = %s AND estatus = 'completado' AND corte_caja_id IS NULL
                ''', [corte_caja_id, caja_id, orden_id])
                
                # Verificar si se actualizaron pagos
                rows_affected = cursor.rowcount
                if rows_affected > 0:
                    print(f"Se actualizaron {rows_affected} pagos con corte_caja_id={corte_caja_id} y caja_id={caja_id}")
                
                # 6. Todo está correcto, actualizar estado de la orden
                cursor.execute('''
                    UPDATE ordenes SET 
                        estatus = 'cerrada',
                        fecha_cierre = NOW()
                    WHERE id = %s
                ''', [orden_id])
                
                # 7. Si tiene mesa, liberarla (cambiar a disponible)
                if mesa_id:
                    cursor.execute('''
                        UPDATE mesas SET estatus = 'disponible' 
                        WHERE id = %s
                    ''', [mesa_id])
                
                # 8. Registrar en historial
                cursor.execute('''
                    INSERT INTO orden_historial_estados (
                        orden_id, estado_anterior, estado_nuevo, empleado_id, motivo
                    ) VALUES (%s, %s, 'cerrada', %s, 'Cierre manual de orden')
                ''', [orden_id, estatus, empleado_id])
                
                # Confirmar transacción
                cursor.execute('COMMIT')
                
                return JsonResponse({
                    'success': True,
                    'mensaje': 'Orden cerrada correctamente'
                })
                
            except Exception as e:
                cursor.execute('ROLLBACK')
                return JsonResponse({'error': str(e)}, status=500)
                
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def ver_orden(request, orden_id, retorno=None):
    """Vista para ver y editar una orden existente"""
    with connections['pagoda'].cursor() as cursor:
        # 1. Obtener datos principales de la orden
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT o.*, 
                   ts.nombre as tipo_servicio,
                   m.numero as mesa_numero,
                   CONCAT(c.nombre, ' ', IFNULL(c.apellidos, '')) as cliente,
                   CONCAT(e.nombre, ' ', e.apellidos) as empleado,
                   CASE
                       WHEN o.tipo_servicio_id = 3 THEN
                           (SELECT CONCAT(calle, ' ', numero_exterior, ', ', colonia)
                            FROM direcciones_cliente
                            WHERE id = o.direccion_entrega_id)
                       ELSE NULL
                   END as direccion_entrega,
                   o.estatus_preparacion,
                   o.estatus_entrega,
                   o.programado,
                   o.fecha_programado,
                   o.nombre_tk
            FROM ordenes o
            LEFT JOIN mesas m ON o.mesa_id = m.id
            LEFT JOIN clientes c ON o.cliente_id = c.id
            JOIN empleados e ON o.empleado_id = e.id
            JOIN tipos_servicio ts ON o.tipo_servicio_id = ts.id
            WHERE o.id = %s
        ''', [orden_id])
        
        orden = dictfetchall(cursor)[0] if cursor.rowcount > 0 else None
        
        if not orden:
            return HttpResponseNotFound('Orden no encontrada')
        
        # 2. Obtener items de la orden
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT od.*, p.nombre as producto, p.imagen_url
            FROM orden_detalles od
            JOIN productos p ON od.producto_id = p.id
            WHERE od.orden_id = %s
        ''', [orden_id])
        
        items = dictfetchall(cursor)
        
        # Añadir el flag 'editable' a cada item según las validaciones
        for item in items:
            editable = False
            
            # Verificar si el producto NO está preparado
            if item['preparado'] == 0:
                # Validar según tipo de servicio
                if orden['tipo_servicio_id'] == 1 or orden['tipo_servicio_id'] == 4:
                    # Tipo 1: Solo si está "abierta" y sin preparación
                    editable = orden['estatus'] == 'abierta' and orden['estatus_preparacion'] is None
                elif orden['tipo_servicio_id'] == 2:
                    # Tipo 2: Si está "abierta" o "por_cobrar" y sin preparación
                    editable = orden['estatus'] in ['abierta', 'por_cobrar'] and orden['estatus_preparacion'] is None
                elif orden['tipo_servicio_id'] == 3:
                    # Tipo 3: Si está "abierta" o "por_cobrar", sin preparación y entrega abierta
                    editable = (orden['estatus'] in ['abierta', 'por_cobrar'] and 
                               orden['estatus_preparacion'] is None and 
                               orden['estatus_entrega'] == 'abierta')
                else:
                    # Otros tipos: Solo si está "abierta"
                    editable = orden['estatus'] == 'abierta'
            
            item['editable'] = editable
        
        # Determinar si se pueden agregar productos según la nueva lógica
        puede_agregar = False
        
        if orden['tipo_servicio_id'] == 1 or orden['tipo_servicio_id'] == 4:
            # Comedor
            if orden['estatus'] == 'abierta' and (orden['estatus_preparacion'] is None or orden['estatus_preparacion'] == 'lista'):
                puede_agregar = True
        elif orden['tipo_servicio_id'] == 2:
            # Para llevar
            if (orden['estatus'] == 'abierta' or orden['estatus'] == 'por_cobrar') and (orden['estatus_preparacion'] is None or orden['estatus_preparacion'] == 'lista'):
                puede_agregar = True
        elif orden['tipo_servicio_id'] == 3:
            # Domicilio
            if (orden['estatus'] == 'abierta' or orden['estatus'] == 'por_cobrar') and (orden['estatus_preparacion'] is None or orden['estatus_preparacion'] == 'lista') and orden['estatus_entrega'] == 'abierta':
                puede_agregar = True
        
        # Determinar si se puede cambiar el tipo de servicio
        puede_cambiar_tipo = False
        if orden['tipo_servicio_id'] == 1 or orden['tipo_servicio_id'] == 4:
            # Tipo 1: Si estatus es 'abierta'
            puede_cambiar_tipo = orden['estatus'] == 'abierta'
        elif orden['tipo_servicio_id'] == 2:
            # Tipo 2: Si estatus es 'por_cobrar'
            puede_cambiar_tipo = orden['estatus'] == 'por_cobrar'
        elif orden['tipo_servicio_id'] == 3:
            # Tipo 3: Si estatus es 'por_cobrar' y estatus_entrega es 'abierta'
            puede_cambiar_tipo = orden['estatus'] == 'por_cobrar' and orden['estatus_entrega'] == 'abierta'

        # Añadir variable para controlar botón "Asignar Mesa"
        puede_asignar_mesa = False
        if orden['tipo_servicio_id'] == 4 and orden['estatus'] == 'abierta' and not orden['mesa_id']:
            puede_asignar_mesa = True    
        
        # 3. Obtener modificadores para cada item
        for item in items:
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT opm.*, om.nombre
                FROM orden_producto_modificadores opm
                JOIN opciones_modificador om ON opm.opcion_modificador_id = om.id
                WHERE opm.orden_detalle_id = %s
            ''', [item['id']])
            item['modificadores'] = dictfetchall(cursor)
        
        orden['items'] = items
        
        # 4. Obtener pagos existentes
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT p.*, mp.nombre as metodo_pago
            FROM pagos p
            JOIN metodos_pago mp ON p.metodo_pago_id = mp.id
            WHERE p.orden_id = %s
            and p.estatus = 'completado'
        ''', [orden_id])
        
        orden['pagos'] = dictfetchall(cursor)
        
        # 5. Obtener categorías para selector de productos (solo si puede agregar)
        categorias = []
        if puede_agregar:
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT id, nombre 
                FROM categorias_productos 
                WHERE visible_menu = 1 
                ORDER BY nombre
            ''')
            categorias = dictfetchall(cursor)
        
        # 6. Obtener métodos de pago disponibles
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT id, nombre, requiere_comprobacion
            FROM metodos_pago
            WHERE activo = 1
            ORDER BY id asc
        ''')
        metodos_pago = dictfetchall(cursor)

        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT id, nombre, costo_adicional
            FROM tipos_servicio
            WHERE activo = 1
        ''')
        tipos_servicio = dictfetchall(cursor)

        # Determinar si se puede cerrar la orden
        puede_cerrar_orden = False
        corte_info = None
        empleado_id = request.session.get('empleado_id')
        grupos_usuario = request.user.groups.values_list('name', flat=True)
        
        # Validar si el usuario tiene permisos
        if 'Administradores' in grupos_usuario or 'Cajeros' in grupos_usuario:
            if empleado_id and orden['estatus'] == 'por_cobrar':
                # Verificar si tiene un corte abierto
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT cc.id, c.nombre as caja_nombre
                    FROM cortes_caja cc
                    JOIN cajas c ON cc.caja_id = c.id
                    WHERE cc.empleado_id = %s AND cc.estatus = 'abierto'
                    LIMIT 1
                ''', [empleado_id])
                
                corte_info = cursor.fetchone()
                if corte_info:
                    puede_cerrar_orden = True
                    corte_info = {
                        'id': corte_info[0],  # El id es el número de corte
                        'caja_nombre': corte_info[1]
                    }

        puede_cambiar_fecha_programada = False

        # Solo evaluar las condiciones para los tipos 2 y 3
        if orden['tipo_servicio_id'] in [2, 3]:
            # Verificar que no esté cancelada y no esté en preparación o lista
            if orden['estatus'] != 'cancelada' and (orden['estatus_preparacion'] is None or orden['estatus_preparacion'] not in ['en_preparacion', 'lista']):
                # Para domicilio, verificar que la entrega esté abierta
                if orden['tipo_servicio_id'] == 3:
                    puede_cambiar_fecha_programada = orden['estatus_entrega'] == 'abierta'
                else:
                    puede_cambiar_fecha_programada = True      
                
    return render(request, 'pos/detalle_orden.html', {
        'orden': orden,
        'categorias': categorias,
        'empleado': request.user,
        'metodos_pago': metodos_pago,  
        'tipos_servicio': tipos_servicio,
        'retorno': retorno,
        'puede_agregar': puede_agregar,
        'puede_cambiar_tipo': puede_cambiar_tipo,
        'puede_cerrar_orden': puede_cerrar_orden,
        'corte_info': corte_info,
        'puede_cambiar_fecha_programada': puede_cambiar_fecha_programada,
        'puede_asignar_mesa': puede_asignar_mesa  # Nueva variable
    })


@csrf_exempt
@login_required
@grupos_permitidos(['Administradores', 'Meseros'])
def asignar_mesa(request):
    """Vista para asignar mesa a un pedido de comedor programado (tipo 4) y convertirlo a tipo 1"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        orden_id = data.get('orden_id')
        mesa_id = data.get('mesa_id')
        empleado_id = request.session['empleado_id']

        # Validaciones básicas
        if not orden_id or not mesa_id:
            return JsonResponse({'error': 'Datos incompletos'}, status=400)
        
        with connections['pagoda'].cursor() as cursor:
            # 1. Verificar que la orden existe y es tipo 4
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT id, tipo_servicio_id, mesa_id, estatus 
                FROM ordenes
                WHERE id = %s
            ''', [orden_id])
            
            orden = cursor.fetchone()
            if not orden:
                return JsonResponse({'error': 'Orden no encontrada'}, status=404)
            
            # Validar que la orden sea tipo 4
            if orden[1] != 4:
                return JsonResponse({'error': 'La orden no es de tipo comedor programado'}, status=400)
            
            # Validar que la orden no tenga mesa asignada
            if orden[2] is not None:
                return JsonResponse({'error': 'La orden ya tiene una mesa asignada'}, status=400)
            
            # Validar que la orden esté abierta
            if orden[3] != 'abierta':
                return JsonResponse({'error': 'La orden debe estar en estado abierto para asignar mesa'}, status=400)
            
            # 2. Verificar que la mesa esté disponible
            cursor.execute('SET STATEMENT max_statement_time = 25 FOR SELECT estatus FROM mesas WHERE id = %s', [mesa_id])
            mesa = cursor.fetchone()
            if not mesa or mesa[0] != 'disponible':
                return JsonResponse({'error': 'La mesa seleccionada no está disponible'}, status=400)
            
            # Iniciar transacción
            cursor.execute('START TRANSACTION')
            
            try:
                # 3. Cambiar tipo de servicio a 1 (comedor) y asignar mesa
                cursor.execute('''
                    UPDATE ordenes 
                    SET tipo_servicio_id = 1,
                        mesa_id = %s,
                        actualizado_en = NOW()
                    WHERE id = %s
                ''', [mesa_id, orden_id])
                
                # 4. Marcar la mesa como ocupada
                cursor.execute('UPDATE mesas SET estatus = "ocupada" WHERE id = %s', [mesa_id])
                
                # 5. Registrar el cambio en el historial
                cursor.execute('''
                    INSERT INTO orden_historial_estados (
                        orden_id, estado_anterior, estado_nuevo, empleado_id, motivo
                    ) VALUES (%s, %s, %s, %s, %s)
                ''', [
                    orden_id,
                    'Tipo 4-abierta',
                    'Tipo 1-abierta',
                    empleado_id,
                    'Conversión de pedido programado a comedor con asignación de mesa'
                ])
                
                # Confirmar transacción
                cursor.execute('COMMIT')
                
                return JsonResponse({
                    'success': True,
                    'mensaje': 'Mesa asignada correctamente. La orden ha sido convertida a servicio de comedor.'
                })
                
            except Exception as e:
                cursor.execute('ROLLBACK')
                return JsonResponse({'error': str(e)}, status=500)
    
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Formato JSON inválido'}, status=400)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)    

@csrf_exempt
@login_required
@grupos_permitidos(['Administradores', 'Meseros', 'Delivery','Operadores','Rapidos'])
def agregar_producto_orden(request):
    """Vista para agregar un producto a una orden existente con logging detallado"""
    logger.info("Iniciando agregar_producto_orden")
    
    if request.method != 'POST':
        logger.error("Método no permitido")
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        logger.debug("Parseando JSON del request")
        data = json.loads(request.body)
        
        producto_id = data.get('producto_id')
        cantidad_raw = data.get('cantidad', 1)
        notas = data.get('notas', '')
        orden_id = data.get('orden_id')
        pagos_ajustados = data.get('pagos_ajustados', None)  # Parámetro nuevo para recibir pagos ajustados
        
        try:
            # Verificar si el valor es un número entero
            if isinstance(cantidad_raw, float) and not cantidad_raw.is_integer():
                logger.error(f"Cantidad no es un entero: {cantidad_raw}")
                return JsonResponse({
                    'error': 'La cantidad debe ser un número entero',
                    'success': False
                }, status=400)
            
            cantidad = int(cantidad_raw)
            # Validar que la cantidad sea mayor a cero
            if cantidad <= 0:
                logger.error(f"Cantidad debe ser mayor a cero: {cantidad}")
                return JsonResponse({
                    'error': 'La cantidad debe ser mayor a cero',
                    'success': False
                }, status=400)
                
        except (ValueError, TypeError):
            logger.error(f"Error convirtiendo cantidad a entero: {cantidad_raw}")
            return JsonResponse({
                'error': 'La cantidad debe ser un número entero válido',
                'success': False
            }, status=400)
        
        logger.debug(f"Datos recibidos - producto_id: {producto_id}, cantidad: {cantidad}, orden_id: {orden_id}")
        
        if not all([producto_id, orden_id]):
            logger.error("Datos incompletos recibidos")
            return JsonResponse({'error': 'Datos incompletos'}, status=400)
        
        with connections['pagoda'].cursor() as cursor:
            try:
                # 1. Verificar que la orden existe y obtener el tipo de servicio
                logger.debug(f"Verificando orden {orden_id}")
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT estatus, tipo_servicio_id, estatus_preparacion, estatus_entrega
                    FROM ordenes 
                    WHERE id = %s
                ''', [orden_id])
                
                orden = cursor.fetchone()
                
                if not orden:
                    logger.error(f"Orden {orden_id} no encontrada")
                    return JsonResponse({'error': 'La orden no existe'}, status=404)
                
                estatus_orden = orden[0]
                tipo_servicio = orden[1]
                estatus_preparacion = orden[2]
                estatus_entrega = orden[3] if len(orden) > 3 else None
                
                logger.debug(f"Datos orden - estatus: {estatus_orden}, tipo_servicio: {tipo_servicio}, estatus_preparacion: {estatus_preparacion}, estatus_entrega: {estatus_entrega}")
                
                # Verificar permisos según el tipo de servicio
                grupos_usuario = request.user.groups.values_list('name', flat=True)
                tiene_permiso = False
                
                if tipo_servicio == 1:
                    # Comedor: Solo Administradores y Meseros
                    if 'Administradores' in grupos_usuario or 'Meseros' in grupos_usuario:
                        tiene_permiso = True
                elif tipo_servicio == 2:
                    # Para llevar: Solo Rapidos, Administradores y Operadores
                    if 'Rapidos' in grupos_usuario or 'Administradores' in grupos_usuario or 'Operadores' in grupos_usuario or 'Rapidos' in grupos_usuario:
                        tiene_permiso = True
                elif tipo_servicio == 3:
                    # Domicilio: Solo Delivery, Administradores y Operadores
                    if 'Delivery' in grupos_usuario or 'Administradores' in grupos_usuario or 'Operadores' in grupos_usuario or 'Delivery' in grupos_usuario:
                        tiene_permiso = True
                elif tipo_servicio == 4:
                    # Domicilio: Solo Delivery, Administradores y Operadores
                    if 'Delivery' in grupos_usuario or 'Administradores' in grupos_usuario or 'Operadores' in grupos_usuario or 'Meseros' in grupos_usuario:
                        tiene_permiso = True        
                
                if not tiene_permiso:
                    logger.error(f"Usuario sin permisos para tipo de servicio {tipo_servicio}")
                    return JsonResponse({
                        'success': False,
                        'error': 'sin_permisos',
                        'message': f'No tiene permiso para ejecutar esta acción en órdenes de tipo {tipo_servicio}'
                    }, status=403)
                
                # 2. Verificar stock del producto (con bloqueo FOR UPDATE) y obtener datos del producto
                logger.debug(f"Verificando producto {producto_id} con bloqueo FOR UPDATE")
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT id, nombre, stock_actual, control_inventario, 
                        precio_venta, vista_cocina, iva_incluido, porcentaje_iva
                    FROM productos 
                    WHERE id = %s FOR UPDATE
                ''', [producto_id])
                producto = cursor.fetchone()
                
                if not producto:
                    logger.error(f"Producto {producto_id} no encontrado")
                    return JsonResponse({'error': 'Producto no encontrado'}, status=404)
                
                producto_id = producto[0]
                producto_nombre = producto[1]
                stock_actual = float(producto[2] or 0) if producto[2] is not None else 0
                control_inventario = producto[3]
                precio_unitario = producto[4]
                vista_cocina = producto[5] if len(producto) > 5 else 1  # Default a 1 si no existe la columna
                iva_incluido = producto[6] if len(producto) > 6 else 0  # Default a 0 si no existe la columna
                porcentaje_iva = producto[7] if len(producto) > 7 else 0  # Default a 0 si no existe la columna
                
                logger.debug(f"Datos producto - nombre: {producto_nombre}, stock: {stock_actual}, " + 
                           f"control_inventario: {control_inventario}, precio: {precio_unitario}, " +
                           f"vista_cocina: {vista_cocina}, iva_incluido: {iva_incluido}, porcentaje_iva: {porcentaje_iva}")
                
                # Verificar si se puede agregar producto según el tipo de servicio y estatus (NUEVA LÓGICA)
                puede_agregar = False
                
                if tipo_servicio == 1 or tipo_servicio == 4:
                    # Comedor
                    if estatus_orden == 'abierta' and (estatus_preparacion is None or estatus_preparacion == 'lista'):
                        puede_agregar = True
                elif tipo_servicio == 2:
                    # Para llevar
                    if (estatus_orden == 'abierta' or estatus_orden == 'por_cobrar') and (estatus_preparacion is None or estatus_preparacion == 'lista'):
                        puede_agregar = True
                elif tipo_servicio == 3:
                    # Domicilio
                    if (estatus_orden == 'abierta' or estatus_orden == 'por_cobrar') and (estatus_preparacion is None or estatus_preparacion == 'lista') and estatus_entrega == 'abierta':
                        puede_agregar = True
                
                if not puede_agregar:
                    mensaje_error = "No se pueden agregar productos a esta orden según su estado actual"
                    logger.error(f"Orden {orden_id} en estado inválido para agregar productos. " + 
                               f"Tipo: {tipo_servicio}, Estatus: {estatus_orden}, Preparación: {estatus_preparacion}, Entrega: {estatus_entrega}")
                    return JsonResponse({
                        'success': False,
                        'error': 'estado_invalido',
                        'message': mensaje_error
                    }, status=400)
                
                # Verificación de stock
                if control_inventario:
                    if stock_actual < float(cantidad):
                        logger.error(f"Stock insuficiente. Producto: {producto_nombre}, Stock: {stock_actual}, Solicitado: {cantidad}")
                        return JsonResponse({
                            'success': False,
                            'error': 'stock_insuficiente',
                            'message': 'No hay suficiente stock para este producto',
                            'producto': {
                                'id': producto_id,
                                'nombre': producto_nombre,
                                'stock_actual': stock_actual,
                                'cantidad_solicitada': cantidad
                            }
                        }, status=400)
                
                # MODIFICACIÓN: Verificar si hay pagos asociados y obtener información detallada
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT p.metodo_pago_id, p.monto, p.id, mp.nombre, mp.requiere_comprobacion, p.referencia
                    FROM pagos p
                    JOIN metodos_pago mp ON p.metodo_pago_id = mp.id
                    WHERE p.orden_id = %s
                    AND p.estatus = 'completado'
                    ORDER BY p.fecha_pago
                ''', [orden_id])
                
                pagos = cursor.fetchall()
                tiene_un_pago = len(pagos) == 1
                tiene_dos_pagos = len(pagos) == 2
                tiene_tres_o_mas_pagos = len(pagos) >= 3
                
                # Si tiene 3 o más pagos, no permitir la operación
                if tiene_tres_o_mas_pagos:
                    logger.error(f"Orden {orden_id} tiene tres o más pagos registrados. No se puede modificar.")
                    return JsonResponse({
                        'success': False,
                        'error': 'multiple_payments',
                        'message': 'Se detectaron tres o más registros de método de pago. Para poder continuar debe cancelar primero esos pagos.',
                        'pagos_count': len(pagos)
                    }, status=400)
                
                # Si tiene dos pagos y no se recibieron pagos_ajustados, devolver datos para mostrar modal
                if tiene_dos_pagos and not pagos_ajustados:
                    # Calcular nuevo total después de agregar el producto
                    precio_total_producto = decimal.Decimal(precio_unitario) * decimal.Decimal(str(cantidad))
                    
                    # Obtener el total actual de la orden
                    cursor.execute('''
                        SET STATEMENT max_statement_time = 25 FOR SELECT total FROM ordenes WHERE id = %s
                    ''', [orden_id])
                    total_actual = float(cursor.fetchone()[0])
                    
                    nuevo_total_orden = total_actual + float(precio_total_producto)
                    
                    # Obtener información detallada de las formas de pago
                    metodos_pago = []
                    for pago in pagos:
                        metodo_id, monto, pago_id, nombre, requiere_comprobacion, referencia = pago
                        metodos_pago.append({
                            'metodo_id': metodo_id,
                            'nombre': nombre,
                            'monto': float(monto),
                            'pago_id': pago_id,
                            'requiere_comprobacion': requiere_comprobacion,
                            'referencia': referencia or ''
                        })
                    
                    # Retornar respuesta especial para ajuste de pagos en frontend
                    logger.info(f"Orden {orden_id} tiene dos formas de pago. Se requiere ajuste por el usuario.")
                    return JsonResponse({
                        'success': False,
                        'requiere_ajuste_pagos': True,
                        'message': 'Se detectaron dos formas de pago. Es necesario ajustar la distribución.',
                        'pagos': metodos_pago,
                        'total_anterior': total_actual,
                        'total_nuevo': nuevo_total_orden,
                        'accion': 'agregar_producto',
                        'producto_id': producto_id,
                        'cantidad': cantidad,
                        'notas': notas
                    })
                
                # Iniciar transacción
                logger.debug("Iniciando transacción")
                cursor.execute('START TRANSACTION')
                
                try:
                    # 4. Si controla inventario, reducir el stock
                    if control_inventario:
                        logger.debug(f"Actualizando stock. Reduciendo {cantidad} unidades de producto {producto_id}")
                        cursor.execute('''
                            UPDATE productos 
                            SET stock_actual = stock_actual - %s 
                            WHERE id = %s
                        ''', [cantidad, producto_id])
                    
                    # 5. Calcular subtotal e IVA según la nueva interpretación
                    # Precio unitario es el precio que paga el cliente (con o sin impuestos)
                    precio_total_item = precio_unitario * decimal.Decimal(str(cantidad))
                    
                    # NUEVA LÓGICA:
                    # Si iva_incluido = 0: El producto NO CAUSA impuestos (está exento)
                    # Si iva_incluido = 1: El producto CAUSA impuestos y el precio YA INCLUYE el IVA
                    
                    if iva_incluido == 1 and porcentaje_iva > 0:
                        # El producto CAUSA impuestos y el precio YA INCLUYE el IVA
                        # Calcular cuánto del precio total es IVA (para contabilidad)
                        iva_factor = decimal.Decimal(str(porcentaje_iva)) / 100 + 1
                        precio_sin_iva = precio_unitario / iva_factor
                        subtotal_item = precio_sin_iva * decimal.Decimal(str(cantidad))
                        iva_item = precio_total_item - subtotal_item
                        logger.debug(f"Item con IVA incluido - Precio: {precio_unitario}, Subtotal: {subtotal_item}, IVA: {iva_item}")
                    else:
                        # El producto NO CAUSA impuestos (está exento)
                        # O el porcentaje de IVA es 0
                        subtotal_item = precio_total_item
                        iva_item = decimal.Decimal(0)
                        logger.debug(f"Item exento de IVA - Precio: {precio_unitario}, Subtotal: {subtotal_item}")

                    # 6. Insertar detalle de orden con los valores correctos de IVA
                    logger.debug(f"Insertando detalle. Subtotal: {subtotal_item}, IVA: {iva_item}, Total: {precio_total_item}")
                    
                    cursor.execute('''
                        INSERT INTO orden_detalles (
                            orden_id, producto_id, cantidad, precio_unitario,
                            subtotal, iva, total, notas
                        ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                    ''', [
                        orden_id, producto_id, cantidad, float(precio_unitario),
                        float(subtotal_item), float(iva_item), float(precio_total_item), notas
                    ])
                    
                    detalle_id = cursor.lastrowid
                    logger.debug(f"Detalle insertado. ID: {detalle_id}")
                    
                    # 7. Actualizar totales de la orden, incluyendo impuestos
                    logger.debug(f"Actualizando totales de orden {orden_id}")
                    cursor.execute('''
                        UPDATE ordenes 
                        SET subtotal = subtotal + %s,
                            impuestos = impuestos + %s,
                            total = total + %s,
                            actualizado_en = NOW()
                        WHERE id = %s
                    ''', [float(subtotal_item), float(iva_item), float(precio_total_item), orden_id])
                    
                    # 8. Actualizar estado de preparación si es necesario y vista_cocina != 0
                    # Los productos con vista_cocina = 0 no deben cambiar el estado de la orden
                    if vista_cocina != 0 and estatus_preparacion == 'lista':
                        logger.debug(f"Cambiando estado de preparación de orden {orden_id} de 'lista' a 'abierta'")
                        cursor.execute('''
                            UPDATE ordenes 
                            SET estatus_preparacion = NULL,
                                actualizado_en = NOW()
                            WHERE id = %s
                        ''', [orden_id])
                        logger.info(f"Estado de preparación de orden {orden_id} actualizado a 'abierta'")
                    
                    # 9. NUEVA LÓGICA PARA PAGOS:
                    # - Si hay un solo pago: actualizar su monto
                    # - Si hay dos pagos y se recibieron pagos_ajustados: cancelar los existentes y crear nuevos
                    
                    if tiene_un_pago and estatus_orden == 'por_cobrar':
                        # Obtener el total actualizado de la orden
                        cursor.execute('''
                            SET STATEMENT max_statement_time = 25 FOR SELECT total FROM ordenes WHERE id = %s
                        ''', [orden_id])
                        nuevo_total = cursor.fetchone()[0]
                        
                        metodo_pago_id, monto_pago, pago_id = pagos[0][0:3]
                        
                        cursor.execute('''
                            UPDATE pagos
                            SET monto = %s,
                                actualizado_en = NOW()
                            WHERE id = %s
                        ''', [float(nuevo_total), pago_id])
                        
                        logger.info(f"Pago {pago_id} actualizado con nuevo monto {nuevo_total} para orden {orden_id}")
                    
                    # Si hay dos pagos y se recibieron pagos ajustados, actualizar los pagos
                    elif tiene_dos_pagos and pagos_ajustados and estatus_orden == 'por_cobrar':
                        empleado_id = request.session.get('empleado_id')
                        
                        # Verificar que la suma de los pagos ajustados coincide con el nuevo total
                        cursor.execute('''
                            SET STATEMENT max_statement_time = 25 FOR SELECT total FROM ordenes WHERE id = %s
                        ''', [orden_id])
                        nuevo_total = float(cursor.fetchone()[0])
                        
                        # Sumar los montos de los pagos ajustados
                        total_pagos_ajustados = sum(float(pago.get('monto', 0)) for pago in pagos_ajustados)
                        
                        # Validar que la suma coincida (con un margen de error de 0.01)
                        if abs(total_pagos_ajustados - nuevo_total) > 0.01:
                            cursor.execute('ROLLBACK')
                            return JsonResponse({
                                'success': False,
                                'error': 'montos_incorrectos',
                                'message': 'La suma de los montos ajustados no coincide con el total de la orden'
                            }, status=400)
                        
                        # Cancelar pagos existentes
                        cursor.execute('''
                            UPDATE pagos 
                            SET estatus = 'cancelado', 
                                fecha_cancelacion = NOW()
                            WHERE orden_id = %s 
                            AND estatus = 'completado'
                        ''', [orden_id])
                        
                        # Crear nuevos pagos con los montos ajustados
                        for pago in pagos_ajustados:
                            cursor.execute('''
                                INSERT INTO pagos (
                                    orden_id, metodo_pago_id, empleado_id,
                                    monto, referencia, estatus, fecha_pago
                                ) VALUES (%s, %s, %s, %s, %s, %s, NOW())
                            ''', [
                                orden_id, pago.get('metodo_id'), empleado_id,
                                pago.get('monto'), pago.get('referencia', ''), 'completado'
                            ])
                    
                    # Confirmar transacción
                    logger.debug("Confirmando transacción")
                    cursor.execute('COMMIT')
                    
                    logger.info(f"Producto {producto_id} agregado exitosamente a orden {orden_id}")
                    return JsonResponse({
                        'success': True, 
                        'detalle_id': detalle_id,
                        'subtotal': float(subtotal_item),
                        'iva': float(iva_item),
                        'total': float(precio_total_item),
                        'pago_actualizado': (tiene_un_pago or (tiene_dos_pagos and pagos_ajustados)) and estatus_orden == 'por_cobrar'
                    })
                
                except Exception as e:
                    logger.error(f"Error en transacción: {str(e)}", exc_info=True)
                    cursor.execute('ROLLBACK')
                    return JsonResponse({
                        'error': 'Error al procesar la transacción',
                        'detalle': str(e)
                    }, status=500)
                    
            except Exception as e:
                logger.error(f"Error en operación con base de datos: {str(e)}", exc_info=True)
                return JsonResponse({
                    'error': 'Error en operación con base de datos',
                    'detalle': str(e)
                }, status=500)
                
    except json.JSONDecodeError as e:
        logger.error(f"Error decodificando JSON: {str(e)}")
        return JsonResponse({
            'error': 'Formato JSON inválido',
            'detalle': str(e)
        }, status=400)
    except Exception as e:
        logger.error(f"Error inesperado: {str(e)}", exc_info=True)
        return JsonResponse({
            'error': 'Error interno del servidor',
            'detalle': str(e)
        }, status=500)


@csrf_exempt
@login_required
@grupos_permitidos(['Administradores', 'Meseros', 'Delivery', 'Operadores', 'Rapidos'])
def editar_producto_orden(request, item_id):
    """Vista para editar la cantidad y notas de un producto en una orden"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    data = json.loads(request.body)
    
    # Validar que la cantidad sea un número entero
    cantidad_raw = data.get('cantidad', 0)
    try:
        # Verificar si el valor es un número entero
        if isinstance(cantidad_raw, float) and not cantidad_raw.is_integer():
            return JsonResponse({'error': 'La cantidad debe ser un número entero'}, status=400)
        
        nueva_cantidad = int(cantidad_raw)
    except (ValueError, TypeError):
        return JsonResponse({'error': 'La cantidad debe ser un número entero válido'}, status=400)
    
    # Validar que la cantidad sea mayor a cero
    if nueva_cantidad <= 0:
        return JsonResponse({'error': 'La cantidad debe ser mayor a cero'}, status=400)
    
    nuevas_notas = data.get('notas', '')
    pagos_ajustados = data.get('pagos_ajustados', None)  # Nuevo parámetro
    
    # Obtener los grupos del usuario actual
    grupos_usuario = [grupo.name for grupo in request.user.groups.all()]
        
    with connections['pagoda'].cursor() as cursor:
        try:
            # 1. Obtener el item a editar con todos los datos necesarios
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT od.orden_id, od.subtotal, od.iva, od.total, od.producto_id, 
                        od.cantidad, od.notas,
                        p.nombre, p.stock_actual, p.control_inventario, od.preparado, od.precio_unitario,
                        p.iva_incluido, p.porcentaje_iva
                FROM orden_detalles od
                JOIN productos p ON od.producto_id = p.id
                WHERE od.id = %s
            ''', [item_id])
            item = cursor.fetchone()
                
            if not item:
                return JsonResponse({'error': 'Item no encontrado'}, status=404)
                
            orden_id, subtotal_actual, iva_actual, total_actual, producto_id, cantidad_actual, notas_actuales, nombre, stock_actual, control_inventario, preparado, precio_unitario, iva_incluido, porcentaje_iva = item
            
            # Validar si el producto ya ha sido preparado
            if preparado != 0:
                return JsonResponse({'error': 'No se puede editar el producto porque ya ha sido o está siendo preparado'}, status=400)
                
            # 2. Obtener información completa de la orden incluyendo tipo_servicio_id
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR 
                SELECT estatus, tipo_servicio_id, estatus_preparacion, estatus_entrega, total 
                FROM ordenes 
                WHERE id = %s
            ''', [orden_id])
            orden = cursor.fetchone()
                
            if not orden:
                return JsonResponse({'error': 'Orden no encontrada'}, status=404)
                
            estatus, tipo_servicio_id, estatus_preparacion, estatus_entrega, total_orden = orden
            
            # VALIDACIÓN DE PERMISOS SEGÚN TIPO DE SERVICIO Y GRUPOS
            tiene_permiso = False
            
            if tipo_servicio_id == 1:  # Comedor
                if 'Administradores' in grupos_usuario or 'Meseros' in grupos_usuario:
                    tiene_permiso = True
            elif tipo_servicio_id == 2:  # Para llevar
                if 'Administradores' in grupos_usuario or 'Operadores' in grupos_usuario or 'Rapidos' in grupos_usuario:
                    tiene_permiso = True
            elif tipo_servicio_id == 3:  # Domicilio
                if 'Administradores' in grupos_usuario or 'Operadores' in grupos_usuario or 'Delivery' in grupos_usuario:
                    tiene_permiso = True
            elif tipo_servicio_id == 4:
                    # Domicilio: Solo Delivery, Administradores, Meseros y Operadores
                    if 'Delivery' in grupos_usuario or 'Administradores' in grupos_usuario or 'Operadores' in grupos_usuario or 'Meseros' in grupos_usuario:
                        tiene_permiso = True         
            
            if not tiene_permiso:
                return JsonResponse({
                    'error': 'No tiene permiso para editar este tipo de orden',
                    'tipo_servicio': tipo_servicio_id
                }, status=403)
            
            # 3. Validaciones según tipo_servicio_id
            if tipo_servicio_id == 1 or tipo_servicio_id == 4:
                if estatus != 'abierta' or estatus_preparacion is not None:
                    return JsonResponse({
                        'error': 'No se puede editar el producto. Para servicios tipo 1 y 4, la orden debe estar abierta y sin preparación iniciada.'
                    }, status=400)
            elif tipo_servicio_id == 2:
                if estatus not in ['abierta', 'por_cobrar'] or estatus_preparacion is not None:
                    return JsonResponse({
                        'error': 'No se puede editar el producto. Para servicios tipo 2, la orden debe estar abierta o por cobrar, y sin preparación iniciada.'
                    }, status=400)
            elif tipo_servicio_id == 3:
                if estatus not in ['abierta', 'por_cobrar'] or estatus_preparacion is not None or estatus_entrega != 'abierta':
                    return JsonResponse({
                        'error': 'No se puede editar el producto. Para servicios tipo 3, la orden debe estar abierta o por cobrar, sin preparación iniciada y con entrega abierta.'
                    }, status=400)
            else:
                # Para cualquier otro tipo de servicio, mantener la validación original
                if estatus != 'abierta':
                    return JsonResponse({'error': 'La orden no está abierta'}, status=400)
            
            # Validar stock suficiente si se está aumentando la cantidad
            diferencia_cantidad = nueva_cantidad - cantidad_actual
            
            if control_inventario and diferencia_cantidad > 0 and stock_actual < diferencia_cantidad:
                return JsonResponse({
                    'error': 'stock_insuficiente',
                    'producto': {
                        'nombre': nombre,
                        'stock_actual': stock_actual,
                        'cantidad_solicitada': diferencia_cantidad
                    }
                }, status=400)
            
            # 4. Verificar si hay pagos asociados (antes de iniciar la transacción)
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT p.metodo_pago_id, p.monto, p.id, mp.nombre, mp.requiere_comprobacion, p.referencia
                FROM pagos p
                JOIN metodos_pago mp ON p.metodo_pago_id = mp.id
                WHERE p.orden_id = %s
                AND p.estatus = 'completado'
                ORDER BY p.fecha_pago
            ''', [orden_id])
            
            pagos = cursor.fetchall()
            tiene_un_pago = len(pagos) == 1
            tiene_dos_pagos = len(pagos) == 2
            tiene_tres_o_mas_pagos = len(pagos) >= 3
            
            if tiene_tres_o_mas_pagos:
                return JsonResponse({
                    'error': 'Se detectaron tres o más registros de método de pago. Para poder continuar debe cancelar primero esos pagos.',
                    'message': 'Se detectaron tres o más registros de método de pago. Para poder continuar debe cancelar primero esos pagos.',
                    'pagos_count': len(pagos)
                }, status=400)
                
            # 5. Calcular nuevos valores de subtotal e IVA con la nueva interpretación
            precio_total_item = precio_unitario * decimal.Decimal(str(nueva_cantidad))
            
            # NUEVA LÓGICA:
            # Si iva_incluido = 0: El producto NO CAUSA impuestos (está exento)
            # Si iva_incluido = 1: El producto CAUSA impuestos y el precio YA INCLUYE el IVA
            
            if iva_incluido == 1 and porcentaje_iva > 0:
                # El producto CAUSA impuestos y el precio YA INCLUYE el IVA
                iva_factor = decimal.Decimal(str(porcentaje_iva)) / 100 + 1
                precio_sin_iva = precio_unitario / iva_factor
                nuevo_subtotal = precio_sin_iva * decimal.Decimal(str(nueva_cantidad))
                nuevo_iva = precio_total_item - nuevo_subtotal
            else:
                # El producto NO CAUSA impuestos (está exento)
                nuevo_subtotal = precio_total_item
                nuevo_iva = decimal.Decimal(0)
            
            nuevo_total = precio_total_item
            
            # Si tiene dos pagos y no se recibieron pagos_ajustados, devolver datos para mostrar modal
            if tiene_dos_pagos and not pagos_ajustados and estatus == 'por_cobrar':
                # Calcular el cambio en el total
                diferencia_total = float(nuevo_total) - float(total_actual)
                nuevo_total_orden = float(total_orden) + diferencia_total
                
                # Obtener información detallada de las formas de pago
                metodos_pago = []
                for pago in pagos:
                    metodo_id, monto, pago_id, nombre, requiere_comprobacion, referencia = pago
                    metodos_pago.append({
                        'metodo_id': metodo_id,
                        'nombre': nombre,
                        'monto': float(monto),
                        'pago_id': pago_id,
                        'requiere_comprobacion': requiere_comprobacion,
                        'referencia': referencia or ''
                    })
                
                # Retornar respuesta especial para ajuste de pagos en frontend
                return JsonResponse({
                    'success': False,
                    'requiere_ajuste_pagos': True,
                    'message': 'Se detectaron dos formas de pago. Es necesario ajustar la distribución.',
                    'pagos': metodos_pago,
                    'total_anterior': float(total_orden),
                    'total_nuevo': nuevo_total_orden,
                    'accion': 'editar_producto',
                    'item_id': item_id,
                    'nueva_cantidad': nueva_cantidad,
                    'nuevas_notas': nuevas_notas
                })
                
            # Iniciar transacción
            cursor.execute('START TRANSACTION')
                
            try:
                # 6. Si el producto controla inventario, ajustar el stock
                if control_inventario and diferencia_cantidad != 0:
                    cursor.execute('''
                        UPDATE productos 
                        SET stock_actual = stock_actual - %s 
                        WHERE id = %s
                    ''', [diferencia_cantidad, producto_id])
                    
                # 7. Actualizar el item de la orden (incluyendo notas)
                cursor.execute('''
                    UPDATE orden_detalles 
                    SET cantidad = %s, 
                        subtotal = %s,
                        iva = %s,
                        total = %s,
                        notas = %s,
                        actualizado_en = NOW()
                    WHERE id = %s
                ''', [nueva_cantidad, float(nuevo_subtotal), float(nuevo_iva), float(nuevo_total), nuevas_notas, item_id])
                    
                # 8. Actualizar totales de la orden incluyendo impuestos
                cursor.execute('''
                    UPDATE ordenes 
                    SET subtotal = subtotal - %s + %s,
                        impuestos = impuestos - %s + %s,
                        total = total - %s + %s,
                        actualizado_en = NOW()
                    WHERE id = %s
                ''', [subtotal_actual, float(nuevo_subtotal), iva_actual, float(nuevo_iva), 
                      total_actual, float(nuevo_total), orden_id])
                
                # 9. Manejar los pagos:
                # - Si hay un solo pago: actualizar su monto
                # - Si hay dos pagos y se recibieron pagos_ajustados: cancelar los existentes y crear nuevos
                pago_actualizado = False
                
                if tiene_un_pago and estatus == 'por_cobrar':
                    # Obtener el total actualizado de la orden
                    cursor.execute('''
                        SET STATEMENT max_statement_time = 25 FOR SELECT total FROM ordenes WHERE id = %s
                    ''', [orden_id])
                    nuevo_total_orden = cursor.fetchone()[0]
                    
                    metodo_pago_id, monto_pago, pago_id = pagos[0][0:3]
                    
                    cursor.execute('''
                        UPDATE pagos
                        SET monto = %s,
                            actualizado_en = NOW()
                        WHERE id = %s
                    ''', [float(nuevo_total_orden), pago_id])
                    
                    pago_actualizado = True
                
                # Si hay dos pagos y se recibieron pagos ajustados, actualizar los pagos
                elif tiene_dos_pagos and pagos_ajustados and estatus == 'por_cobrar':
                    empleado_id = request.session.get('empleado_id')
                    
                    # Verificar que la suma de los pagos ajustados coincide con el nuevo total
                    cursor.execute('''
                        SET STATEMENT max_statement_time = 25 FOR SELECT total FROM ordenes WHERE id = %s
                    ''', [orden_id])
                    nuevo_total_orden = float(cursor.fetchone()[0])
                    
                    # Sumar los montos de los pagos ajustados
                    total_pagos_ajustados = sum(float(pago.get('monto', 0)) for pago in pagos_ajustados)
                    
                    # Validar que la suma coincida (con un margen de error de 0.01)
                    if abs(total_pagos_ajustados - nuevo_total_orden) > 0.01:
                        cursor.execute('ROLLBACK')
                        return JsonResponse({
                            'success': False,
                            'error': 'montos_incorrectos',
                            'message': 'La suma de los montos ajustados no coincide con el total de la orden'
                        }, status=400)
                    
                    # Cancelar pagos existentes
                    cursor.execute('''
                        UPDATE pagos 
                        SET estatus = 'cancelado', 
                            fecha_cancelacion = NOW()
                        WHERE orden_id = %s 
                        AND estatus = 'completado'
                    ''', [orden_id])
                    
                    # Crear nuevos pagos con los montos ajustados
                    for pago in pagos_ajustados:
                        cursor.execute('''
                            INSERT INTO pagos (
                                orden_id, metodo_pago_id, empleado_id,
                                monto, referencia, estatus, fecha_pago
                            ) VALUES (%s, %s, %s, %s, %s, %s, NOW())
                        ''', [
                            orden_id, pago.get('metodo_id'), empleado_id,
                            pago.get('monto'), pago.get('referencia', ''), 'completado'
                        ])
                    
                    pago_actualizado = True
                    
                # Confirmar transacción
                cursor.execute('COMMIT')
                    
                return JsonResponse({
                    'success': True,
                    'message': 'Producto actualizado',
                    'producto': {
                        'id': producto_id,
                        'nombre': nombre,
                        'cantidad_anterior': cantidad_actual,
                        'cantidad_nueva': nueva_cantidad,
                        'notas_anterior': notas_actuales,
                        'notas_nueva': nuevas_notas,
                        'nuevo_stock': stock_actual - diferencia_cantidad if control_inventario else None,
                        'subtotal': float(nuevo_subtotal),
                        'iva': float(nuevo_iva),
                        'total': float(nuevo_total)
                    },
                    'pago_actualizado': pago_actualizado
                })
                
            except Exception as e:
                cursor.execute('ROLLBACK')
                return JsonResponse({'error': f'Error en transacción: {str(e)}'}, status=500)
                
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)

@csrf_exempt
@login_required
@grupos_permitidos(['Administradores', 'Meseros', 'Delivery', 'Operadores', 'Rapidos'])
def eliminar_producto_orden(request, item_id):
    """Vista para eliminar un producto de una orden y devolverlo al inventario"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
        
    # Obtener pagos_ajustados del cuerpo de la solicitud, si existe
    pagos_ajustados = None
    try:
        if request.body:
            data = json.loads(request.body)
            pagos_ajustados = data.get('pagos_ajustados', None)
    except:
        # Si hay error al leer JSON, continuamos sin pagos_ajustados
        pass
        
    with connections['pagoda'].cursor() as cursor:
        try:
            # 1. Obtener el item a eliminar con todos los datos necesarios
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT od.orden_id, od.subtotal, od.iva, od.total, od.producto_id, 
                        od.cantidad, p.nombre, p.stock_actual, p.control_inventario, od.preparado
                FROM orden_detalles od
                JOIN productos p ON od.producto_id = p.id
                WHERE od.id = %s
            ''', [item_id])
            item = cursor.fetchone()
                
            if not item:
                return JsonResponse({'error': 'Item no encontrado'}, status=404)
                
            orden_id, subtotal, iva, total, producto_id, cantidad, nombre, stock_actual, control_inventario, preparado = item
            
            # Validar si el producto ya ha sido preparado
            if preparado != 0:
                return JsonResponse({'error': 'No se puede eliminar el producto porque ya ha sido o está siendo preparado'}, status=400)
                
            # 2. Obtener información completa de la orden incluyendo tipo_servicio_id
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR 
                SELECT estatus, tipo_servicio_id, estatus_preparacion, estatus_entrega, total 
                FROM ordenes 
                WHERE id = %s
            ''', [orden_id])
            orden = cursor.fetchone()
                
            if not orden:
                return JsonResponse({'error': 'Orden no encontrada'}, status=404)
                
            estatus, tipo_servicio_id, estatus_preparacion, estatus_entrega, total_orden = orden
            
            # 3. Validaciones según tipo_servicio_id
            if tipo_servicio_id == 1 or tipo_servicio_id == 4 :
                if estatus != 'abierta' or estatus_preparacion is not None:
                    return JsonResponse({
                        'error': 'No se puede eliminar el producto. Para servicios tipo 1, la orden debe estar abierta y sin preparación iniciada.'
                    }, status=400)
            elif tipo_servicio_id == 2:
                if estatus not in ['abierta', 'por_cobrar'] or estatus_preparacion is not None:
                    return JsonResponse({
                        'error': 'No se puede eliminar el producto. Para servicios tipo 2, la orden debe estar abierta o por cobrar, y sin preparación iniciada.'
                    }, status=400)
            elif tipo_servicio_id == 3:
                if estatus not in ['abierta', 'por_cobrar'] or estatus_preparacion is not None or estatus_entrega != 'abierta':
                    return JsonResponse({
                        'error': 'No se puede eliminar el producto. Para servicios tipo 3, la orden debe estar abierta o por cobrar, sin preparación iniciada y con entrega abierta.'
                    }, status=400)
            else:
                # Para cualquier otro tipo de servicio, mantener la validación original
                if estatus != 'abierta':
                    return JsonResponse({'error': 'La orden no está abierta'}, status=400)
            
            # 4. NUEVO: Verificar si hay pagos asociados
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT p.metodo_pago_id, p.monto, p.id, mp.nombre, mp.requiere_comprobacion, p.referencia
                FROM pagos p
                JOIN metodos_pago mp ON p.metodo_pago_id = mp.id
                WHERE p.orden_id = %s
                AND p.estatus = 'completado'
                ORDER BY p.fecha_pago
            ''', [orden_id])
            
            pagos = cursor.fetchall()
            tiene_un_pago = len(pagos) == 1
            tiene_dos_pagos = len(pagos) == 2
            tiene_tres_o_mas_pagos = len(pagos) >= 3
            
            # Calcular el nuevo total de la orden después de eliminar el producto
            nuevo_total_orden = decimal.Decimal(str(total_orden)) - decimal.Decimal(str(total))
            
            if tiene_tres_o_mas_pagos:
                return JsonResponse({
                    'error': 'Se detectaron tres o más registros de método de pago. Para poder continuar debe cancelar primero esos pagos.',
                    'message': 'Se detectaron tres o más registros de método de pago. Para poder continuar debe cancelar primero esos pagos.',
                    'pagos_count': len(pagos)
                }, status=400)
            
            # Si tiene dos pagos y no se recibieron pagos_ajustados, devolver datos para mostrar modal
            if tiene_dos_pagos and not pagos_ajustados and estatus == 'por_cobrar':
                # Obtener información detallada de las formas de pago
                metodos_pago = []
                for pago in pagos:
                    metodo_id, monto, pago_id, nombre, requiere_comprobacion, referencia = pago
                    metodos_pago.append({
                        'metodo_id': metodo_id,
                        'nombre': nombre,
                        'monto': float(monto),
                        'pago_id': pago_id,
                        'requiere_comprobacion': requiere_comprobacion,
                        'referencia': referencia or ''
                    })
                
                # Retornar respuesta especial para ajuste de pagos en frontend
                return JsonResponse({
                    'success': False,
                    'requiere_ajuste_pagos': True,
                    'message': 'Se detectaron dos formas de pago. Es necesario ajustar la distribución.',
                    'pagos': metodos_pago,
                    'total_anterior': float(total_orden),
                    'total_nuevo': float(nuevo_total_orden),
                    'accion': 'eliminar_producto',
                    'item_id': item_id
                })
            
            # Iniciar transacción
            cursor.execute('START TRANSACTION')
                
            try:
                # 5. Si el producto controla inventario, devolver el stock
                if control_inventario:
                    cursor.execute('''
                        UPDATE productos 
                        SET stock_actual = stock_actual + %s 
                        WHERE id = %s
                    ''', [cantidad, producto_id])

                # NUEVO: Verificar que no se elimine el único producto restante
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR  SELECT COUNT(*) FROM orden_detalles WHERE orden_id = %s
                ''', [orden_id])
                cantidad_items = cursor.fetchone()[0]

                if cantidad_items <= 1:
                    cursor.execute('ROLLBACK')
                    return JsonResponse({
                        'error': 'No se puede eliminar el único producto restante de la orden. La orden no puede quedar vacía. Si desea eliminar este producto, cancele la orden',
                        'message': 'La orden no puede quedar vacía. Si desea eliminar este producto, cancele la orden.'
                    }, status=400)
                    
                # 6. Eliminar el item de la orden
                cursor.execute('DELETE FROM orden_detalles WHERE id = %s', [item_id])
                    
                # 7. Actualizar totales de la orden incluyendo impuestos
                cursor.execute('''
                    UPDATE ordenes 
                    SET subtotal = subtotal - %s,
                        impuestos = impuestos - %s,
                        total = total - %s,
                        actualizado_en = NOW()
                    WHERE id = %s
                ''', [subtotal, iva, total, orden_id])
                
                # 8. Manejar los pagos:
                # - Si hay un solo pago: actualizar su monto
                # - Si hay dos pagos y se recibieron pagos_ajustados: cancelar los existentes y crear nuevos
                pago_actualizado = False
                
                if tiene_un_pago and estatus == 'por_cobrar':
                    metodo_pago_id, monto_pago, pago_id = pagos[0][0:3]
                    
                    cursor.execute('''
                        UPDATE pagos
                        SET monto = %s,
                            actualizado_en = NOW()
                        WHERE id = %s
                    ''', [float(nuevo_total_orden), pago_id])
                    
                    pago_actualizado = True
                
                # Si hay dos pagos y se recibieron pagos ajustados, actualizar los pagos
                elif tiene_dos_pagos and pagos_ajustados and estatus == 'por_cobrar':
                    empleado_id = request.session.get('empleado_id')
                    
                    # Verificar que la suma de los pagos ajustados coincide con el nuevo total
                    # Sumar los montos de los pagos ajustados
                    total_pagos_ajustados = sum(float(pago.get('monto', 0)) for pago in pagos_ajustados)
                    
                    # Validar que la suma coincida (con un margen de error de 0.01)
                    if abs(total_pagos_ajustados - float(nuevo_total_orden)) > 0.01:
                        cursor.execute('ROLLBACK')
                        return JsonResponse({
                            'success': False,
                            'error': 'montos_incorrectos',
                            'message': 'La suma de los montos ajustados no coincide con el total de la orden'
                        }, status=400)
                    
                    # Cancelar pagos existentes
                    cursor.execute('''
                        UPDATE pagos 
                        SET estatus = 'cancelado', 
                            fecha_cancelacion = NOW()
                        WHERE orden_id = %s 
                        AND estatus = 'completado'
                    ''', [orden_id])
                    
                    # Crear nuevos pagos con los montos ajustados
                    for pago in pagos_ajustados:
                        cursor.execute('''
                            INSERT INTO pagos (
                                orden_id, metodo_pago_id, empleado_id,
                                monto, referencia, estatus, fecha_pago
                            ) VALUES (%s, %s, %s, %s, %s, %s, NOW())
                        ''', [
                            orden_id, pago.get('metodo_id'), empleado_id,
                            pago.get('monto'), pago.get('referencia', ''), 'completado'
                        ])
                    
                    pago_actualizado = True
                    
                # Confirmar transacción
                cursor.execute('COMMIT')
                    
                return JsonResponse({
                    'success': True,
                    'message': 'Producto eliminado y stock restaurado',
                    'producto': {
                        'id': producto_id,
                        'nombre': nombre,
                        'cantidad_devuelta': cantidad,
                        'nuevo_stock': stock_actual + cantidad if control_inventario else None
                    },
                    'orden': {
                        'subtotal': float(decimal.Decimal(str(total_orden)) - decimal.Decimal(str(total))),
                        'total': float(nuevo_total_orden)
                    },
                    'pago_actualizado': pago_actualizado
                })
                
            except Exception as e:
                cursor.execute('ROLLBACK')
                return JsonResponse({'error': f'Error en transacción: {str(e)}'}, status=500)
                
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)

@csrf_exempt
@login_required
def eliminar_cliente(request, cliente_id):
    """Elimina un cliente con SQL directo"""
    if request.method == 'POST':
        try:
            with connections['pagoda'].cursor() as cursor:
                cursor.execute("DELETE FROM clientes WHERE id = %s", [cliente_id])
                messages.success(request, "Cliente eliminado correctamente")
        except Exception as e:
            messages.error(request, f"Error al eliminar: {str(e)}")
    
    return redirect('lista_clientes')

@csrf_exempt
@login_required
def eliminar_direccion(request, direccion_id):
    """Vista para eliminar una dirección de cliente"""
    with connections['pagoda'].cursor() as cursor:
        # Obtener cliente_id para redirección
        cursor.execute('SET STATEMENT max_statement_time = 25 FOR SELECT cliente_id FROM direcciones_cliente WHERE id = %s', [direccion_id])
        result = cursor.fetchone()
        if not result:
            messages.error(request, 'Dirección no encontrada')
            return redirect('lista_clientes')
        
        cliente_id = result[0]
        
        # Verificar si la dirección está siendo usada en alguna orden activa
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT COUNT(*) FROM ordenes 
            WHERE direccion_entrega_id = %s 
            AND estatus NOT IN ('cerrada', 'cancelada')
        ''', [direccion_id])
        
        if cursor.fetchone()[0] > 0:
            messages.error(request, 'No se puede eliminar la dirección porque está siendo usada en órdenes activas')
            return redirect('detalle_cliente', cliente_id=cliente_id)
        
        # Eliminar dirección
        cursor.execute('DELETE FROM direcciones_cliente WHERE id = %s', [direccion_id])
        messages.success(request, 'Dirección eliminada correctamente')
        
        return redirect('detalle_cliente', cliente_id=cliente_id)

@csrf_exempt
@login_required
def direcciones_cliente(request, cliente_id):
    """Vista para obtener direcciones de un cliente (AJAX)"""
    with connections['pagoda'].cursor() as cursor:
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT id, nombre_etiqueta, 
                   CONCAT('Calle. ', calle, ' # ', numero_exterior, 
                          IF(numero_interior IS NULL OR numero_interior = '', 
                             '', CONCAT(' Int. ', numero_interior)), 
                          ', Col. ', colonia, ', ',
                          IF(codigo_postal IS NULL OR codigo_postal = '', 
                             '', CONCAT(' C.P. ', codigo_postal)),
                          IF(referencias IS NULL OR referencias = '', 
                             '', CONCAT(', Ref: ', referencias))) as direccion_completa,
                   latitud, longitud, predeterminada, costo_entrega
            FROM direcciones_cliente
            WHERE cliente_id = %s
            ORDER BY predeterminada DESC, nombre_etiqueta
        ''', [cliente_id])
        
        direcciones = dictfetchall(cursor)
    
    return JsonResponse(direcciones, safe=False, json_dumps_params={'default': decimal_default})



@login_required
def api_orden_datos(request, orden_id):
    """API que retorna los datos de la orden para el ticket"""
    from decimal import Decimal  # Importamos aquí para el uso en decimal_default
    
    with connections['pagoda'].cursor() as cursor:
        # Datos de la empresa
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT nombre, telefono, direccion, observaciones 
            FROM empresa 
            WHERE sys_pk = 1
        ''')
        empresa = dictfetchone(cursor)
        
        if not empresa:
            empresa = {
                'nombre': 'Cloud Restaurant',
                'telefono': '',
                'direccion': '',
                'observaciones': ''
            }
        
        # Datos de la orden
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT o.*,
                ts.nombre as tipo_servicio,
                m.numero as mesa_numero,
                CONCAT(c.nombre, ' ', IFNULL(c.apellidos, '')) as cliente,
                CONCAT(e.nombre, ' ', e.apellidos) as empleado,
                IF(o.programado = 1, o.fecha_programado, NULL) as fecha_programada,
                CASE
                    WHEN o.tipo_servicio_id = 3 THEN
                        (SELECT CONCAT(calle, ' ', numero_exterior, ', ', colonia)
                         FROM direcciones_cliente
                         WHERE id = o.direccion_entrega_id)
                    ELSE NULL
                END as direccion_entrega
            FROM ordenes o
            LEFT JOIN tipos_servicio ts ON o.tipo_servicio_id = ts.id
            LEFT JOIN mesas m ON o.mesa_id = m.id
            LEFT JOIN clientes c ON o.cliente_id = c.id
            JOIN empleados e ON o.empleado_id = e.id
            WHERE o.id = %s
        ''', [orden_id])
        
        orden = dictfetchone(cursor)
        
        if not orden:
            return JsonResponse({'error': 'Orden no encontrada'}, status=404)
        
        # Obtener items de la orden
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT od.*, p.nombre as producto
            FROM orden_detalles od
            JOIN productos p ON od.producto_id = p.id
            WHERE od.orden_id = %s
            ORDER BY od.id
        ''', [orden_id])
        
        items = dictfetchall(cursor)
        
        # Para cada item, obtener sus modificadores
        for item in items:
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT opm.*, om.nombre
                FROM orden_producto_modificadores opm
                JOIN opciones_modificador om ON opm.opcion_modificador_id = om.id
                WHERE opm.orden_detalle_id = %s
            ''', [item['id']])
            item['modificadores'] = dictfetchall(cursor)
        
        # Obtener pagos de la orden
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT p.*, mp.nombre as metodo_pago
            FROM pagos p
            JOIN metodos_pago mp ON p.metodo_pago_id = mp.id
            WHERE p.orden_id = %s
            And p.estatus = 'completado'
            ORDER BY p.fecha_pago
        ''', [orden_id])
        
        pagos = dictfetchall(cursor)
    
    # Construir respuesta JSON
    data = {
        'orden': orden,
        'items': items,
        'pagos': pagos,
        'empresa': empresa
    }
    
    return JsonResponse(data, safe=False, json_dumps_params={'default': decimal_default})

def ticket_cocina_direct_view(request, orden_id):
    """Vista que muestra un ticket de cocina optimizado para impresión directa"""
    context = {
        'orden_id': orden_id,
        'tipo_ticket': 'cocina',
    }
    return render(request, 'pos/ticket_imprimir.html', context)

@csrf_exempt
@login_required
def verificar_imprimir_comanda(request, orden_id):
    """Verificar estados y cambiarlos si es necesario antes de imprimir comanda"""
    try:
        with connections['pagoda'].cursor() as cursor:
            # Verificar estado actual de la orden y mesa
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT o.estatus, m.estatus as mesa_estatus, m.id as mesa_id
                FROM ordenes o
                LEFT JOIN mesas m ON o.mesa_id = m.id
                WHERE o.id = %s
            ''', [orden_id])
            
            resultado = dictfetchone(cursor)
            
            if not resultado:
                return JsonResponse({'error': 'Orden no encontrada'}, status=404)
            
            estatus_orden = resultado['estatus']
            estatus_mesa = resultado.get('mesa_estatus')
            mesa_id = resultado.get('mesa_id')
            
            # Si ya está en por_cobrar y por_liberar, solo imprimir
            if estatus_orden == 'por_cobrar' and (not mesa_id or estatus_mesa == 'por_liberar'):
                return JsonResponse({'success': True, 'imprimir': True, 'mensaje': 'Imprimiendo comanda'})
            
            # Verificar que esté abierta y la mesa ocupada
            if estatus_orden != 'abierta':
                return JsonResponse({
                    'error': f'La orden no está en estado abierta (estado: {estatus_orden})',
                    'imprimir': False
                }, status=400)
            
            if mesa_id and estatus_mesa != 'ocupada':
                return JsonResponse({
                    'error': f'La mesa no está en estado ocupada (estado: {estatus_mesa})',
                    'imprimir': False
                }, status=400)
            
            empleado_id = request.session['pos_empleado_id']
            
            # Todo está bien, iniciar transacción para cambiar estados
            cursor.execute('START TRANSACTION')
            
            try:
                # Cambiar estado de la orden
                cursor.execute('''
                    UPDATE ordenes SET estatus = 'por_cobrar'
                    WHERE id = %s
                ''', [orden_id])
                
                # Cambiar estado de la mesa si existe
                if mesa_id:
                    cursor.execute('''
                        UPDATE mesas SET estatus = 'por_liberar'
                        WHERE id = %s
                    ''', [mesa_id])
                
                # Registrar en historial de estados
                cursor.execute('''
                    INSERT INTO orden_historial_estados (
                        orden_id, estado_anterior, estado_nuevo, empleado_id, motivo
                    ) VALUES (%s, %s, 'por_cobrar', %s, 'Impresión de comanda')
                ''', [orden_id, estatus_orden, empleado_id])
                
                # Confirmar cambios
                cursor.execute('COMMIT')
                
                return JsonResponse({
                    'success': True, 
                    'imprimir': True,
                    'mensaje': 'Estado actualizado e imprimiendo comanda'
                })
                
            except Exception as e:
                cursor.execute('ROLLBACK')
                return JsonResponse({
                    'error': f'Error en transacción: {str(e)}',
                    'imprimir': False
                }, status=500)
            
    except Exception as e:
        return JsonResponse({
            'error': f'Error general: {str(e)}',
            'imprimir': False
        }, status=500)



@csrf_exempt
@login_required
def verificar_ticket_cobro(request, orden_id):
    """Verificar que la orden esté en estado correcto para imprimir ticket de cobro"""
    try:
        data = json.loads(request.body)
        es_reimpresion = data.get('es_reimpresion', False)
        
        with connections['pagoda'].cursor() as cursor:
            # Verificar estado actual de la orden
            cursor.execute('SET STATEMENT max_statement_time = 25 FOR SELECT estatus FROM ordenes WHERE id = %s', [orden_id])
            resultado = dictfetchone(cursor)
            
            if not resultado:
                return JsonResponse({'error': 'Orden no encontrada', 'imprimir': False}, status=404)
            
            estatus_orden = resultado['estatus']
            
            # Si es reimpresión, permitir en cualquier estado cerrado
            if es_reimpresion:
                if estatus_orden == 'cerrada':
                    return JsonResponse({
                        'success': True, 
                        'imprimir': True, 
                        'mensaje': 'Reimprimiendo ticket de cobro'
                    })
                else:
                    return JsonResponse({
                        'error': f'No se puede reimprimir ticket de una orden no cerrada (estado: {estatus_orden})',
                        'imprimir': False
                    }, status=400)
            
            # Si no es reimpresión, verificar si está en estado correcto
            if estatus_orden not in ['por_cobrar', 'cerrada']:
                return JsonResponse({
                    'error': f'La orden no está en estado adecuado para cobro (estado: {estatus_orden})',
                    'imprimir': False
                }, status=400)
            
            return JsonResponse({
                'success': True,
                'imprimir': True,
                'mensaje': 'Imprimiendo ticket de cobro'
            })
            
    except Exception as e:
        return JsonResponse({
            'error': f'Error general: {str(e)}',
            'imprimir': False
        }, status=500)


@login_required
def ticket_cliente_view(request, orden_id):
    """Vista para mostrar e imprimir el ticket de cliente con validaciones de seguridad"""
    
    # Obtener parámetros
    es_reimpresion = request.GET.get('reimpresion', 'false').lower() == 'true'
    tipo_ticket = request.GET.get('tipo', 'cuenta')  # 'cuenta' o 'cobro'
    print(tipo_ticket)
    # Verificar acceso y validar estados
    with connections['pagoda'].cursor() as cursor:
        cursor.execute('SET STATEMENT max_statement_time = 25 FOR SELECT estatus FROM ordenes WHERE id = %s', [orden_id])
        orden_status = dictfetchone(cursor)
        
        if not orden_status:
            return HttpResponse('Orden no encontrada', status=404)
        
        estatus_orden = orden_status['estatus']
        print(estatus_orden)
        # Verificar permisos según tipo de ticket
        if tipo_ticket == 'cuenta' and estatus_orden not in ['por_cobrar']:
            return HttpResponse('No autorizado: Estado incorrecto para ticket de cuenta', status=403)
            
        if tipo_ticket == 'cobro' and estatus_orden != 'cerrada' and not es_reimpresion:
            return HttpResponse('No autorizado: La orden no está cerrada', status=403)
    
    # A partir de aquí continuar con el código original de la vista
    # Datos de la empresa
    with connections['pagoda'].cursor() as cursor:
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT nombre, telefono, direccion, observaciones 
            FROM empresa 
            WHERE sys_pk = 1
        ''')
        empresa = dictfetchone(cursor)
        
        if not empresa:
            empresa = {
                'nombre': 'Prompt Restaurant',
                'telefono': '',
                'direccion': '',
                'observaciones': ''
            }
        
        # Datos de la orden
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT o.*,
                ts.nombre as tipo_servicio,
                m.numero as mesa_numero,
                CONCAT(c.nombre, ' ', IFNULL(c.apellidos, '')) as cliente,
                CONCAT(e.nombre, ' ', e.apellidos) as empleado,
                IF(o.programado = 1, o.fecha_programado, NULL) as fecha_programada,
                CASE
                    WHEN o.tipo_servicio_id = 3 THEN
                        (SELECT CONCAT(calle, ' ', numero_exterior, ', ', colonia)
                         FROM direcciones_cliente
                         WHERE id = o.direccion_entrega_id)
                    ELSE NULL
                END as direccion_entrega
            FROM ordenes o
            LEFT JOIN tipos_servicio ts ON o.tipo_servicio_id = ts.id
            LEFT JOIN mesas m ON o.mesa_id = m.id
            LEFT JOIN clientes c ON o.cliente_id = c.id
            JOIN empleados e ON o.empleado_id = e.id
            WHERE o.id = %s
        ''', [orden_id])
        
        orden = dictfetchone(cursor)
        
        if not orden:
            return HttpResponse('Orden no encontrada', status=404)
        
        # Obtener items de la orden
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT od.*, p.nombre as producto
            FROM orden_detalles od
            JOIN productos p ON od.producto_id = p.id
            WHERE od.orden_id = %s
            ORDER BY od.id
        ''', [orden_id])
        
        items = dictfetchall(cursor)
        
        # Para cada item, obtener sus modificadores
        for item in items:
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT opm.*, om.nombre
                FROM orden_producto_modificadores opm
                JOIN opciones_modificador om ON opm.opcion_modificador_id = om.id
                WHERE opm.orden_detalle_id = %s
            ''', [item['id']])
            item['modificadores'] = dictfetchall(cursor)
        
        # Obtener pagos de la orden
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT p.*, mp.nombre as metodo_pago
            FROM pagos p
            JOIN metodos_pago mp ON p.metodo_pago_id = mp.id
            WHERE p.orden_id = %s
            and p.estatus = 'completado'
            ORDER BY p.fecha_pago
        ''', [orden_id])
        
        pagos = dictfetchall(cursor)
    
    # Construir contexto para el template
    context = {
        'orden': orden,
        'items': items,
        'pagos': pagos,
        'empresa': empresa,
        'es_reimpresion': es_reimpresion,
        'fecha_actual': datetime.now(),
        'tipo_ticket': tipo_ticket  # Agregar el tipo de ticket al contexto
    }
    
    return render(request, 'pos/ticket_imprimir.html', context)

from datetime import datetime

@login_required
@grupos_permitidos(['Administradores'])
def obtener_configuracion_orden(request):
    """Obtiene la configuración actual del orden de presentación"""
    try:
        with connections['pagoda'].cursor() as cursor:
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT config_tipo_servicio 
                FROM configuracion_orden_cocina 
                WHERE activo = 1 
                ORDER BY id DESC 
                LIMIT 1
            ''')
            result = cursor.fetchone()
            
            if result:
                # Parse JSON string to dict
                import json
                config = json.loads(result[0])
                return JsonResponse(config)
            else:
                # Valores por defecto
                return JsonResponse({
                    'para_llevar': 3,
                    'domicilio': 2,
                    'comedor': 1
                })
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
@grupos_permitidos(['Administradores'])
def guardar_configuracion_orden(request):
    """Guarda la nueva configuración del orden de presentación"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        import json
        data = json.loads(request.body)
        
        # Validar datos
        if not all(key in data for key in ['para_llevar', 'domicilio', 'comedor']):
            return JsonResponse({'error': 'Faltan parámetros requeridos'}, status=400)
        
        config_json = json.dumps({
            'para_llevar': int(data['para_llevar']),
            'domicilio': int(data['domicilio']),
            'comedor': int(data['comedor'])
        })
        
        with connections['pagoda'].cursor() as cursor:
            # Desactivar configuraciones anteriores
            cursor.execute('UPDATE configuracion_orden_cocina SET activo = 0')
            
            # Insertar nueva configuración
            cursor.execute('''
                INSERT INTO configuracion_orden_cocina (nombre_config, config_tipo_servicio, activo)
                VALUES (%s, %s, 1)
            ''', ['custom', config_json])
            
        return JsonResponse({'success': True})
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)



@login_required
@grupos_permitidos(['Administradores','Cocineros'])
def vista_cocina(request):
    """Vista principal para la cocina, muestra órdenes pendientes para que los cocineros las tomen"""
    print("Iniciando vista_cocina")
    try:
        with connections['pagoda'].cursor() as cursor:
            print("Conexión a base de datos establecida")
            try:
                # Obtener configuración del orden
                print("Obteniendo configuración del orden")
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT config_tipo_servicio 
                    FROM configuracion_orden_cocina 
                    WHERE activo = 1 
                    ORDER BY id DESC 
                    LIMIT 1
                ''')
                config_result = cursor.fetchone()
                
                if config_result:
                    import json
                    config_orden = json.loads(config_result[0])
                    print(f"Configuración encontrada: {config_orden}")
                else:
                    # Valores por defecto si no hay configuración
                    config_orden = {
                        'para_llevar': 3,
                        'domicilio': 2,
                        'comedor': 1
                    }
                    print("Usando configuración por defecto: 3-2-1")
                
                # Obtener todas las órdenes pendientes
                print("Ejecutando consulta de órdenes pendientes")
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT o.id, o.codigo_orden, o.fecha_apertura, o.estatus, o.estatus_preparacion,
                           o.jerarquia, o.grupo_ruteo, o.cocinero_id, o.tipo_servicio_id,
                           o.bloque_ruta_id, o.posicion_en_bloque, o.prioridad_manual,
                           o.programado, o.fecha_programado,
                           ts.nombre as tipo_servicio, m.numero as mesa_numero,
                           CONCAT(c.nombre, ' ', IFNULL(c.apellidos, '')) as cliente,
                           CONCAT(e.nombre, ' ', e.apellidos) as mesero,
                           CASE
                               WHEN o.tipo_servicio_id = 3 THEN
                                   (SELECT CONCAT(calle, ' ', numero_exterior, ', ', colonia)
                                    FROM direcciones_cliente
                                    WHERE id = o.direccion_entrega_id)
                               ELSE NULL
                           END as direccion_entrega,
                           (SELECT COUNT(*) FROM orden_detalles WHERE orden_id = o.id) as num_items,
                           CONCAT(
                               FLOOR(TIMESTAMPDIFF(MINUTE, o.fecha_apertura, NOW()) / 60), 
                               ':', 
                               LPAD(TIMESTAMPDIFF(MINUTE, o.fecha_apertura, NOW()) % 60, 2, '0')
                           ) as tiempo_espera,
                           TIMESTAMPDIFF(MINUTE, o.fecha_apertura, NOW()) as minutos_espera,
                           CONCAT(coc.nombre, ' ', coc.apellidos) as cocinero,
                           br.nombre as bloque_ruta_nombre,
                           br.color as bloque_ruta_color,
                           br.prioritario as bloque_prioritario
                    FROM ordenes o
                    LEFT JOIN tipos_servicio ts ON o.tipo_servicio_id = ts.id
                    LEFT JOIN mesas m ON o.mesa_id = m.id
                    LEFT JOIN clientes c ON o.cliente_id = c.id
                    LEFT JOIN empleados e ON o.empleado_id = e.id
                    LEFT JOIN empleados coc ON o.cocinero_id = coc.id
                    LEFT JOIN bloques_ruta br ON o.bloque_ruta_id = br.id
                    WHERE EXISTS (
                        SELECT 1 FROM orden_detalles od INNER JOIN productos p ON p.id = od.producto_id
                        WHERE od.orden_id = o.id AND (od.preparado = 0 OR od.preparado = 1) 
                        AND (p.vista_cocina IS NULL OR p.vista_cocina = 1 OR p.vista_cocina = "")
                    )
                    AND (
                        o.programado = 0 
                        OR (o.programado = 1 AND TIMESTAMPDIFF(MINUTE, NOW(), o.fecha_programado) <= 50)
                    )
                    AND NOT (o.tipo_servicio_id = 4 AND o.mesa_id IS NULL)
                    ORDER BY o.fecha_apertura ASC
                ''')
                print("Consulta ejecutada correctamente")
                
                # Obteniendo resultados
                print("Obteniendo resultados de la consulta")
                todas_las_ordenes = dictfetchall(cursor)
                print(f"Obtenidas {len(todas_las_ordenes)} órdenes")
                
                # Implementar la lógica de ordenamiento en Python
                print("Aplicando lógica de ordenamiento personalizada")
                
                # 1. Separar órdenes por estado y tipo
                ordenes_en_preparacion = []
                ordenes_prioridad_manual = []
                ordenes_programadas = []
                ordenes_para_llevar = []  # tipo_servicio_id = 2
                ordenes_domicilio = []    # tipo_servicio_id = 3
                ordenes_comedor = []      # tipo_servicio_id = 1
                
                # Get current time
                ahora = datetime.now()
                
                # First, categorize all orders
                for orden in todas_las_ordenes:
                    # Check if order is already in preparation
                    if orden.get('estatus_preparacion') == 'en_preparacion':
                        ordenes_en_preparacion.append(orden)
                        continue
                    
                    # Check if order has manual priority
                    if orden.get('prioridad_manual'):
                        ordenes_prioridad_manual.append(orden)
                        continue
                    
                    # Check if order is scheduled and within 50 minutes OR past scheduled time
                    if orden.get('programado') and orden.get('fecha_programado'):
                        fecha_programado = orden.get('fecha_programado')
                        
                        # Calculate minutes until scheduled time
                        minutos_hasta_programado = None
                        try:
                            if isinstance(fecha_programado, str):
                                # Parse date string if needed
                                fecha_programado = datetime.strptime(fecha_programado, '%Y-%m-%d %H:%M:%S')
                            
                            minutos_hasta_programado = (fecha_programado - ahora).total_seconds() / 60
                        except (ValueError, TypeError) as e:
                            print(f"Error al procesar fecha programada: {e}")
                            minutos_hasta_programado = None
                        
                        # Incluir pedidos donde ya pasó la hora (minutos_hasta_programado < 0)
                        if minutos_hasta_programado is not None and minutos_hasta_programado <= 50:
                            # Guardar los minutos para ordenarlos después
                            orden['minutos_hasta_programado'] = minutos_hasta_programado
                            ordenes_programadas.append(orden)
                            continue
                    
                    # Categorize by service type
                    tipo_servicio_id = orden.get('tipo_servicio_id')
                    if tipo_servicio_id == 2:  # Para llevar
                        ordenes_para_llevar.append(orden)
                    elif tipo_servicio_id == 3:  # Domicilio
                        ordenes_domicilio.append(orden)
                    elif tipo_servicio_id == 1:  # Comedor
                        ordenes_comedor.append(orden)
                
                # Helper functions for sorting
                def get_posicion_en_bloque(orden):
                    try:
                        return int(orden.get('posicion_en_bloque', 99999))
                    except (ValueError, TypeError):
                        return 99999
                
                def get_fecha_apertura(orden):
                    return orden.get('fecha_apertura')
                
                # Ordenar pedidos programados de forma que los más atrasados van primero
                ordenes_programadas.sort(key=lambda o: o.get('minutos_hasta_programado', 0))
                
                # Agrupar pedidos a domicilio por bloque_ruta_id
                bloques_domicilio = {}
                
                for orden in ordenes_domicilio:
                    bloque_id = orden.get('bloque_ruta_id')
                    # Si no tiene bloque, usar un valor especial
                    if not bloque_id:
                        bloque_id = 'sin_bloque'
                    
                    # Inicializar la lista si no existe
                    if bloque_id not in bloques_domicilio:
                        bloques_domicilio[bloque_id] = []
                    
                    # Agregar la orden al grupo de su bloque
                    bloques_domicilio[bloque_id].append(orden)
                
                # Ordenar cada grupo de bloque por fecha_apertura
                for bloque_id, ordenes in bloques_domicilio.items():
                    ordenes.sort(key=lambda o: get_fecha_apertura(o))
                
                # Ordenar los bloques: primero los prioritarios, luego los demás
                bloques_prioritarios = []
                bloques_normales = []
                
                for bloque_id, ordenes in bloques_domicilio.items():
                    # Revisar si el bloque es prioritario (tomamos el primer orden como referencia)
                    es_prioritario = ordenes[0].get('bloque_prioritario') == 1 if ordenes else False
                    
                    if es_prioritario:
                        bloques_prioritarios.append((bloque_id, ordenes))
                    else:
                        bloques_normales.append((bloque_id, ordenes))
                
                # Reconstruir la lista de órdenes a domicilio manteniendo agrupados los bloques
                ordenes_domicilio = []
                
                # Primero los bloques prioritarios
                for _, ordenes in bloques_prioritarios:
                    ordenes_domicilio.extend(ordenes)
                
                # Luego los bloques normales
                for _, ordenes in bloques_normales:
                    ordenes_domicilio.extend(ordenes)
                
                # Sort other order types by fecha_apertura
                ordenes_para_llevar.sort(key=lambda o: get_fecha_apertura(o))
                ordenes_comedor.sort(key=lambda o: get_fecha_apertura(o))
                
                # Sort manual priority orders
                ordenes_prioridad_manual.sort(key=lambda o: get_fecha_apertura(o))
                
                # Now apply the pattern based on configuration
                ordenes_ordenadas = []
                
                # First, add scheduled orders (highest priority)
                ordenes_ordenadas.extend(ordenes_programadas)
                
                # Then, add manual priority orders
                ordenes_ordenadas.extend(ordenes_prioridad_manual)
                
                # Now apply the pattern from configuration
                para_llevar_index = 0
                domicilio_index = 0
                comedor_index = 0
                
                # Continue until all orders are processed
                while (para_llevar_index < len(ordenes_para_llevar) or 
                       domicilio_index < len(ordenes_domicilio) or 
                       comedor_index < len(ordenes_comedor)):
                    
                    # Add takeout orders según configuración
                    for _ in range(config_orden['para_llevar']):
                        if para_llevar_index < len(ordenes_para_llevar):
                            ordenes_ordenadas.append(ordenes_para_llevar[para_llevar_index])
                            para_llevar_index += 1
                        else:
                            break
                    
                    # Add delivery orders según configuración
                    for _ in range(config_orden['domicilio']):
                        if domicilio_index < len(ordenes_domicilio):
                            ordenes_ordenadas.append(ordenes_domicilio[domicilio_index])
                            domicilio_index += 1
                        else:
                            break
                    
                    # Add dine-in orders según configuración
                    for _ in range(config_orden['comedor']):
                        if comedor_index < len(ordenes_comedor):
                            ordenes_ordenadas.append(ordenes_comedor[comedor_index])
                            comedor_index += 1
                        else:
                            break
                
                # Combine all orders for display - orders in preparation first, then ordered list
                ordenes = []
                ordenes.extend(ordenes_en_preparacion)
                ordenes.extend(ordenes_ordenadas)
                
                # Process order data for the template
                print("Procesando datos para la plantilla")
                ordenes_pendientes = ordenes_ordenadas
                
                for orden in ordenes:
                    # Marcar tiempos de espera largos - ahora usando minutos_espera
                    orden['tiempo_espera_largo'] = orden.get('minutos_espera', 0) > 30
                    
                    # Marcar visualmente pedidos programados para mostrar en el frontend
                    if orden.get('programado') and orden.get('fecha_programado'):
                        fecha_programado = orden.get('fecha_programado')
                        if isinstance(fecha_programado, str):
                            try:
                                fecha_programado = datetime.strptime(fecha_programado, '%Y-%m-%d %H:%M:%S')
                            except ValueError:
                                pass
                            
                        # Formatear la hora programada para mostrar
                        if isinstance(fecha_programado, datetime):
                            hora_formateada = fecha_programado.strftime('%H:%M')
                            orden['es_programado'] = True
                            orden['hora_programada'] = hora_formateada
                        else:
                            orden['es_programado'] = True
                            orden['hora_programada'] = "Programado"
                
                print(f"Clasificadas: {len(ordenes_en_preparacion)} en preparación, {len(ordenes_pendientes)} pendientes")
                
                # Obtener cocineros disponibles (rol_id = 5)
                print("Obteniendo lista de cocineros")
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT id, CONCAT(nombre, ' ', apellidos) as nombre_completo
                    FROM empleados
                    WHERE rol_id = 5 AND estatus = 'activo' and numero_django is NULL
                    ORDER BY nombre, apellidos
                ''')
                
                cocineros = dictfetchall(cursor)
                print(f"Obtenidos {len(cocineros)} cocineros")
                
                # Obtener información de bloques de ruta
                print("Obteniendo información de bloques de ruta")
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT br.id, br.nombre, br.color,
                           COUNT(o.id) as total_ordenes
                    FROM bloques_ruta br
                    LEFT JOIN ordenes o ON br.id = o.bloque_ruta_id
                    WHERE br.activo = 1
                    GROUP BY br.id
                    ORDER BY br.nombre
                ''')
                
                bloques_ruta = dictfetchall(cursor)
                print(f"Obtenidos {len(bloques_ruta)} bloques de ruta")
            

                # Consultar productos con stock bajo
                print("Consultando productos con stock bajo")
                try:
                    cursor.execute('''
                        SET STATEMENT max_statement_time = 25 FOR 
                        SELECT nombre, stock_actual
                        FROM productos 
                        WHERE (DATE(fecha_validado) <> CURDATE() OR fecha_validado IS NULL)
                        AND (dias_disponibles IS NULL OR FIND_IN_SET(WEEKDAY(CURDATE()) + 1, dias_disponibles))
                        AND (vista_cocina <> 0 OR vista_cocina IS NULL) AND control_inventario = 1
                        AND stock_actual < 6
                    ''')
                    
                    productos_stock_bajo = dictfetchall(cursor)
                    print(f"Encontrados {len(productos_stock_bajo)} productos con stock bajo")
                except Exception as e:
                    print(f"ERROR al consultar productos stock bajo: {str(e)}")
                    productos_stock_bajo = []
            except Exception as e:
                print(f"ERROR EN CONSULTA SQL: {str(e)}")
                # Datos vacíos para no romper la plantilla
                ordenes = []
                ordenes_en_preparacion = []
                ordenes_pendientes = []
                cocineros = []
                bloques_ruta = []
                # Mostrar error en la interfaz
                messages.error(request, f"Error al consultar datos: {str(e)}")
        
        # Renderizar plantilla
        print("Renderizando plantilla")
        return render(request, 'cocina/vista_cocina.html', {
            'ordenes': ordenes,
            'total_ordenes': len(ordenes),
            'en_preparacion': len(ordenes_en_preparacion),
            'pendientes': len(ordenes_pendientes),
            'cocineros': cocineros,
            'bloques_ruta': bloques_ruta,
            'productos_stock_bajo': productos_stock_bajo
        })
    
    except Exception as e:
        print(f"ERROR GENERAL EN VISTA: {str(e)}")
        # En caso de error serio, mostrar página de error básica
        return HttpResponse(f"""
            <h1>Error en el sistema</h1>
            <p>Ha ocurrido un error en la vista de cocina:</p>
            <pre>{str(e)}</pre>
            <p><a href="/">Volver al inicio</a></p>
        """)
@login_required
@grupos_permitidos(['Administradores','Cocineros'])
def productos_stock_bajo(request):
    """API endpoint para consultar productos con stock bajo"""
    try:
        with connections['pagoda'].cursor() as cursor:
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT nombre, stock_actual
                FROM productos 
                WHERE (DATE(fecha_validado) <> CURDATE() OR fecha_validado IS NULL)
                AND (dias_disponibles IS NULL OR FIND_IN_SET(WEEKDAY(CURDATE()) + 1, dias_disponibles))
                AND (vista_cocina <> 0 OR vista_cocina IS NULL)
                AND stock_actual < 6 AND control_inventario = 1
            ''')
            
            productos = dictfetchall(cursor)
            
            return JsonResponse({
                'success': True,
                'productos': productos,
                'total': len(productos)
            })
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)

@csrf_exempt
@login_required
def tomar_orden(request, orden_id):
    """Vista para que un cocinero tome una orden"""
    print(f"Iniciando tomar_orden para orden_id: {orden_id}")
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        cocinero_id = data.get('cocinero_id')
        print(f"Cocinero seleccionado: {cocinero_id}")
        
        if not cocinero_id:
            return JsonResponse({'error': 'Debe seleccionar un cocinero'}, status=400)
        
        connection = connections['pagoda']
        with connection.cursor() as cursor:
            try:
                # Iniciar transacción explícitamente
                cursor.execute("BEGIN")
                
                # Verificar si la orden ya está tomada
                print("Verificando estado actual de la orden")
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT estatus_preparacion, cocinero_id 
                    FROM ordenes 
                    WHERE id = %s
                ''', [orden_id])
                
                orden = cursor.fetchone()
                if not orden:
                    print(f"Orden {orden_id} no encontrada")
                    # Hacer rollback y salir
                    cursor.execute("ROLLBACK")
                    return JsonResponse({'error': 'Orden no encontrada'}, status=404)
                
                print(f"Estado actual: {orden[0]}, cocinero actual: {orden[1]}")
                estatus_actual = orden[0]
                cocinero_actual = orden[1]
                print(estatus_actual)
                print(cocinero_actual)
                print('orden', orden)
                if estatus_actual == 'en_preparacion' and cocinero_actual is not None:
                    print("Orden ya está siendo preparada")
                    # Hacer rollback y salir
                    cursor.execute("ROLLBACK")
                    return JsonResponse({
                        'error': 'Esta orden ya está siendo preparada por otro cocinero'
                    }, status=400)
                
                # Actualizar la orden
                print("Actualizando orden a en_preparacion")
                cursor.execute('''
                    UPDATE ordenes 
                    SET estatus_preparacion = 'en_preparacion',
                        cocinero_id = %s,
                        fecha_inicio_preparacion = NOW()
                    WHERE id = %s
                ''', [cocinero_id, orden_id])

                cursor.execute('''
                    UPDATE orden_detalles 
                    SET preparado = 1
                    WHERE orden_id = %s and preparado = 0
                ''', [orden_id])
                
                # Registrar en historial de estados
                print("Registrando en historial")
                cursor.execute('''
                    INSERT INTO orden_historial_estados (
                        orden_id, estado_anterior, estado_nuevo, empleado_id, motivo
                    ) VALUES (%s, %s, 'en_preparacion', %s, 'Orden tomada por cocinero')
                ''', [orden_id, estatus_actual or 'pendiente', cocinero_id])
                
                # Obtener datos para el ticket
                print("Obteniendo datos para ticket")
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT o.codigo_orden, o.fecha_apertura,
                           ts.nombre as tipo_servicio,
                           CONCAT(e.nombre, ' ', e.apellidos) as mesero,
                           CONCAT(c.nombre, ' ', IFNULL(c.apellidos, '')) as cliente
                    FROM ordenes o
                    JOIN tipos_servicio ts ON o.tipo_servicio_id = ts.id
                    JOIN empleados e ON o.empleado_id = e.id
                    LEFT JOIN clientes c ON o.cliente_id = c.id
                    WHERE o.id = %s
                ''', [orden_id])
                
                datos_orden = dictfetchall(cursor)[0] if cursor.rowcount > 0 else None
                
                # Confirmar la transacción
                cursor.execute("COMMIT")
                print("Transacción completada y confirmada con éxito")
                
                return JsonResponse({
                    'success': True,
                    'mensaje': 'Orden tomada correctamente',
                    'datos_orden': datos_orden,
                    'ticket_url': f'/cocina/ticket/{orden_id}/'
                })
                
            except Exception as e:
                # Hacer rollback en caso de error
                cursor.execute("ROLLBACK")
                print(f"ERROR EN TOMAR ORDEN - Transacción cancelada: {str(e)}")
                raise e
                
    except json.JSONDecodeError:
        print("Error: JSON inválido")
        return JsonResponse({'error': 'Formato JSON inválido'}, status=400)
    except Exception as e:
        print(f"ERROR EN TOMAR ORDEN: {str(e)}")
        return JsonResponse({'error': str(e)}, status=500)

@csrf_exempt
@login_required
def finalizar_orden(request, orden_id):
    """Vista para marcar una orden como lista"""
    print(f"Iniciando finalizar_orden para orden_id: {orden_id}")
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        connection = connections['pagoda']
        with connection.cursor() as cursor:
            try:
                # Iniciar transacción explícitamente
                cursor.execute("BEGIN")
                
                # Verificar si la orden está en preparación
                print("Verificando estado actual de la orden")
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT estatus_preparacion, cocinero_id 
                    FROM ordenes 
                    WHERE id = %s
                ''', [orden_id])
                
                orden = cursor.fetchone()
                if not orden:
                    print(f"Orden {orden_id} no encontrada")
                    # Hacer rollback y salir
                    cursor.execute("ROLLBACK")
                    return JsonResponse({'error': 'Orden no encontrada'}, status=404)
                
                print(f"Estado actual: {orden[0]}, cocinero: {orden[1]}")
                estatus_actual = orden[0]
                cocinero_id = orden[1]
                
                if estatus_actual != 'en_preparacion':
                    print("Orden no está en preparación")
                    # Hacer rollback y salir
                    cursor.execute("ROLLBACK")
                    return JsonResponse({
                        'error': 'Esta orden no está en preparación'
                    }, status=400)
                
                # Actualizar la orden
                print("Actualizando orden a lista")
                cursor.execute('''
                    UPDATE ordenes 
                    SET estatus_preparacion = 'lista',
                        fecha_fin_preparacion = NOW()
                    WHERE id = %s
                ''', [orden_id])

                cursor.execute('''
                    UPDATE orden_detalles 
                    SET preparado = 2
                    WHERE orden_id = %s and preparado = 1
                ''', [orden_id])
                
                # Registrar en historial de estados
                print("Registrando en historial")
                cursor.execute('''
                    INSERT INTO orden_historial_estados (
                        orden_id, estado_anterior, estado_nuevo, empleado_id, motivo
                    ) VALUES (%s, 'en_preparacion', 'lista', %s, 'Orden finalizada por cocinero')
                ''', [orden_id, cocinero_id])
                
                # Confirmar la transacción
                cursor.execute("COMMIT")
                print("Transacción completada y confirmada con éxito")
                
                return JsonResponse({
                    'success': True,
                    'mensaje': 'Orden marcada como lista'
                })
                
            except Exception as e:
                # Hacer rollback en caso de error
                cursor.execute("ROLLBACK")
                print(f"ERROR EN FINALIZAR ORDEN - Transacción cancelada: {str(e)}")
                raise e
            
    except Exception as e:
        print(f"ERROR EN FINALIZAR ORDEN: {str(e)}")
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def ticket_cocina(request, orden_id):
    """Vista para generar e imprimir el ticket de cocina"""
    print(f"Iniciando ticket_cocina para orden_id: {orden_id}")
    try:
        with connections['pagoda'].cursor() as cursor:
            # Datos de la orden
            print("Obteniendo datos de la orden")
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT o.*,
                       ts.nombre as tipo_servicio,
                       m.numero as mesa_numero,
                       CONCAT(e.nombre, ' ', e.apellidos) as mesero,
                       CONCAT(coc.nombre, ' ', coc.apellidos) as cocinero,
                       o.cubiertos, -- Nueva columna agregada
                       CASE
                           WHEN o.tipo_servicio_id = 3 THEN
                               (SELECT CONCAT(calle, ' ', numero_exterior, ', ', colonia)
                                FROM direcciones_cliente
                                WHERE id = o.direccion_entrega_id)
                           ELSE NULL
                       END as direccion_entrega
                FROM ordenes o
                JOIN tipos_servicio ts ON o.tipo_servicio_id = ts.id
                LEFT JOIN mesas m ON o.mesa_id = m.id
                JOIN empleados e ON o.empleado_id = e.id
                LEFT JOIN empleados coc ON o.cocinero_id = coc.id
                WHERE o.id = %s
            ''', [orden_id])
                         
            orden = dictfetchone(cursor)
                         
            if not orden:
                print(f"Orden {orden_id} no encontrada")
                return HttpResponse('Orden no encontrada', status=404)
                         
            # Obtener items de la orden
            print("Obteniendo items de la orden")
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT od.*, p.nombre as producto
                FROM orden_detalles od
                JOIN productos p ON od.producto_id = p.id
                WHERE od.orden_id = %s and od.preparado = 1 and (p.vista_cocina = 1 or p.vista_cocina is null)
                ORDER BY od.id
            ''', [orden_id])
                         
            items = dictfetchall(cursor)
            print(f"Obtenidos {len(items)} items")
                         
            # Para cada item, obtener sus modificadores
            print("Obteniendo modificadores para cada item")
            for item in items:
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT opm.*, om.nombre
                    FROM orden_producto_modificadores opm
                    JOIN opciones_modificador om ON opm.opcion_modificador_id = om.id
                    WHERE opm.orden_detalle_id = %s
                ''', [item['id']])
                item['modificadores'] = dictfetchall(cursor)
                print(f"Item {item['id']} tiene {len(item['modificadores'])} modificadores")
             
        # Configurar para impresión automática
        imprimir_auto = not request.GET.get('preview') == 'true'
        print(f"Impresión automática: {imprimir_auto}")
                 
        # Renderizar plantilla
        print("Renderizando ticket")
        return render(request, 'cocina/ticket.html', {
            'orden': orden,
            'items': items,
            'imprimir_auto': imprimir_auto
        })
             
    except Exception as e:
        print(f"ERROR EN TICKET: {str(e)}")
        return HttpResponse(f"""
            <h1>Error al generar ticket</h1>
            <p>Ha ocurrido un error:</p>
            <pre>{str(e)}</pre>
            <p><a href="/cocina/">Volver a cocina</a></p>
        """)

@login_required
@grupos_permitidos(['Administradores', 'Meseros','Delivery','Operadores','Rapidos'])
def ordenes_usuario(request, empleado_id):
    """Vista para obtener órdenes del empleado actual (solo del día actual)"""
    try:
        # Verificar que el empleado_id corresponda con el de la sesión
        if str(empleado_id) != str(request.session.get('pos_empleado_id')):
            return JsonResponse({'error': 'No autorizado para ver órdenes de otro empleado'}, status=403)
        
        # Obtener los grupos del usuario
        grupos_usuario = [grupo.name for grupo in request.user.groups.all()]
        
        # Determinar qué tipos de servicio puede ver según sus grupos
        tipos_servicio_permitidos = []
        
        # Tipo 1: Comedor - Permitido para Administradores y Meseros
        if 'Administradores' in grupos_usuario or 'Meseros' in grupos_usuario:
            tipos_servicio_permitidos.append(1)
            
        # Tipo 2: Para llevar - Permitido para Administradores, Operadores y Rapidos
        if 'Administradores' in grupos_usuario or 'Operadores' in grupos_usuario or 'Rapidos' in grupos_usuario:
            tipos_servicio_permitidos.append(2)
            
        # Tipo 3: Domicilio - Permitido para Administradores, Operadores y Delivery
        if 'Administradores' in grupos_usuario or 'Operadores' in grupos_usuario or 'Delivery' in grupos_usuario:
            tipos_servicio_permitidos.append(3)
            
        # Tipo 4: Pedidos de comedor programados - Permitido para Administradores y Operadores
        if 'Administradores' in grupos_usuario or 'Operadores' in grupos_usuario:
            tipos_servicio_permitidos.append(4)
        
        with connections['pagoda'].cursor() as cursor:
            # Base de la consulta SQL
            query_base = '''
                SET STATEMENT max_statement_time = 25 FOR SELECT
                    o.id, o.codigo_orden, ts.nombre as tipo_servicio,
                    ts.id as tipo_servicio_id,
                    m.numero as mesa,
                    CONCAT(c.nombre, ' ', IFNULL(c.apellidos, ''),' ', IFNULL(o.nombre_tk, '')) as cliente,
                    DATE_FORMAT(o.fecha_apertura, '%H:%i') as hora,
                    o.fecha_apertura,
                    CASE
                         -- Para tipo_servicio = 1: usar el estatus normal
                        WHEN ts.id = 1 THEN o.estatus
                        
                         -- Para tipo_servicio = 2: revisar estatus_preparacion
                        WHEN ts.id = 2 THEN
                             CASE
                                 WHEN o.estatus_preparacion IS NULL THEN 'por preparar'
                                ELSE o.estatus_preparacion
                            END
                        
                         -- Para tipo_servicio = 3: lógica más compleja
                        WHEN ts.id = 3 THEN
                             CASE
                                 WHEN o.estatus_preparacion IS NULL THEN 'por preparar'
                                WHEN o.estatus_preparacion = 'lista' THEN o.estatus_entrega
                                ELSE o.estatus_preparacion
                            END
                            
                        -- Para tipo_servicio = 4: mostrar el estatus de preparación
                        WHEN ts.id = 4 THEN
                            CASE
                                WHEN o.estatus_preparacion IS NULL THEN 'por preparar'
                                ELSE o.estatus_preparacion
                            END
                        
                         -- Para otros tipos de servicio: usar estatus normal por defecto
                        ELSE o.estatus
                    END as estatus,
                    
                    o.programado, o.fecha_programado,
                    CASE
                        WHEN o.direccion_entrega_id IS NOT NULL THEN
                            (SELECT CONCAT('Colonia ', colonia, ' Calle ', calle)
                              FROM direcciones_cliente
                              WHERE id = o.direccion_entrega_id)
                        ELSE NULL
                    END as direccion,
                    o.es_reserva
                FROM ordenes o
                LEFT JOIN mesas m ON o.mesa_id = m.id
                JOIN tipos_servicio ts ON o.tipo_servicio_id = ts.id
                LEFT JOIN clientes c ON o.cliente_id = c.id
                WHERE DATE(o.fecha_apertura) = CURDATE()
            '''
            
            # Añadir filtro según los tipos de servicio permitidos
            if tipos_servicio_permitidos:
                query_base += f" AND ts.id IN ({','.join(map(str, tipos_servicio_permitidos))})"
            else:
                # Si no tiene permiso para ningún tipo, devolver lista vacía
                return JsonResponse([], safe=False)
                
            query_base += " ORDER BY o.fecha_apertura DESC"
            
            cursor.execute(query_base)
            
            ordenes = dictfetchall(cursor)
            
            return JsonResponse(ordenes, safe=False, json_dumps_params={'default': decimal_default})
            
    except Exception as e:
        logger.error(f"ERROR EN ORDENES USUARIO: {str(e)}")
        return JsonResponse({'error': str(e)}, status=500)
 

@login_required
@grupos_permitidos(['Administradores','Ruteador'])
def vista_pre_ruteo(request):
    """Vista principal para gestionar rutas de entrega y pedidos a domicilio"""
    try:
        with connections['pagoda'].cursor() as cursor:
            # Obtener rutas activas (antes bloques_ruta)
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT r.*, 
                       CONCAT(e.nombre, ' ', e.apellidos) as creador_nombre,
                       rep.id as repartidor_id,
                       CONCAT(emp.nombre, ' ', emp.apellidos) as repartidor_nombre,
                       (SELECT COUNT(*) FROM ordenes WHERE bloque_ruta_id = r.id) as total_ordenes,
                        r.prioritario
                FROM bloques_ruta r
                LEFT JOIN empleados e ON r.creador_id = e.id
                LEFT JOIN repartidores rep ON r.repartidor_id = rep.id
                LEFT JOIN empleados emp ON rep.empleado_id = emp.id
                WHERE r.activo IN (0, 1)  # Solo rutas abiertas (0) o en camino (1)
                ORDER BY r.fecha_creacion DESC
            ''')
            rutas_activas = dictfetchall(cursor)
            
            # Obtener pedidos a domicilio pendientes
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT o.id, o.codigo_orden, o.fecha_apertura, o.estatus, 
                    o.estatus_preparacion, o.estatus_entrega, o.programado,
                    o.fecha_programado, o.bloque_ruta_id as ruta_id, 
                    o.posicion_en_bloque, o.prioridad_manual,
                    o.tipo_servicio_id, ts.nombre as tipo_servicio, 
                    CONCAT(c.nombre, ' ', IFNULL(c.apellidos, '')) as cliente,
                    CASE
                        WHEN o.tipo_servicio_id = 3 THEN
                            (SELECT CONCAT('Calle ' , calle, ' #', numero_exterior, ', ', colonia)
                                FROM direcciones_cliente
                                WHERE id = o.direccion_entrega_id)
                        ELSE NULL
                    END as direccion_entrega,
                    (SELECT COUNT(*) FROM orden_detalles WHERE orden_id = o.id) as num_items,
                    CONCAT(
                        FLOOR(TIMESTAMPDIFF(MINUTE, o.fecha_apertura, NOW()) / 60), 
                        ':', 
                        LPAD(TIMESTAMPDIFF(MINUTE, o.fecha_apertura, NOW()) % 60, 2, '0')
                    ) as tiempo_espera,
                    TIMESTAMPDIFF(MINUTE, o.fecha_apertura, NOW()) as minutos_espera,
                    r.nombre as ruta_nombre,
                    r.color as ruta_color,
                    o.fecha_programado,
                    CASE 
                        WHEN o.estatus_entrega = 'abierta' AND o.bloque_ruta_id IS NOT NULL THEN 'ruta_asignada'
                        WHEN o.estatus_entrega = 'en_camino' THEN 'en_ruta'
                        WHEN o.estatus_entrega = 'entregada' THEN 'entregada'
                        ELSE 'por_asignar'
                    END as estado_display
                FROM ordenes o
                LEFT JOIN tipos_servicio ts ON o.tipo_servicio_id = ts.id
                LEFT JOIN clientes c ON o.cliente_id = c.id
                LEFT JOIN bloques_ruta r ON o.bloque_ruta_id = r.id
                WHERE 
                    # Pedidos de domicilio (tipo_servicio_id = 3)
                    o.tipo_servicio_id = 3 OR 
                        # Abiertos o en camino
                        o.estatus_entrega IN ('abierta', 'en_camino') OR
                        # O programados para hoy
                        (o.programado = 1 AND DATE(o.fecha_programado) = CURDATE() OR
                        o.fecha_entrega = CURDATE()
                        
                    
                )
                ORDER BY 
                        o.bloque_ruta_id,  -- Primero por ruta
                        o.posicion_en_bloque,  -- Luego por posición dentro de la ruta
                        o.prioridad_manual DESC,  -- Después por prioridad
                        o.fecha_apertura ASC  -- Finalmente por fecha
            ''')
            # Convertir resultados a diccionarios
            ordenes = dictfetchall(cursor)
            
            # Obtener repartidores
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT r.*, e.id as empleado_id, e.nombre, e.apellidos,
                       CASE 
                           WHEN EXISTS (
                               SELECT 1 FROM bloques_ruta br 
                               WHERE br.repartidor_id = r.id AND br.activo = 1
                           ) THEN 0
                           ELSE 1
                       END as disponible
                FROM repartidores r
                JOIN empleados e ON r.empleado_id = e.id
                WHERE r.activo = 1
                AND NOT EXISTS (
                    SELECT 1 FROM bloques_ruta br 
                    WHERE br.repartidor_id = r.id AND br.activo = 1
                )                           
                ORDER BY e.nombre, e.apellidos
            ''')
            repartidores = dictfetchall(cursor)
            print(repartidores)
            # Procesar órdenes por ruta para el panel derecho
            for ruta in rutas_activas:
                ruta['ordenes'] = [o for o in ordenes if o.get('ruta_id') == ruta['id']]
                ruta['ordenes'].sort(key=lambda x: x.get('posicion_en_bloque', 0))
            
            # Separar pedidos por el nuevo sistema de 4 estados
            ordenes_por_asignar = [o for o in ordenes if o.get('estatus_entrega') == 'abierta' and not o.get('ruta_id')]
            ordenes_ruta_asignada = [o for o in ordenes if o.get('estatus_entrega') == 'abierta' and o.get('ruta_id')]
            ordenes_en_ruta = [o for o in ordenes if o.get('estatus_entrega') == 'en_camino']
            ordenes_entregadas = [o for o in ordenes if o.get('estatus_entrega') == 'entregada']

            # Obtener cantidad de pedidos entregados hoy
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT COUNT(*) as total_entregados
                FROM ordenes 
                WHERE tipo_servicio_id = 3
                AND estatus_entrega = 'entregada'
                AND DATE(fecha_entrega) = CURDATE()
            ''')
            total_entregados = dictfetchone(cursor)['total_entregados']

            return render(request, 'despacho/pre_ruteo.html', {
                'rutas_activas': rutas_activas,
                'ordenes': ordenes,
                'repartidores': repartidores,
                'ordenes_por_asignar': ordenes_por_asignar,
                'ordenes_ruta_asignada': ordenes_ruta_asignada,
                'ordenes_en_ruta': ordenes_en_ruta,
                'ordenes_entregadas': ordenes_entregadas,
                'total_ordenes': len(ordenes),
            })
    
    except Exception as e:
        print(f"ERROR: {str(e)}")
        return HttpResponse(f"Error en el sistema: {str(e)}")

@csrf_exempt
@login_required
def crear_ruta(request):
    """API para crear o actualizar una ruta (antes bloques_ruta)"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        # Verificar contenido
        if not request.body:
            return JsonResponse({'error': 'Cuerpo de la solicitud vacío'}, status=400)
        
        try:
            data = json.loads(request.body)
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Formato JSON inválido'}, status=400)
        print(data.get('prioritario'))
        nombre = data.get('nombre')
        descripcion = data.get('descripcion')
        color = data.get('color')
        hora_estimada = data.get('hora_estimada')
        prioritario = data.get('prioritario', 1)  # Por defecto 0
        ruta_id = data.get('id')
        empleado_id = request.session['empleado_id']
        
        # Convertir string vacío a None
        hora_estimada = hora_estimada if hora_estimada not in ['', None] else None
        descripcion = descripcion if descripcion not in ['', None] else None
        color = color if color not in ['', None] else None
        
        if not nombre:
            return JsonResponse({'error': 'El nombre de la ruta es obligatorio'}, status=400)
        
        with connections['pagoda'].cursor() as cursor:
            if ruta_id:
                # Actualizar ruta existente
                query = '''
                    UPDATE bloques_ruta
                    SET nombre = %s, 
                        descripcion = %s, 
                        color = %s, 
                        hora_estimada_entrega = %s,
                        prioritario = %s,
                        modificador_id = %s,
                        fecha_modificacion = NOW()
                    WHERE id = %s
                '''
                cursor.execute(query, [
                    nombre,
                    descripcion,
                    color,
                    hora_estimada,
                    prioritario,
                    empleado_id,
                    ruta_id
                ])
                
                mensaje = "Ruta actualizada correctamente"
            else:
                # Crear nueva ruta
                query = '''
                    INSERT INTO bloques_ruta (
                        nombre, descripcion, color, hora_estimada_entrega, 
                        creador_id, activo, prioritario
                    ) VALUES (%s, %s, %s, %s, %s, 0, %s)
                '''
                cursor.execute(query, [
                    nombre,
                    descripcion,
                    color,
                    hora_estimada,
                    empleado_id,
                    prioritario
                ])
                
                ruta_id = cursor.lastrowid
                mensaje = "Ruta creada correctamente"
            
            # Obtener datos actualizados de la ruta
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT r.*, 
                       CONCAT(e.nombre, ' ', e.apellidos) as creador_nombre
                FROM bloques_ruta r
                LEFT JOIN empleados e ON r.creador_id = e.id
                WHERE r.id = %s
            ''', [ruta_id])
            
            ruta = dictfetchone(cursor)
            
            return JsonResponse({
                'success': True,
                'mensaje': mensaje,
                'ruta': ruta
            })
            
    except Exception as e:
        print(f"ERROR EN CREAR/ACTUALIZAR RUTA: {str(e)}")
        return JsonResponse({'error': f"Error en el servidor: {str(e)}"}, status=500)
    
@csrf_exempt
@login_required
def cambiar_prioridad_ruta(request):
    """API para cambiar la prioridad de una ruta"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        ruta_id = data.get('ruta_id')
        prioridad = data.get('prioridad', False)
        
        if not ruta_id:
            return JsonResponse({'error': 'ID de ruta es obligatorio'}, status=400)
        
        empleado_id = request.session['empleado_id']
        with connections['pagoda'].cursor() as cursor:
            # Verificar si la ruta existe y está activa
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT id, prioritario, activo
                FROM bloques_ruta 
                WHERE id = %s AND activo = 0
            ''', [ruta_id])
            
            ruta = dictfetchone(cursor)
            if not ruta:
                return JsonResponse({'error': 'Ruta no encontrada o ya está en proceso'}, status=404)
            
            # Actualizar prioridad
            cursor.execute('''
                UPDATE bloques_ruta 
                SET prioritario = %s, 
                    modificador_id = %s,
                    fecha_modificacion = NOW()
                WHERE id = %s
            ''', [prioridad, empleado_id, ruta_id])
            
            return JsonResponse({
                'success': True,
                'mensaje': 'Prioridad actualizada correctamente',
                'ruta_id': ruta_id,
                'prioridad': prioridad
            })
            
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Formato JSON inválido'}, status=400)
    except Exception as e:
        print(f"ERROR EN CAMBIAR PRIORIDAD DE RUTA: {str(e)}")
        return JsonResponse({'error': str(e)}, status=500)

@csrf_exempt
@login_required
def eliminar_ruta(request, ruta_id):
    """API para eliminar una ruta (antes bloque_ruta)"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        with connections['pagoda'].cursor() as cursor:
            # Verificar si la ruta existe
            cursor.execute('SET STATEMENT max_statement_time = 25 FOR SELECT id, activo FROM bloques_ruta WHERE id = %s', [ruta_id])
            ruta = dictfetchone(cursor)
            
            if not ruta:
                return JsonResponse({'error': 'Ruta no encontrada'}, status=404)
            
            # Solo permitir eliminar rutas que estén abiertas (activo = 0)
            if ruta['activo'] != 0:
                return JsonResponse({'error': 'No se puede eliminar una ruta que ya está en proceso de entrega'}, status=400)
            
            # Desasignar todas las órdenes de la ruta
            cursor.execute('''
                UPDATE ordenes
                SET bloque_ruta_id = NULL, posicion_en_bloque = 0
                WHERE bloque_ruta_id = %s
            ''', [ruta_id])
            
            ordenes_afectadas = cursor.rowcount
            
            # Marcar ruta como inactiva (eliminada)
            cursor.execute('''
                DELETE FROM bloques_ruta
                WHERE id = %s
            ''', [ruta_id])
            
            return JsonResponse({
                'success': True,
                'mensaje': 'Ruta eliminada correctamente',
                'ordenes_liberadas': ordenes_afectadas
            })
    
    except Exception as e:
        print(f"ERROR EN ELIMINAR RUTA: {str(e)}")
        return JsonResponse({'error': str(e)}, status=500)

@csrf_exempt
@login_required
def cambiar_prioridad_orden(request):
    """API para cambiar la prioridad de una orden"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        orden_id = data.get('orden_id')
        prioridad = data.get('prioridad', False)
        
        if not orden_id:
            return JsonResponse({'error': 'ID de orden es obligatorio'}, status=400)
        
        empleado_id = request.session['empleado_id']

        with connections['pagoda'].cursor() as cursor:
            # Verificar si la orden existe y está en un estado válido
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT id, estatus_preparacion, prioridad_manual
                FROM ordenes 
                WHERE id = %s AND (estatus_preparacion IS NULL OR estatus_preparacion = 'pendiente')
            ''', [orden_id])
            
            orden = dictfetchone(cursor)
            if not orden:
                return JsonResponse({'error': 'Orden no encontrada o no se puede priorizar en su estado actual'}, status=404)
            
            # Actualizar prioridad
            cursor.execute('''
                UPDATE ordenes 
                SET prioridad_manual = %s
                WHERE id = %s
            ''', [prioridad, orden_id])
            
            # Registrar en historial
            cursor.execute('''
                INSERT INTO orden_historial_estados (
                    orden_id, estado_anterior, estado_nuevo, empleado_id, motivo
                ) VALUES (%s, %s, %s, %s, %s)
            ''', [
                orden_id,
                'prioritaria' if orden['prioridad_manual'] else 'normal',
                'prioritaria' if prioridad else 'normal',
                empleado_id,
                f"Cambio de prioridad: {'Establecida como prioritaria' if prioridad else 'Prioridad removida'}"
            ])
            
            return JsonResponse({
                'success': True,
                'mensaje': 'Prioridad actualizada correctamente',
                'orden_id': orden_id,
                'prioridad': prioridad
            })
            
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Formato JSON inválido'}, status=400)
    except Exception as e:
        print(f"ERROR EN CAMBIAR PRIORIDAD: {str(e)}")
        return JsonResponse({'error': str(e)}, status=500)

@csrf_exempt
@login_required
def asignar_orden_ruta(request):
    """API para asignar una orden a una ruta"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        orden_id = data.get('orden_id')
        ruta_id = data.get('bloque_id')  # Mantener compatibilidad con nombre anterior
        posicion = data.get('posicion', 0)  # 0 = final, 1 = inicio
        empleado_id = request.session['empleado_id']
        
        if not orden_id:
            return JsonResponse({'error': 'ID de orden es obligatorio'}, status=400)
        
        with connections['pagoda'].cursor() as cursor:
            # Verificar si la orden existe y está en estado válido
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT o.id, o.tipo_servicio_id, o.estatus_preparacion, o.estatus_entrega, 
                       o.bloque_ruta_id, r.activo as ruta_activo
                FROM ordenes o
                LEFT JOIN bloques_ruta r ON o.bloque_ruta_id = r.id
                WHERE o.id = %s
            ''', [orden_id])
            
            orden = dictfetchone(cursor)
            print(orden)
            if not orden:
                return JsonResponse({'error': 'Orden no encontrada'}, status=404)
            
            # Verificar que sea de tipo domicilio
            if orden['tipo_servicio_id'] != 3:
                return JsonResponse({'error': 'Solo se pueden asignar a rutas los pedidos de domicilio'}, status=400)
            
            # Solo asignar órdenes que estén listas y abiertas para entrega
            if orden['estatus_entrega'] != 'abierta':
                return JsonResponse({
                    'error': 'Solo se pueden asignar a rutas los pedidos que estén listos para entrega'
                }, status=400)
            
            # Si la ruta actual está cerrada (en ruta), no permitir cambios
            if orden['bloque_ruta_id'] and orden['ruta_activo'] == 1:
                return JsonResponse({
                    'error': 'No se puede modificar la asignación de un pedido que ya está en ruta'
                }, status=400)
            
            # Si estamos asignando a una ruta
            if ruta_id:
                # Verificar que la ruta existe y está abierta
                cursor.execute('SET STATEMENT max_statement_time = 25 FOR SELECT id, nombre, color, activo FROM bloques_ruta WHERE id = %s', [ruta_id])
                ruta = dictfetchone(cursor)
                
                if not ruta:
                    return JsonResponse({'error': 'Ruta no encontrada'}, status=404)
                
                if ruta['activo'] != 0:
                    return JsonResponse({
                        'error': 'No se pueden agregar pedidos a una ruta que ya está en proceso de entrega'
                    }, status=400)
                
                # Obtener la posición máxima actual en la ruta
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT COALESCE(MAX(posicion_en_bloque), 0) as max_pos
                    FROM ordenes 
                    WHERE bloque_ruta_id = %s
                ''', [ruta_id])
                max_pos = dictfetchone(cursor)['max_pos']
                
                # Calcular nueva posición
                nueva_posicion = 1 if posicion == 1 else max_pos + 1
                
                # Si la posición es al inicio, reordenar las existentes
                if posicion == 1:
                    cursor.execute('''
                        UPDATE ordenes
                        SET posicion_en_bloque = posicion_en_bloque + 1
                        WHERE bloque_ruta_id = %s
                    ''', [ruta_id])
                
                # Asignar la orden a la ruta
                cursor.execute('''
                    UPDATE ordenes
                    SET bloque_ruta_id = %s, posicion_en_bloque = %s
                    WHERE id = %s
                ''', [ruta_id, nueva_posicion, orden_id])
                
                
                return JsonResponse({
                    'success': True,
                    'mensaje': 'Orden asignada correctamente a la ruta',
                    'orden_id': orden_id,
                    'ruta_id': ruta_id,
                    'bloque_nombre': ruta['nombre'],
                    'bloque_color': ruta['color']
                })
            
            else:
                # Desasignar la orden de la ruta actual
                if orden['bloque_ruta_id']:
                    cursor.execute('''
                        UPDATE ordenes
                        SET bloque_ruta_id = NULL, posicion_en_bloque = 0
                        WHERE id = %s
                    ''', [orden_id])
                    
                    # Registrar en historial
                    cursor.execute('''
                        INSERT INTO orden_historial_estados (
                            orden_id, estado_anterior, estado_nuevo, empleado_id, motivo
                        ) VALUES (%s, %s, %s, %s, %s)
                    ''', [
                        orden_id,
                        f"Ruta asignada",
                        "Sin ruta",
                        empleado_id,
                        "Pedido removido de ruta"
                    ])
                    
                    return JsonResponse({
                        'success': True,
                        'mensaje': 'Orden removida de la ruta',
                        'orden_id': orden_id
                    })
                else:
                    return JsonResponse({
                        'success': True,
                        'mensaje': 'La orden ya estaba sin ruta asignada',
                        'orden_id': orden_id
                    })
    
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Formato JSON inválido'}, status=400)
    except Exception as e:
        print(f"ERROR EN ASIGNAR ORDEN A RUTA: {str(e)}")
        return JsonResponse({'error': str(e)}, status=500)

@csrf_exempt
@login_required
def asignar_repartidor_ruta(request):
    """API para asignar un repartidor a una ruta"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        ruta_id = data.get('ruta_id')
        repartidor_id = data.get('repartidor_id')
        empleado_id = request.session['empleado_id']
        
        if not ruta_id or not repartidor_id:
            return JsonResponse({'error': 'ID de ruta y repartidor son obligatorios'}, status=400)
        
        with connections['pagoda'].cursor() as cursor:
            # Verificar si la ruta existe y está en estado válido (abierta)
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT id, nombre, activo 
                FROM bloques_ruta 
                WHERE id = %s
            ''', [ruta_id])
            
            ruta = dictfetchone(cursor)
            if not ruta:
                return JsonResponse({'error': 'Ruta no encontrada'}, status=404)
            
            if ruta['activo'] != 0:
                return JsonResponse({
                    'error': 'No se puede asignar repartidor a una ruta que ya está en proceso de entrega'
                }, status=400)
            
            # Verificar si el repartidor existe y está disponible
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT r.id, e.nombre, e.apellidos
                FROM repartidores r
                JOIN empleados e ON r.empleado_id = e.id
                WHERE r.id = %s AND r.activo = 1
                AND NOT EXISTS (
                    SELECT 1 FROM bloques_ruta br 
                    WHERE br.repartidor_id = r.id AND br.activo = 1
                )
            ''', [repartidor_id])
            
            repartidor = dictfetchone(cursor)
            if not repartidor:
                return JsonResponse({
                    'error': 'Repartidor no encontrado o no está disponible'
                }, status=404)
            
            # Asignar repartidor a la ruta
            cursor.execute('''
                UPDATE bloques_ruta
                SET repartidor_id = %s,
                    modificador_id = %s,
                    fecha_modificacion = NOW()
                WHERE id = %s
            ''', [repartidor_id, empleado_id, ruta_id])
            
            return JsonResponse({
                'success': True,
                'mensaje': 'Repartidor asignado correctamente',
                'ruta_id': ruta_id,
                'ruta_nombre': ruta['nombre'],
                'repartidor_id': repartidor_id,
                'repartidor_nombre': f"{repartidor['nombre']} {repartidor['apellidos']}"
            })
    
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Formato JSON inválido'}, status=400)
    except Exception as e:
        print(f"ERROR EN ASIGNAR REPARTIDOR: {str(e)}")
        return JsonResponse({'error': str(e)}, status=500)

@csrf_exempt
@login_required
def cerrar_ruta(request):
    """API para cambiar el estado de una ruta (iniciar entrega o completar)"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        ruta_id = data.get('ruta_id')
        estado = data.get('estado')  # 1 = en ruta, 2 = completada
        empleado_id = request.session['empleado_id']

        if not ruta_id or estado not in [1, 2]:
            return JsonResponse({'error': 'ID de ruta y estado válido son obligatorios'}, status=400)
        
        with connections['pagoda'].cursor() as cursor:
            # Verificar si la ruta existe
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT r.id, r.nombre, r.activo, r.repartidor_id, 
                       CONCAT(e.nombre, ' ', e.apellidos) as repartidor_nombre
                FROM bloques_ruta r
                LEFT JOIN repartidores rep ON r.repartidor_id = rep.id
                LEFT JOIN empleados e ON rep.empleado_id = e.id
                WHERE r.id = %s
            ''', [ruta_id])
            
            ruta = dictfetchone(cursor)
            if not ruta:
                return JsonResponse({'error': 'Ruta no encontrada'}, status=404)
            
            # Validar cambio de estado
            if estado == 1:  # Iniciar entrega (ruta debe estar abierta y tener repartidor)
                if ruta['activo'] != 0:
                    return JsonResponse({
                        'error': 'Solo se pueden iniciar rutas que estén abiertas'
                    }, status=400)
                
                if not ruta['repartidor_id']:
                    return JsonResponse({
                        'error': 'No se puede iniciar una ruta sin repartidor asignado'
                    }, status=400)
                
                repartidor = ruta['repartidor_id']
                print(repartidor)
                
                # Verificar que haya órdenes en la ruta
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT COUNT(*) as total
                    FROM ordenes
                    WHERE bloque_ruta_id = %s
                ''', [ruta_id])
                
                total_ordenes = dictfetchone(cursor)['total']
                if total_ordenes == 0:
                    return JsonResponse({
                        'error': 'No se puede iniciar una ruta sin pedidos asignados'
                    }, status=400)
                
                # NUEVA VALIDACIÓN: Verificar que todas las órdenes sean de tipo 3 (domicilio)
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT COUNT(*) as no_tipo_3
                    FROM ordenes
                    WHERE bloque_ruta_id = %s 
                    AND estatus <> 'Cancelado'
                    AND tipo_servicio_id <> 3
                ''', [ruta_id])
                
                ordenes_no_tipo_3 = dictfetchone(cursor)['no_tipo_3']
                if ordenes_no_tipo_3 > 0:
                    # Obtener detalles de las órdenes que no son tipo 3
                    cursor.execute('''
                        SET STATEMENT max_statement_time = 25 FOR SELECT o.id, o.codigo_orden, o.tipo_servicio_id, ts.nombre as tipo_servicio
                        FROM ordenes o
                        JOIN tipos_servicio ts ON o.tipo_servicio_id = ts.id
                        WHERE o.bloque_ruta_id = %s 
                        AND o.estatus <> 'Cancelado'
                        AND o.tipo_servicio_id <> 3
                        LIMIT 5
                    ''', [ruta_id])
                    
                    ordenes_problema = dictfetchall(cursor)
                    ejemplos = [f"Orden #{o['codigo_orden']} ({o['tipo_servicio']})" for o in ordenes_problema]
                    
                    return JsonResponse({
                        'error': 'No se puede iniciar la ruta porque contiene órdenes que no son de domicilio',
                        'total_no_tipo_3': ordenes_no_tipo_3,
                        'ejemplos': ejemplos[:5],
                        'detalle': 'Solo se pueden enviar órdenes de tipo "Domicilio" en rutas de entrega'
                    }, status=400)
                
                # VALIDACIÓN: Verificar que todas las órdenes tengan estatus_preparacion = 'lista'
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT COUNT(*) as no_listas
                    FROM ordenes
                    WHERE bloque_ruta_id = %s 
                    AND estatus <> 'Cancelado'
                    AND (estatus_preparacion <> 'lista' OR estatus_preparacion IS NULL)
                ''', [ruta_id])
                
                ordenes_no_listas = dictfetchone(cursor)['no_listas']
                if ordenes_no_listas > 0:
                    # Obtener detalles de las órdenes no listas para mejor información
                    cursor.execute('''
                        SET STATEMENT max_statement_time = 25 FOR SELECT id, codigo_orden, estatus_preparacion
                        FROM ordenes
                        WHERE bloque_ruta_id = %s 
                        AND estatus <> 'Cancelado'
                        AND (estatus_preparacion <> 'lista' OR estatus_preparacion IS NULL OR estatus_preparacion = 'en_preparacion')
                        LIMIT 5
                    ''', [ruta_id])
                    
                    ordenes_problema = dictfetchall(cursor)
                    numeros_orden = [str(o['codigo_orden']) for o in ordenes_problema]
                    
                    return JsonResponse({
                        'error': 'No se puede iniciar la ruta porque hay órdenes que no están listas para entrega',
                        'total_no_listas': ordenes_no_listas,
                        'ejemplos': numeros_orden[:5],
                        'detalle': 'Todas las órdenes deben tener estatus de preparación "lista"'
                    }, status=400)
                
                # Actualizar estado de la ruta a "en ruta"
                cursor.execute('''
                    UPDATE bloques_ruta
                    SET activo = 1,
                        fecha_salida = NOW(),
                        modificador_id = %s
                    WHERE id = %s
                ''', [empleado_id, ruta_id])
                
                # Actualizar estado de todas las órdenes a "en_camino"
                cursor.execute('''
                    UPDATE ordenes
                    SET estatus_entrega = 'en_camino',
                    repartidor_id = %s
                    WHERE bloque_ruta_id = %s
                ''', [repartidor, ruta_id])
                
                # Registrar en historial de cada orden
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT id FROM ordenes WHERE bloque_ruta_id = %s
                ''', [ruta_id])
                
                ordenes = dictfetchall(cursor)
                for orden in ordenes:
                    cursor.execute('''
                        INSERT INTO orden_historial_estados (
                            orden_id, estado_anterior, estado_nuevo, empleado_id, motivo
                        ) VALUES (%s, %s, %s, %s, %s)
                    ''', [
                        orden['id'],
                        "abierta",
                        "en_camino",
                        empleado_id,
                        f"Pedido en ruta de entrega con {ruta['repartidor_nombre']}"
                    ])
                
                return JsonResponse({
                    'success': True,
                    'mensaje': 'Ruta iniciada correctamente. Los pedidos están en camino.',
                    'ruta_id': ruta_id,
                    'ruta_nombre': ruta['nombre'],
                    'total_ordenes': total_ordenes
                })
                
            elif estado == 2:  # Completar ruta (ruta debe estar en camino)
                if ruta['activo'] != 1:
                    return JsonResponse({
                        'error': 'Solo se pueden completar rutas que estén en proceso de entrega'
                    }, status=400)
                
                # Actualizar estado de la ruta a "completada"
                cursor.execute('''
                    UPDATE bloques_ruta
                    SET activo = 2,
                        fecha_regreso = NOW(),
                        modificador_id = %s
                    WHERE id = %s
                ''', [empleado_id, ruta_id])
                
                # Actualizar estado de todas las órdenes a "entregada"
                cursor.execute('''
                    UPDATE ordenes
                    SET estatus_entrega = 'entregada',
                        fecha_entrega = NOW()
                    WHERE bloque_ruta_id = %s
                ''', [ruta_id])
                
                # Registrar en historial de cada orden
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT id FROM ordenes WHERE bloque_ruta_id = %s
                ''', [ruta_id])
                
                ordenes = dictfetchall(cursor)
                for orden in ordenes:
                    cursor.execute('''
                        INSERT INTO orden_historial_estados (
                            orden_id, estado_anterior, estado_nuevo, empleado_id, motivo
                        ) VALUES (%s, %s, %s, %s, %s)
                    ''', [
                        orden['id'],
                        "en_camino",
                        "entregada",
                        empleado_id,
                        "Pedido entregado"
                    ])
                
                return JsonResponse({
                    'success': True,
                    'mensaje': 'Ruta completada correctamente. Todos los pedidos han sido entregados.',
                    'ruta_id': ruta_id,
                    'ruta_nombre': ruta['nombre'],
                    'total_ordenes': len(ordenes)
                })
    
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Formato JSON inválido'}, status=400)
    except Exception as e:
        print(f"ERROR EN CERRAR RUTA: {str(e)}")
        return JsonResponse({'error': str(e)}, status=500)

@csrf_exempt
@login_required
def actualizar_posicion_orden(request):
    """API para actualizar la posición de una orden dentro de una ruta"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        orden_id = data.get('orden_id')
        ruta_id = data.get('ruta_id')
        posicion = data.get('posicion', 0)
        
        if not orden_id or not ruta_id:
            return JsonResponse({'error': 'ID de orden y ruta son obligatorios'}, status=400)
        
        with connections['pagoda'].cursor() as cursor:
            # Verificar si la ruta está abierta
            cursor.execute('SET STATEMENT max_statement_time = 25 FOR SELECT activo FROM bloques_ruta WHERE id = %s', [ruta_id])
            ruta = dictfetchone(cursor)
            
            if not ruta:
                return JsonResponse({'error': 'Ruta no encontrada'}, status=404)
            
            if ruta['activo'] != 0:
                return JsonResponse({
                    'error': 'No se puede modificar el orden en una ruta que ya está en proceso de entrega'
                }, status=400)
            
            # Actualizar posición
            cursor.execute('''
                UPDATE ordenes
                SET posicion_en_bloque = %s
                WHERE id = %s AND bloque_ruta_id = %s
            ''', [posicion + 1, orden_id, ruta_id])
            
            if cursor.rowcount == 0:
                return JsonResponse({'error': 'La orden no pertenece a esta ruta'}, status=400)
            
            return JsonResponse({
                'success': True,
                'mensaje': 'Posición actualizada correctamente',
                'orden_id': orden_id,
                'ruta_id': ruta_id,
                'posicion': posicion
            })
    
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Formato JSON inválido'}, status=400)
    except Exception as e:
        print(f"ERROR EN ACTUALIZAR POSICIÓN: {str(e)}")
        return JsonResponse({'error': str(e)}, status=500)

@csrf_exempt
@login_required
def cambiar_repartidor_ruta(request):
    """API para cambiar el repartidor asignado a una ruta"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        ruta_id = data.get('ruta_id')
        repartidor_id = data.get('repartidor_id')
        empleado_id = request.session['empleado_id']
        
        if not ruta_id:
            return JsonResponse({'error': 'ID de ruta es obligatorio'}, status=400)
        
        with connections['pagoda'].cursor() as cursor:
            # Verificar que la ruta existe y está abierta
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT id, activo FROM bloques_ruta WHERE id = %s
            ''', [ruta_id])
            
            ruta = dictfetchone(cursor)
            if not ruta:
                return JsonResponse({'error': 'Ruta no encontrada'}, status=404)
            
            if ruta['activo'] != 0:
                return JsonResponse({
                    'error': 'No se puede cambiar el repartidor de una ruta que ya está en proceso de entrega'
                }, status=400)
            
            # Actualizar repartidor
            cursor.execute('''
                UPDATE bloques_ruta
                SET repartidor_id = %s,
                    modificador_id = %s,
                    fecha_modificacion = NOW()
                WHERE id = %s
            ''', [repartidor_id if repartidor_id else None, empleado_id, ruta_id])
            
            mensaje = 'Repartidor removido correctamente' if not repartidor_id else 'Repartidor actualizado correctamente'
            
            return JsonResponse({
                'success': True,
                'mensaje': mensaje,
                'ruta_id': ruta_id
            })
    
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Formato JSON inválido'}, status=400)
    except Exception as e:
        print(f"ERROR EN CAMBIAR REPARTIDOR: {str(e)}")
        return JsonResponse({'error': str(e)}, status=500)

@csrf_exempt
@login_required
def obtener_detalle_orden(request, orden_id):
    """API para obtener el detalle completo de una orden"""
    if request.method != 'GET':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        with connections['pagoda'].cursor() as cursor:
            # Obtener información general de la orden
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT o.id, o.codigo_orden, o.fecha_apertura, o.fecha_programado,
                       CONCAT(c.nombre, ' ', IFNULL(c.apellidos, '')) as cliente,
                       CONCAT('Calle ', d.calle, ', Col. ', d.colonia, ', Referencias: ', IFNULL(d.referencias, '')) as direccion,
                       IFNULL(o.fecha_programado, '') as hora_programada,
                       o.total as total_orden
                FROM ordenes o
                LEFT JOIN clientes c ON c.id = o.cliente_id
                LEFT JOIN direcciones_cliente d ON d.id = o.direccion_entrega_id
                WHERE o.id = %s
            ''', [orden_id])
            
            orden = dictfetchone(cursor)
            if not orden:
                return JsonResponse({'error': 'Orden no encontrada'}, status=404)
            
            # Obtener productos de la orden
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT p.nombre as producto, od.cantidad, od.notas, od.total
                FROM orden_detalles od
                JOIN productos p ON od.producto_id = p.id
                WHERE od.orden_id = %s
                ORDER BY p.nombre
            ''', [orden_id])
            
            productos = dictfetchall(cursor)
            
            return JsonResponse({
                'success': True,
                'orden': orden,
                'productos': productos
            })
    
    except Exception as e:
        print(f"ERROR EN OBTENER DETALLE ORDEN: {str(e)}")
        return JsonResponse({'error': str(e)}, status=500)

@csrf_exempt
@login_required
def obtener_detalle_ruta_historial(request, ruta_id):
    """API para obtener el detalle histórico de una ruta"""
    if request.method != 'GET':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        with connections['pagoda'].cursor() as cursor:
            # Obtener información de la ruta
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT r.*, 
                       CONCAT(e.nombre, ' ', e.apellidos) as creador_nombre,
                       CONCAT(emp.nombre, ' ', emp.apellidos) as repartidor_nombre
                FROM bloques_ruta r
                LEFT JOIN empleados e ON r.creador_id = e.id
                LEFT JOIN repartidores rep ON r.repartidor_id = rep.id
                LEFT JOIN empleados emp ON rep.empleado_id = emp.id
                WHERE r.id = %s
            ''', [ruta_id])
            
            ruta = dictfetchone(cursor)
            if not ruta:
                return JsonResponse({'error': 'Ruta no encontrada'}, status=404)
            
            # Obtener pedidos de la ruta
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT o.id, o.codigo_orden, o.estatus_entrega, o.fecha_entrega,
                       CONCAT(c.nombre, ' ', IFNULL(c.apellidos, '')) as cliente,
                       CONCAT('Calle ', d.calle, ', Col. ', d.colonia, ', Referencias: ', IFNULL(d.referencias, '')) as direccion
                FROM ordenes o
                LEFT JOIN clientes c ON c.id = o.cliente_id
                LEFT JOIN direcciones_cliente d ON d.id = o.direccion_entrega_id
                WHERE o.bloque_ruta_id = %s
                ORDER BY o.posicion_en_bloque
            ''', [ruta_id])
            
            pedidos = dictfetchall(cursor)
            
            return JsonResponse({
                'success': True,
                'ruta': ruta,
                'pedidos': pedidos
            })
    
    except Exception as e:
        print(f"ERROR EN OBTENER DETALLE RUTA HISTORIAL: {str(e)}")
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def ticket_reparto_view(request, orden_id):
    """Vista para mostrar e imprimir el ticket de reparto individual"""
    
    with connections['pagoda'].cursor() as cursor:
        # Datos de la empresa
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT nombre, telefono, direccion, observaciones 
            FROM empresa 
            WHERE sys_pk = 1
        ''')
        empresa = dictfetchone(cursor)
        
        if not empresa:
            empresa = {
                'nombre': 'Pagoda',
                'telefono': '',
                'direccion': '',
                'observaciones': ''
            }
        
        # Datos de la orden
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT o.*,
                ts.nombre as tipo_servicio,
                CONCAT(c.nombre, ' ', IFNULL(c.apellidos, '')) as cliente,
                c.telefono,
                IF(o.programado = 1, o.fecha_programado, NULL) as fecha_programada,
                (SELECT CONCAT(calle, ' ', numero_exterior, ', ', colonia)
                 FROM direcciones_cliente
                 WHERE id = o.direccion_entrega_id) as direccion_entrega,
                (SELECT referencias
                 FROM direcciones_cliente
                 WHERE id = o.direccion_entrega_id) as referencias_entrega,
                (SELECT numero_piso
                 FROM direcciones_cliente
                 WHERE id = o.direccion_entrega_id) as piso_entrega,
                (SELECT area
                 FROM direcciones_cliente
                 WHERE id = o.direccion_entrega_id) as area_entrega,
                br.nombre as ruta_nombre,
                CONCAT(e.nombre, ' ', e.apellidos) as repartidor_nombre,
                o.observaciones as notas_entrega,
                o.estatus
            FROM ordenes o
            LEFT JOIN tipos_servicio ts ON o.tipo_servicio_id = ts.id
            LEFT JOIN clientes c ON o.cliente_id = c.id
            LEFT JOIN bloques_ruta br ON o.bloque_ruta_id = br.id
            LEFT JOIN repartidores r ON br.repartidor_id = r.id
            LEFT JOIN empleados e ON r.empleado_id = e.id
            WHERE o.id = %s and o.estatus <> 'cancelada'
        ''', [orden_id])
        
        orden = dictfetchone(cursor)
        
        if not orden:
            return HttpResponse('Orden no encontrada', status=404)
        
        # Obtener items de la orden
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT od.*, p.nombre as producto
            FROM orden_detalles od
            JOIN productos p ON od.producto_id = p.id
            WHERE od.orden_id = %s
            ORDER BY od.id
        ''', [orden_id])
        
        items = dictfetchall(cursor)
        
        # Para cada item, obtener sus modificadores
        for item in items:
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT opm.*, om.nombre
                FROM orden_producto_modificadores opm
                JOIN opciones_modificador om ON opm.opcion_modificador_id = om.id
                WHERE opm.orden_detalle_id = %s
            ''', [item['id']])
            item['modificadores'] = dictfetchall(cursor)
        
        # Obtener pagos de la orden
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT p.*, mp.nombre as metodo_pago, mp.id as metodo_pago_id
            FROM pagos p
            JOIN metodos_pago mp ON p.metodo_pago_id = mp.id
            WHERE p.orden_id = %s
            and p.estatus = 'completado'
            ORDER BY p.fecha_pago
        ''', [orden_id])
        
        pagos = dictfetchall(cursor)
        print(pagos)
        # Calcular montos totales
        total_pagado = sum(pago['monto'] for pago in pagos)
        total_orden = orden['total']
        
        # Identificar métodos de pago - crédito y efectivo
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT id 
            FROM metodos_pago 
            WHERE id = 6
        ''')
        metodos_credito = [row[0] for row in cursor.fetchall()]
        
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT id 
            FROM metodos_pago 
            WHERE id = 1
        ''')
        metodos_efectivo = [row[0] for row in cursor.fetchall()]
        
        # Calcular pagos por tipo
        pagos_credito = sum(pago['monto'] for pago in pagos if pago['metodo_pago_id'] in metodos_credito)
        pagos_efectivo = sum(pago['monto'] for pago in pagos if pago['metodo_pago_id'] in metodos_efectivo)
        pagos_otros = total_pagado - pagos_credito - pagos_efectivo  # Pagos con tarjeta, transferencia, etc.
        print(pagos_efectivo)
        # Calcular montos por cobrar según estatus
        if orden['estatus'] == 'cerrada':
            por_cobrar_efectivo = 0
            por_cobrar_credito = 0
            ticket_pagado = True
        else:  # estatus = 'por_cobrar'
            if not pagos:
                por_cobrar_efectivo = total_orden
                por_cobrar_credito = 0
            else:
                # Por cobrar en efectivo es el total menos los pagos realizados con métodos que no son efectivo (como tarjetas, transferencias)
                por_cobrar_efectivo = total_orden - pagos_otros - pagos_credito
                por_cobrar_credito = pagos_credito
            ticket_pagado = False
            print("t",total_orden)
            print(pagos_otros)
            print(pagos_credito)
    # Añadir información de cobro al contexto
    orden['por_cobrar_efectivo'] = por_cobrar_efectivo
    orden['por_cobrar_credito'] = por_cobrar_credito
    orden['ticket_pagado'] = ticket_pagado
    
    # Construir contexto para el template
    context = {
        'orden': orden,
        'items': items,
        'pagos': pagos,
        'empresa': empresa,
        'fecha_actual': datetime.now()
    }
    
    return render(request, 'despacho/ticket_reparto.html', context)

@login_required
def tira_continua_view(request, ruta_id):
    """Vista para mostrar e imprimir la tira continua de tickets"""
    
    with connections['pagoda'].cursor() as cursor:
        # Datos de la empresa
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT nombre, telefono, direccion, observaciones 
            FROM empresa 
            WHERE sys_pk = 1
        ''')
        empresa = dictfetchone(cursor)
        
        if not empresa:
            empresa = {
                'nombre': 'Cloud Restaurant',
                'telefono': '',
                'direccion': '',
                'observaciones': ''
            }
        
        # Datos de la ruta
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT br.*,
                CONCAT(e.nombre, ' ', e.apellidos) as repartidor_nombre
            FROM bloques_ruta br
            LEFT JOIN empleados e ON br.repartidor_id = e.id
            WHERE br.id = %s
        ''', [ruta_id])
        
        ruta = dictfetchone(cursor)
        
        if not ruta:
            return HttpResponse('Ruta no encontrada', status=404)
        
        # Identificar métodos de pago - crédito y efectivo
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT id 
            FROM metodos_pago 
            WHERE id = 6
        ''')
        metodos_credito = [row[0] for row in cursor.fetchall()]
        
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT id 
            FROM metodos_pago 
            WHERE id = 1
        ''')
        metodos_efectivo = [row[0] for row in cursor.fetchall()]
        
        # Obtener todas las órdenes de la ruta
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT o.*,
                ts.nombre as tipo_servicio,
                CONCAT(c.nombre, ' ', IFNULL(c.apellidos, '')) as cliente,
                c.telefono,
                IF(o.programado = 1, o.fecha_programado, NULL) as fecha_programada,
                (SELECT CONCAT(calle, ' ', numero_exterior, ', ', colonia)
                 FROM direcciones_cliente
                 WHERE id = o.direccion_entrega_id) as direccion_entrega,
                o.observaciones as notas_entrega,
                o.estatus
            FROM ordenes o
            LEFT JOIN tipos_servicio ts ON o.tipo_servicio_id = ts.id
            LEFT JOIN clientes c ON o.cliente_id = c.id
            WHERE o.bloque_ruta_id = %s and o.estatus <> 'cancelada'
            ORDER BY o.posicion_en_bloque
        ''', [ruta_id])
        
        ordenes = dictfetchall(cursor)
        
        # Para cada orden, obtener sus items y calcular montos por cobrar
        for orden in ordenes:
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT od.*, p.nombre as producto
                FROM orden_detalles od
                JOIN productos p ON od.producto_id = p.id
                WHERE od.orden_id = %s
                ORDER BY od.id
            ''', [orden['id']])
            
            orden['items'] = dictfetchall(cursor)
            
            # Para cada item, obtener sus modificadores
            for item in orden['items']:
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT opm.*, om.nombre
                    FROM orden_producto_modificadores opm
                    JOIN opciones_modificador om ON opm.opcion_modificador_id = om.id
                    WHERE opm.orden_detalle_id = %s
                ''', [item['id']])
                item['modificadores'] = dictfetchall(cursor)
            
            # Obtener pagos de la orden
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT p.*, mp.nombre as metodo_pago, mp.id as metodo_pago_id
                FROM pagos p
                JOIN metodos_pago mp ON p.metodo_pago_id = mp.id
                WHERE p.orden_id = %s
                and p.estatus = 'completado'
                ORDER BY p.fecha_pago
            ''', [orden['id']])
            
            orden['pagos'] = dictfetchall(cursor)
            
            # Calcular montos totales
            total_pagado = sum(pago['monto'] for pago in orden['pagos'])
            total_orden = orden['total']
            
            # Calcular pagos por tipo
            pagos_credito = sum(pago['monto'] for pago in orden['pagos'] if pago['metodo_pago_id'] in metodos_credito)
            pagos_efectivo = sum(pago['monto'] for pago in orden['pagos'] if pago['metodo_pago_id'] in metodos_efectivo)
            pagos_otros = total_pagado - pagos_credito - pagos_efectivo  # Pagos con tarjeta, transferencia, etc.
            
            # Calcular montos por cobrar según estatus
            if orden['estatus'] == 'cerrada':
                orden['por_cobrar_efectivo'] = 0
                orden['por_cobrar_credito'] = 0
                orden['ticket_pagado'] = True
            else:  # estatus = 'por_cobrar'
                if not orden['pagos']:
                    orden['por_cobrar_efectivo'] = total_orden
                    orden['por_cobrar_credito'] = 0
                else:
                    # Por cobrar en efectivo es el total menos los pagos realizados con métodos que no son efectivo
                    orden['por_cobrar_efectivo'] = total_orden - pagos_otros - pagos_credito
                    orden['por_cobrar_credito'] = pagos_credito
                orden['ticket_pagado'] = False
    
    # Construir contexto para el template
    context = {
        'ruta': ruta,
        'ordenes': ordenes,
        'empresa': empresa,
        'fecha_actual': datetime.now()
    }
    
    return render(request, 'despacho/ticket_reparto_continuo.html', context)

@login_required
def obtener_ordenes_ruta(request, ruta_id):
    """API para obtener las órdenes de una ruta (usado por JavaScript)"""
    
    with connections['pagoda'].cursor() as cursor:
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT o.id
            FROM ordenes o
            WHERE o.bloque_ruta_id = %s
            ORDER BY o.posicion_en_bloque
        ''', [ruta_id])
        
        ordenes = dictfetchall(cursor)
    
    return JsonResponse({
        'success': True,
        'ordenes': ordenes
    })


@csrf_exempt
@login_required
def cancelar_pago(request, pago_id):
    """Vista para cancelar un pago"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        empleado_id = request.session['empleado_id']
        
        with connections['pagoda'].cursor() as cursor:
            # Iniciar transacción
            cursor.execute('START TRANSACTION')
            
            try:
                # Verificar que el pago existe y obtener su información
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT p.orden_id, p.monto, p.estatus, o.estatus as orden_estatus
                    FROM pagos p
                    JOIN ordenes o ON p.orden_id = o.id
                    WHERE p.id = %s
                ''', [pago_id])
                
                result = cursor.fetchone()
                if not result:
                    cursor.execute('ROLLBACK')
                    return JsonResponse({'error': 'Pago no encontrado'}, status=404)
                
                orden_id, monto, pago_estatus, orden_estatus = result
                
                # Verificar que el pago está completado y la orden está abierta
                if pago_estatus != 'completado':
                    cursor.execute('ROLLBACK')
                    return JsonResponse({'error': 'El pago ya fue cancelado'}, status=400)
                
                if orden_estatus != 'por_cobrar':
                    cursor.execute('ROLLBACK')
                    return JsonResponse({'error': 'Solo se pueden cancelar pagos de órdenes abiertas'}, status=400)
                
                # Actualizar el estatus del pago a cancelado
                cursor.execute('''
                    UPDATE pagos 
                    SET estatus = 'cancelado'
                    WHERE id = %s
                ''', [pago_id])
                
                # Confirmar transacción
                cursor.execute('COMMIT')
                
                return JsonResponse({
                    'success': True,
                    'message': 'Pago cancelado correctamente'
                })
                
            except Exception as e:
                cursor.execute('ROLLBACK')
                return JsonResponse({'error': str(e)}, status=500)
    
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)


@csrf_exempt
@login_required
@grupos_permitidos(['Administradores'])
def cambiar_fecha_programada(request):
    """Vista para cambiar o establecer la fecha programada de una orden"""
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método no permitido'})
    
    # Iniciar una transacción para poder hacer rollback si es necesario
    conn = connections['pagoda']
    conn.autocommit = False
    cursor = conn.cursor()
    
    try:
        data = json.loads(request.body)
        orden_id = data.get('orden_id')
        nueva_fecha = data.get('nueva_fecha')
        
        if not orden_id or not nueva_fecha:
            return JsonResponse({'success': False, 'error': 'Datos incompletos'})
        
        # Convertir la fecha recibida a formato adecuado para la base de datos
        try:
            fecha_obj = datetime.fromisoformat(nueva_fecha.replace('Z', '+00:00'))
            nueva_fecha_iso = fecha_obj.strftime('%Y-%m-%d %H:%M:%S')
        except ValueError:
            return JsonResponse({'success': False, 'error': 'Formato de fecha inválido'})
        
        # Verificar que la orden existe y cumple con los criterios para cambiar fecha
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT o.estatus, o.tipo_servicio_id, o.estatus_preparacion, o.estatus_entrega,
                   o.programado, o.fecha_programado
            FROM ordenes o
            WHERE o.id = %s
        ''', [orden_id])
        
        resultado = cursor.fetchone()
        if not resultado:
            return JsonResponse({'success': False, 'error': 'Orden no encontrada'})
        
        estatus, tipo_servicio_id, estatus_preparacion, estatus_entrega, programado, fecha_programado_actual = resultado
        
        # Validaciones
        if tipo_servicio_id not in [2, 3]:
            return JsonResponse({'success': False, 'error': 'Solo se pueden programar órdenes para llevar o a domicilio'})
            
        if estatus == 'cancelada':
            return JsonResponse({'success': False, 'error': 'No se puede modificar una orden cancelada'})
            
        if estatus_preparacion in ['en_preparacion', 'lista']:
            return JsonResponse({'success': False, 'error': 'No se puede modificar la fecha de una orden que ya está en preparación o lista'})
            
        if tipo_servicio_id == 3 and estatus_entrega != 'abierta':
            return JsonResponse({'success': False, 'error': 'Solo se puede modificar la fecha de órdenes a domicilio con estatus de entrega "abierta"'})
        
        # Si pasa todas las validaciones, actualizar la fecha
        fecha_programado_actual_str = fecha_programado_actual.strftime('%Y-%m-%d %H:%M:%S') if fecha_programado_actual else "No programada"
        
        cursor.execute('''
            UPDATE ordenes
            SET fecha_programado = %s, programado = 1
            WHERE id = %s
        ''', [nueva_fecha_iso, orden_id])
        
        # Registrar la acción en el historial con las columnas correctas
        empleado_id = request.session.get('empleado_id')
        print(fecha_programado_actual_str)
        cursor.execute('''
            INSERT INTO orden_historial_estados (
                orden_id, estado_anterior, estado_nuevo, empleado_id, motivo
            ) VALUES (%s, %s, %s, %s, %s)
        ''', [
            orden_id, 
            f'FECHA_PROGRAMADA: {fecha_programado_actual_str}',
            f'FECHA_PROGRAMADA: {nueva_fecha_iso}',
            empleado_id,
            'Cambio de fecha programada'
        ])
        
        # Confirmar la transacción
        conn.commit()
        return JsonResponse({'success': True, 'mensaje': 'Fecha programada actualizada correctamente'})
            
    except Exception as e:
        # Hacer rollback en caso de error
        conn.rollback()
        return JsonResponse({'success': False, 'error': str(e)})
    finally:
        # Restaurar autocommit y cerrar cursor
        conn.autocommit = True
        cursor.close()


@csrf_exempt
@login_required
@grupos_permitidos(['Administradores', 'Cajeros'])
def cambiar_cliente(request):
    """Vista para cambiar el cliente de una orden tipo 2 (para llevar)"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        orden_id = data.get('orden_id')
        cliente_id = data.get('cliente_id')
        empleado_id = request.session['empleado_id']
        
        # Validaciones básicas
        if not orden_id or not cliente_id:
            return JsonResponse({'error': 'Datos incompletos'}, status=400)
        
        with connections['pagoda'].cursor() as cursor:
            # Iniciar transacción
            cursor.execute('START TRANSACTION')
            
            try:
                # 1. Verificar que la orden existe y su tipo de servicio
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT id, tipo_servicio_id, estatus
                    FROM ordenes
                    WHERE id = %s
                ''', [orden_id])
                
                orden = cursor.fetchone()
                if not orden:
                    cursor.execute('ROLLBACK')
                    return JsonResponse({'error': 'Orden no encontrada'}, status=404)
                
                tipo_servicio = orden[1]
                estatus = orden[2]
                
                # 2. Validar que sea tipo 2 (para llevar) y estatus por_cobrar
                if tipo_servicio != 2:
                    cursor.execute('ROLLBACK')
                    return JsonResponse({'error': 'Esta operación solo es válida para órdenes tipo "para llevar"'}, status=400)
                
                if estatus != 'por_cobrar':
                    cursor.execute('ROLLBACK')
                    return JsonResponse({'error': 'Solo se puede cambiar el cliente cuando la orden está en estado "por cobrar"'}, status=400)
                
                # 3. Verificar que el cliente existe
                cursor.execute('SET STATEMENT max_statement_time = 25 FOR SELECT id FROM clientes WHERE id = %s', [cliente_id])
                if cursor.rowcount == 0:
                    cursor.execute('ROLLBACK')
                    return JsonResponse({'error': 'El cliente seleccionado no existe'}, status=400)
                
                # 4. Actualizar la orden con el nuevo cliente
                cursor.execute('''
                    UPDATE ordenes 
                    SET cliente_id = %s
                    WHERE id = %s
                ''', [cliente_id, orden_id])
                
                # 5. Registrar el cambio en el historial
                cursor.execute('''
                    INSERT INTO orden_historial_estados (
                        orden_id, estado_anterior, estado_nuevo, empleado_id, motivo
                    ) VALUES (%s, %s, %s, %s, %s)
                ''', [
                    orden_id,
                    'CAMBIO_CLIENTE',
                    'CAMBIO_CLIENTE',
                    empleado_id,
                    'Cambio de cliente para orden para llevar'
                ])
                
                # Confirmar transacción
                cursor.execute('COMMIT')
                
                return JsonResponse({
                    'success': True,
                    'mensaje': 'Cliente actualizado correctamente'
                })
                
            except Exception as e:
                cursor.execute('ROLLBACK')
                return JsonResponse({'error': str(e)}, status=500)
    
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Formato JSON inválido'}, status=400)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@csrf_exempt
@login_required
@grupos_permitidos(['Administradores', 'Meseros','Delivery','Operadores','Rapidos'])
def cambiar_cliente_direccion(request):
    """Vista para cambiar el cliente y dirección de una orden tipo 3 (domicilio)"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        orden_id = data.get('orden_id')
        cliente_id = data.get('cliente_id')
        direccion_id = data.get('direccion_id')
        costo_entrega = data.get('costo_entrega', 0)
        empleado_id = request.session['empleado_id']
        
        # Validaciones básicas
        if not orden_id or not cliente_id or not direccion_id:
            return JsonResponse({'error': 'Datos incompletos'}, status=400)
        
        with connections['pagoda'].cursor() as cursor:
            # Iniciar transacción
            cursor.execute('START TRANSACTION')
            
            try:
                # 1. Verificar que la orden existe y su tipo de servicio
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT id, tipo_servicio_id, estatus, estatus_entrega,
                           subtotal, impuestos, costo_entrega, total
                    FROM ordenes
                    WHERE id = %s
                ''', [orden_id])
                
                orden = cursor.fetchone()
                if not orden:
                    cursor.execute('ROLLBACK')
                    return JsonResponse({'error': 'Orden no encontrada'}, status=404)
                
                tipo_servicio = orden[1]
                estatus = orden[2]
                estatus_entrega = orden[3]
                subtotal = orden[4]
                impuestos = orden[5]
                costo_entrega_actual = orden[6]
                total_actual = orden[7]
                
                # 2. Validar que sea tipo 3 (domicilio), estatus por_cobrar y estatus_entrega abierta
                if tipo_servicio != 3:
                    cursor.execute('ROLLBACK')
                    return JsonResponse({'error': 'Esta operación solo es válida para órdenes tipo "domicilio"'}, status=400)
                
                if estatus != 'por_cobrar':
                    cursor.execute('ROLLBACK')
                    return JsonResponse({'error': 'Solo se puede cambiar el cliente/dirección cuando la orden está en estado "por cobrar"'}, status=400)
                
                if estatus_entrega != 'abierta':
                    cursor.execute('ROLLBACK')
                    return JsonResponse({'error': 'Solo se puede cambiar el cliente/dirección cuando el estatus de entrega es "abierta"'}, status=400)
                
                # 3. Verificar que el cliente existe
                cursor.execute('SET STATEMENT max_statement_time = 25 FOR SELECT id FROM clientes WHERE id = %s', [cliente_id])
                if cursor.rowcount == 0:
                    cursor.execute('ROLLBACK')
                    return JsonResponse({'error': 'El cliente seleccionado no existe'}, status=400)
                
                # 4. Verificar que la dirección existe y pertenece al cliente
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT id 
                    FROM direcciones_cliente
                    WHERE id = %s AND cliente_id = %s
                ''', [direccion_id, cliente_id])
                
                if cursor.rowcount == 0:
                    cursor.execute('ROLLBACK')
                    return JsonResponse({'error': 'La dirección seleccionada no existe o no pertenece al cliente'}, status=400)
                
                # 5. Calcular nuevo total si cambió el costo de entrega
                nuevo_total = float(subtotal) + float(impuestos) + float(costo_entrega)
                
                # 6. Actualizar la orden con el nuevo cliente, dirección y costo de entrega
                cursor.execute('''
                    UPDATE ordenes 
                    SET cliente_id = %s, direccion_entrega_id = %s, costo_entrega = %s, total = %s
                    WHERE id = %s
                ''', [cliente_id, direccion_id, costo_entrega, nuevo_total, orden_id])
                
                # 7. Registrar el cambio en el historial
                cursor.execute('''
                    INSERT INTO orden_historial_estados (
                        orden_id, estado_anterior, estado_nuevo, empleado_id, motivo
                    ) VALUES (%s, %s, %s, %s, %s)
                ''', [
                    orden_id,
                    'CAMBIO_CLIENTE_DIRECCION',
                    'CAMBIO_CLIENTE_DIRECCION',
                    empleado_id,
                    'Cambio de cliente y dirección para orden a domicilio'
                ])
                
                # Registrar cambio en costo de entrega si hubo cambio
                if costo_entrega_actual != costo_entrega:
                    cursor.execute('''
                        INSERT INTO orden_historial_estados (
                            orden_id, estado_anterior, estado_nuevo, empleado_id, motivo
                        ) VALUES (%s, %s, %s, %s, %s)
                    ''', [
                        orden_id,
                        f'COSTO ENTREGA: {costo_entrega_actual}',
                        f'COSTO ENTREGA: {costo_entrega}',
                        empleado_id,
                        'Cambio de costo de entrega al actualizar dirección'
                    ])
                
                # Confirmar transacción
                cursor.execute('COMMIT')
                
                return JsonResponse({
                    'success': True,
                    'mensaje': 'Cliente, dirección y costo de entrega actualizados correctamente',
                    'nuevo_total': nuevo_total
                })
                
            except Exception as e:
                cursor.execute('ROLLBACK')
                return JsonResponse({'error': str(e)}, status=500)
    
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Formato JSON inválido'}, status=400)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)        

@csrf_exempt
@login_required
@grupos_permitidos(['Administradores', 'Meseros','Delivery','Operadores','Rapidos'])
def cambiar_tipo_servicio(request):
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        orden_id = data.get('orden_id')
        nuevo_tipo = data.get('nuevo_tipo')
        mesa_id = data.get('mesa_id')
        direccion_id = data.get('direccion_id')
        cliente_id = data.get('cliente_id')
        tipo_actual = data.get('tipo_actual')
        costo_entrega = data.get('costo_entrega', 0)
        pagos_ajustados = data.get('pagos_ajustados', None)
        empleado_id = request.session['empleado_id']
        nombre_tk = data.get('nombre_tk', '')  # Nueva variable para referencia

        # Validaciones básicas
        if not orden_id or not nuevo_tipo:
            return JsonResponse({'error': 'Datos incompletos'}, status=400)
        
        
        with connections['pagoda'].cursor() as cursor:
            # 1. Verificar que la orden existe y obtener información
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT id, tipo_servicio_id, mesa_id, direccion_entrega_id, 
                       estatus, estatus_entrega, programado, fecha_programado, subtotal, impuestos, costo_entrega, total,
                       nombre_tk
                FROM ordenes
                WHERE id = %s
            ''', [orden_id])
            
            orden = cursor.fetchone()
            if not orden:
                return JsonResponse({'error': 'Orden no encontrada'}, status=404)
            
            tipo_servicio_actual = orden[1]
            mesa_actual = orden[2]
            estatus_actual = orden[4]
            estatus_entrega = orden[5]
            programado_actual = orden[6]
            fecha_programado_actual = orden[7]
            subtotal_actual = orden[8]
            impuestos_actual = orden[9]
            costo_entrega_actual = orden[10]
            total_actual = orden[11]
            nombre_tk_actual = orden[12]
            
            # Validar el costo de entrega para domicilio
            if nuevo_tipo == 3:  # Domicilio
                if costo_entrega is None or costo_entrega < 0:
                    return JsonResponse({'error': 'El costo de entrega debe ser un valor válido para servicio a domicilio'}, status=400)
            
            # 2. Validaciones de estatus según tipo actual
            if tipo_servicio_actual in [1, 4]:  # Tipo 1 actual (comedor)
                if estatus_actual != 'abierta':
                    return JsonResponse({
                        'error': 'Solo se puede cambiar de tipo de servicio 1 cuando la orden está abierta'
                    }, status=400)
            
            elif tipo_servicio_actual in [2, 3]:  # Tipo 2, 3 o 4 actual
                if estatus_actual != 'por_cobrar':
                    return JsonResponse({
                        'error': 'Solo se puede cambiar de tipo de servicio 2, 3 o 4 cuando la orden está por cobrar'
                    }, status=400)
                
                # Validación adicional para tipo 3
                if tipo_servicio_actual == 3 and estatus_entrega != 'abierta':
                    return JsonResponse({
                        'error': 'Solo se puede cambiar de tipo de servicio 3 cuando el estatus de entrega es abierto'
                    }, status=400)
            
            # 3. Validaciones específicas para el nuevo tipo de servicio
            if nuevo_tipo == 1:  # Comedor
                if not mesa_id:
                    return JsonResponse({'error': 'Debe especificar una mesa para servicio en comedor'}, status=400)
                
                # Verificar disponibilidad de la mesa
                cursor.execute('SET STATEMENT max_statement_time = 25 FOR SELECT estatus FROM mesas WHERE id = %s', [mesa_id])
                mesa = cursor.fetchone()
                if not mesa or mesa[0] != 'disponible':
                    return JsonResponse({'error': 'La mesa seleccionada no está disponible'}, status=400)
            
            elif nuevo_tipo == 2:  # Para llevar
                if not cliente_id:
                    return JsonResponse({'error': 'Debe especificar un cliente para servicio para llevar'}, status=400)
                
                # Validar nombre_tk para cliente general (ID=1)
                if int(cliente_id) == 1 and not nombre_tk:
                    return JsonResponse({'error': 'Debe especificar una referencia para el cliente general'}, status=400)
            
            elif nuevo_tipo == 3:  # Domicilio
                if not cliente_id:
                    return JsonResponse({'error': 'Debe especificar un cliente para servicio a domicilio'}, status=400)
                    
                if not direccion_id:
                    return JsonResponse({'error': 'Debe especificar una dirección para servicio a domicilio'}, status=400)
            
            elif nuevo_tipo == 4:  # Comedor programado
                # Para tipo 4, el cliente siempre debe ser ID=1 (público general)
                cliente_id = 1
                
                # Validar que tenga nombre_tk
                if not nombre_tk:
                    return JsonResponse({'error': 'Debe especificar una referencia para el pedido programado'}, status=400)
            
            # 4. Verificar si hay pagos asociados
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT p.metodo_pago_id, p.monto, p.id, mp.nombre, mp.requiere_comprobacion, p.referencia
                FROM pagos p
                JOIN metodos_pago mp ON p.metodo_pago_id = mp.id
                WHERE p.orden_id = %s
                AND p.estatus = 'completado'
                ORDER BY p.fecha_pago
            ''', [orden_id])
            
            pagos = cursor.fetchall()
            tiene_un_pago = len(pagos) == 1
            tiene_dos_pagos = len(pagos) == 2
            tiene_tres_o_mas_pagos = len(pagos) >= 3
            sin_pagos = len(pagos) == 0  # Nueva variable para detectar cuando no hay pagos
            
            if tiene_tres_o_mas_pagos:
                return JsonResponse({
                    'error': 'Se detectaron tres o más registros de método de pago. Para poder continuar debe cancelar primero esos pagos.',
                    'message': 'Se detectaron tres o más registros de método de pago. Para poder continuar debe cancelar primero esos pagos.',
                    'pagos_count': len(pagos)
                }, status=400)
            
            # 5. Establecer nuevo costo de entrega y recalcular totales
            nuevo_costo_entrega = 0
            
            if nuevo_tipo == 3:  # Si cambia A domicilio
                nuevo_costo_entrega = float(costo_entrega)
            else:  # Si cambia DE domicilio a otro tipo, o cualquier otro cambio
                nuevo_costo_entrega = 0
            
            # Calcular nuevo total
            nuevo_total = float(subtotal_actual) + float(impuestos_actual) + nuevo_costo_entrega
            
            # 6. Si tiene dos pagos y no se recibieron pagos_ajustados, devolver datos para mostrar modal
            if tiene_dos_pagos and not pagos_ajustados and estatus_actual == 'por_cobrar':
                # Obtener información detallada de las formas de pago
                metodos_pago = []
                for pago in pagos:
                    metodo_id, monto, pago_id, nombre, requiere_comprobacion, referencia = pago
                    metodos_pago.append({
                        'metodo_id': metodo_id,
                        'nombre': nombre,
                        'monto': float(monto),
                        'pago_id': pago_id,
                        'requiere_comprobacion': requiere_comprobacion,
                        'referencia': referencia or ''
                    })
                
                # Retornar respuesta especial para ajuste de pagos en frontend
                return JsonResponse({
                    'success': False,
                    'requiere_ajuste_pagos': True,
                    'message': 'Se detectaron dos formas de pago. Es necesario ajustar la distribución.',
                    'pagos': metodos_pago,
                    'total_anterior': float(total_actual),
                    'total_nuevo': nuevo_total,
                    'accion': 'cambiar_tipo_servicio',
                    'orden_id': orden_id,
                    'nuevo_tipo': nuevo_tipo,
                    'mesa_id': mesa_id,
                    'direccion_id': direccion_id,
                    'cliente_id': cliente_id,
                    'tipo_actual': tipo_actual,
                    'costo_entrega': costo_entrega,
                    'nombre_tk': nombre_tk
                })
            
            # Iniciar transacción
            cursor.execute('START TRANSACTION')
            
            try:
                # 7. Liberar mesa actual si es necesario
                if tipo_servicio_actual == 1 and mesa_actual:
                    cursor.execute('''
                        UPDATE mesas SET estatus = 'disponible' WHERE id = %s
                    ''', [mesa_actual])
                
                # 8. Determinar el nuevo estatus de la orden
                nuevo_estatus = estatus_actual
                
                # Si cambia de tipo 1 a otro tipo, poner en 'por_cobrar'
                if tipo_servicio_actual in [1, 4] and nuevo_tipo in [2, 3]:
                    nuevo_estatus = 'por_cobrar'
                
                # Si cambia de tipo 2, 3a tipo 1 o 4, poner en 'abierta'
                if tipo_servicio_actual in [1, 2, 3, 4] and nuevo_tipo == 1 or nuevo_tipo == 4:
                    nuevo_estatus = 'abierta'
                
                # 9. Actualizar tipo de servicio y campos relacionados
                update_query = 'UPDATE ordenes SET tipo_servicio_id = %s, estatus = %s, costo_entrega = %s, total = %s'
                update_params = [nuevo_tipo, nuevo_estatus, nuevo_costo_entrega, nuevo_total]
                
                # Registrar cambio de programación si la orden estaba programada y cambia a tipo 1
                registro_programacion = None
                if programado_actual == 1 and nuevo_tipo == 1:
                    fecha_programado_str = fecha_programado_actual.strftime('%Y-%m-%d %H:%M:%S') if fecha_programado_actual else "N/A"
                    registro_programacion = f'PROGRAMACIÓN: De {fecha_programado_str} a NULL'
                
                # Manejar nombre_tk para tipos 2 y 4 con cliente general
                if (nuevo_tipo == 2 or nuevo_tipo == 4) and int(cliente_id) == 1 and nombre_tk:
                    update_query += ', nombre_tk = %s'
                    update_params.append(nombre_tk)
                
                if nuevo_tipo == 1:  # Comedor
                    # Limpiar programación y fecha al cambiar a tipo 1
                    update_query += ', mesa_id = %s, direccion_entrega_id = NULL, cliente_id = NULL, empleado_id = 10, programado = 0, fecha_programado = NULL, nombre_tk = NULL'
                    update_params.append(mesa_id)
                    
                    # Marcar la nueva mesa como ocupada
                    cursor.execute('UPDATE mesas SET estatus = "ocupada" WHERE id = %s', [mesa_id])
                    
                elif nuevo_tipo == 2:  # Para llevar
                    update_query += ', mesa_id = NULL, direccion_entrega_id = NULL, cliente_id = %s'
                    update_params.append(cliente_id)
                    
                elif nuevo_tipo == 3:  # Domicilio
                    update_query += ', mesa_id = NULL, direccion_entrega_id = %s, cliente_id = %s, nombre_tk = NULL, estatus_entrega = "abierta" '
                    update_params.extend([direccion_id, cliente_id])
                
                elif nuevo_tipo == 4:  # Comedor programado
                    # Para tipo 4, mantener programado y fecha_programado si existen
                    if programado_actual == 1 and fecha_programado_actual:
                        update_query += ', mesa_id = NULL, direccion_entrega_id = NULL, cliente_id = %s, programado = 1, fecha_programado = %s'
                        update_params.extend([cliente_id, fecha_programado_actual])
                    else:
                        update_query += ', mesa_id = NULL, direccion_entrega_id = NULL, cliente_id = %s, programado = 1, fecha_programado = NOW()'
                        update_params.append(cliente_id)
                
                update_query += ' WHERE id = %s'
                update_params.append(orden_id)
                
                cursor.execute(update_query, update_params)
                
                # 10. Manejar los pagos:
                # - Si hay un solo pago: actualizar su monto
                # - Si hay dos pagos y se recibieron pagos_ajustados: cancelar los existentes y crear nuevos
                # - NUEVO: Si no hay pagos y cambia a tipo 2 o 3: crear un pago automático
                
                if tiene_un_pago and estatus_actual == 'por_cobrar':
                    metodo_pago_id, monto_pago, pago_id = pagos[0][0:3]
                    
                    cursor.execute('''
                        UPDATE pagos
                        SET monto = %s,
                            actualizado_en = NOW()
                        WHERE id = %s
                    ''', [nuevo_total, pago_id])
                
                # Si hay dos pagos y se recibieron pagos ajustados, actualizar los pagos
                elif tiene_dos_pagos and pagos_ajustados and estatus_actual == 'por_cobrar':
                    empleado_id = request.session.get('empleado_id')
                    
                    # Verificar que la suma de los pagos ajustados coincide con el nuevo total
                    total_pagos_ajustados = sum(float(pago.get('monto', 0)) for pago in pagos_ajustados)
                    
                    # Validar que la suma coincida (con un margen de error de 0.01)
                    if abs(total_pagos_ajustados - nuevo_total) > 0.01:
                        cursor.execute('ROLLBACK')
                        return JsonResponse({
                            'success': False,
                            'error': 'montos_incorrectos',
                            'message': 'La suma de los montos ajustados no coincide con el total de la orden'
                        }, status=400)
                    
                    # Cancelar pagos existentes
                    cursor.execute('''
                        UPDATE pagos 
                        SET estatus = 'cancelado', 
                            fecha_cancelacion = NOW()
                        WHERE orden_id = %s 
                        AND estatus = 'completado'
                    ''', [orden_id])
                    
                    # Crear nuevos pagos con los montos ajustados
                    for pago in pagos_ajustados:
                        cursor.execute('''
                            INSERT INTO pagos (
                                orden_id, metodo_pago_id, empleado_id,
                                monto, referencia, estatus, fecha_pago
                            ) VALUES (%s, %s, %s, %s, %s, %s, NOW())
                        ''', [
                            orden_id, pago.get('metodo_id'), empleado_id,
                            pago.get('monto'), pago.get('referencia', ''), 'completado'
                        ])
                
                # NUEVO: Si no hay pagos y se cambia a tipo 2 o 3, crear pago automático
                elif sin_pagos and nuevo_tipo in [2, 3] and nuevo_estatus == 'por_cobrar':
                    # Obtener la forma de pago predeterminada del cliente
                    metodo_pago_id = 1  # Valor predeterminado si no existe
                    
                    if cliente_id and int(cliente_id) > 0:
                        cursor.execute('''
                            SET STATEMENT max_statement_time = 25 FOR
                            SELECT forma_pago_predeterminada FROM clientes WHERE id = %s
                        ''', [cliente_id])
                        
                        cliente_info = cursor.fetchone()
                        if cliente_info and cliente_info[0]:
                            metodo_pago_id = cliente_info[0]
                    
                    # Insertar el pago automático
                    cursor.execute('''
                        INSERT INTO pagos (
                            orden_id, metodo_pago_id, empleado_id,
                            monto, estatus, fecha_pago,
                            creado_en, actualizado_en
                        ) VALUES (%s, %s, %s, %s, %s, NOW(), NOW(), NOW())
                    ''', [
                        orden_id, metodo_pago_id, empleado_id,
                        nuevo_total, 'completado'
                    ])
                
                # 11. Registrar el cambio en el historial
                cursor.execute('''
                    INSERT INTO orden_historial_estados (
                        orden_id, estado_anterior, estado_nuevo, empleado_id, motivo
                    ) VALUES (%s, %s, %s, %s, %s)
                ''', [
                    orden_id,
                    f'Tipo {tipo_servicio_actual}-{estatus_actual}',
                    f'Tipo {nuevo_tipo}-{nuevo_estatus}',
                    empleado_id,
                    f'Cambio de tipo de servicio: de {tipo_servicio_actual} a {nuevo_tipo}'
                ])
                
                # Registrar cambio en costo de entrega si hubo cambio
                if costo_entrega_actual != nuevo_costo_entrega:
                    cursor.execute('''
                        INSERT INTO orden_historial_estados (
                            orden_id, estado_anterior, estado_nuevo, empleado_id, motivo
                        ) VALUES (%s, %s, %s, %s, %s)
                    ''', [
                        orden_id,
                        f'COSTO ENTREGA: {costo_entrega_actual}',
                        f'COSTO ENTREGA: {nuevo_costo_entrega}',
                        empleado_id,
                        f'Cambio de costo de entrega por cambio de tipo de servicio'
                    ])
                
                # Registrar cambio de programación en el historial si aplica
                if registro_programacion:
                    cursor.execute('''
                        INSERT INTO orden_historial_estados (
                            orden_id, estado_anterior, estado_nuevo, empleado_id, motivo
                        ) VALUES (%s, %s, %s, %s, %s)
                    ''', [
                        orden_id,
                        f'PROGRAMADO: {programado_actual}',
                        'PROGRAMADO: 0',
                        empleado_id,
                        'Eliminación de programación por cambio a servicio de comedor'
                    ])
                
                # Confirmar transacción
                cursor.execute('COMMIT')
                
                return JsonResponse({
                    'success': True,
                    'mensaje': 'Tipo de servicio actualizado correctamente',
                    'mesa_liberada': mesa_actual if tipo_servicio_actual == 1 else None,
                    'mesa_asignada': mesa_id if nuevo_tipo == 1 else None,
                    'nuevo_estatus': nuevo_estatus,
                    'estatus_cambiado': estatus_actual != nuevo_estatus,
                    'programacion_eliminada': True if registro_programacion else False,
                    'nuevo_total': nuevo_total,
                    'costo_entrega_modificado': costo_entrega_actual != nuevo_costo_entrega,
                    'pago_automatico_creado': sin_pagos and nuevo_tipo in [2, 3]
                })
                
            except Exception as e:
                cursor.execute('ROLLBACK')
                return JsonResponse({'error': str(e)}, status=500)
    
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Formato JSON inválido'}, status=400)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
@grupos_permitidos(['Administradores', 'Meseros'])
def mesas_disponibles(request):
    """Obtener todas las mesas disponibles"""
    with connections['pagoda'].cursor() as cursor:
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT m.id, m.numero, m.capacidad, m.estatus, a.nombre as area
            FROM mesas m
            JOIN areas a ON m.area_id = a.id
            WHERE m.estatus = 'disponible'
            ORDER BY a.nombre, m.numero
        ''')
        mesas = dictfetchall(cursor)
    
    return JsonResponse(mesas, safe=False)


@csrf_exempt
@login_required
@grupos_permitidos(['Administradores', 'Meseros'])
def cambiar_mesa(request):
    """Vista para cambiar una orden de una mesa a otra"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        orden_id = data.get('orden_id')
        nueva_mesa_id = data.get('nueva_mesa_id')
        empleado_id = request.session['empleado_id']
        
        if not orden_id or not nueva_mesa_id:
            return JsonResponse({'error': 'Datos incompletos'}, status=400)
        
        with connections['pagoda'].cursor() as cursor:
            # Iniciar transacción
            cursor.execute('START TRANSACTION')
            
            try:
                # Verificar que la orden existe y está abierta
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT id, mesa_id, tipo_servicio_id, estatus
                    FROM ordenes
                    WHERE id = %s
                ''', [orden_id])
                
                orden = cursor.fetchone()
                if not orden:
                    cursor.execute('ROLLBACK')
                    return JsonResponse({'error': 'Orden no encontrada'}, status=404)
                
                if orden[3] != 'abierta':
                    cursor.execute('ROLLBACK')
                    return JsonResponse({'error': 'Solo se puede cambiar la mesa en órdenes abiertas'}, status=400)
                
                if orden[2] != 1:  # Verificar que es servicio de comedor
                    cursor.execute('ROLLBACK')
                    return JsonResponse({'error': 'Solo se puede cambiar mesa en servicio de comedor'}, status=400)
                
                mesa_actual = orden[1]
                
                # Verificar que la nueva mesa está disponible
                cursor.execute('SET STATEMENT max_statement_time = 25 FOR SELECT estatus FROM mesas WHERE id = %s', [nueva_mesa_id])
                mesa = cursor.fetchone()
                if not mesa or mesa[0] != 'disponible':
                    cursor.execute('ROLLBACK')
                    return JsonResponse({'error': 'La mesa seleccionada no está disponible'}, status=400)
                
                # Liberar mesa actual
                if mesa_actual:
                    cursor.execute('UPDATE mesas SET estatus = "disponible" WHERE id = %s', [mesa_actual])
                
                # Actualizar orden con nueva mesa
                cursor.execute('UPDATE ordenes SET mesa_id = %s WHERE id = %s', [nueva_mesa_id, orden_id])
                
                # Marcar nueva mesa como ocupada
                cursor.execute('UPDATE mesas SET estatus = "ocupada" WHERE id = %s', [nueva_mesa_id])
                
                # Registrar en historial
                cursor.execute('''
                    INSERT INTO orden_historial_estados (
                        orden_id, estado_anterior, estado_nuevo, empleado_id, motivo
                    ) VALUES (%s, %s, %s, %s, %s)
                ''', [
                    orden_id,
                    'Mesa ' + str(mesa_actual),
                    'Mesa ' + str(nueva_mesa_id),
                    empleado_id,
                    'Cambio de mesa'
                ])
                
                # Confirmar transacción
                cursor.execute('COMMIT')
                
                return JsonResponse({
                    'success': True,
                    'mensaje': 'Mesa cambiada correctamente',
                    'mesa_liberada': mesa_actual,
                    'mesa_asignada': nueva_mesa_id
                })
                
            except Exception as e:
                cursor.execute('ROLLBACK')
                return JsonResponse({'error': str(e)}, status=500)
    
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Formato JSON inválido'}, status=400)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)
    
from .models import Repartidores, Empleados

@login_required
@grupos_permitidos(['Administradores','Ruteador'])
def lista_repartidores(request):
    """Vista para listar repartidores usando ORM"""
    repartidores = Repartidores.objects.select_related('empleado').all().order_by('empleado__apellidos', 'empleado__nombre')
    
    # Si necesitas los datos en formato similar a dictfetchall
    repartidores_data = []
    for rep in repartidores:
        repartidores_data.append({
            'id': rep.id,
            'vehiculo': rep.vehiculo,
            'placas': rep.placas,
            'licencia': rep.licencia,
            'estatus': rep.estatus,
            'nombre': rep.empleado.nombre,
            'apellidos': rep.empleado.apellidos,
            'telefono': rep.empleado.telefono,
            'email': rep.empleado.email,
            'foto_url': rep.empleado.foto_url
        })
    
    return render(request, 'catalogos/repartidores/lista.html', {'repartidores': repartidores_data})

from .models import Repartidores, Empleados
from django.shortcuts import get_object_or_404
from django.utils import timezone


@login_required
@grupos_permitidos(['Administradores','Ruteador'])
def detalle_repartidor(request, repartidor_id=None):
    """Vista para ver o editar detalles del repartidor usando ORM"""
    
    # Obtener empleados para el selector
    empleados = Empleados.objects.filter(
        rol_id=6, 
        numero_django__isnull=True
    ).order_by('nombre', 'apellidos')
    
    repartidor = None
    if repartidor_id:
        repartidor = get_object_or_404(Repartidores, id=repartidor_id)
    
    if request.method == 'POST':
        empleado_id = request.POST.get('empleado_id')
        vehiculo = request.POST.get('vehiculo')
        placas = request.POST.get('placas')
        licencia = request.POST.get('licencia')
        estatus = request.POST.get('estatus', 'disponible')
        activo = request.POST.get('activo', True)
        
        if repartidor_id:
            # Actualizar repartidor existente
            repartidor.empleado_id = empleado_id
            repartidor.vehiculo = vehiculo
            repartidor.placas = placas
            repartidor.licencia = licencia
            repartidor.estatus = estatus
            repartidor.activo = bool(activo)
            repartidor.actualizado_en = timezone.now()
            repartidor.save()
        else:
            # Crear nuevo repartidor
            repartidor = Repartidores.objects.create(
                empleado_id=empleado_id,
                vehiculo=vehiculo,
                placas=placas,
                licencia=licencia,
                estatus=estatus,
                activo=bool(activo),
                creado_en=timezone.now(),
                actualizado_en=timezone.now()
            )
        
        return redirect('lista_repartidores')
    
    return render(request, 'catalogos/repartidores/detalle.html', {
        'repartidor': repartidor,
        'empleados': empleados
    })

@login_required
@grupos_permitidos(['Administradores','Ruteador'])
def desactivar_repartidor(request, repartidor_id):
    """Vista para desactivar un repartidor (eliminación lógica)"""
    print('print')
    try:
        with connections['pagoda'].cursor() as cursor:
            cursor.execute('''
                UPDATE repartidores 
                SET activo = 0, estatus = 'inactivo', actualizado_en = NOW()
                WHERE id = %s
            ''', [repartidor_id])
            
            return JsonResponse({'success': True})
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)})

@login_required
@grupos_permitidos(['Administradores','Cajeros'])
def modulo_caja(request):
    """Vista principal del módulo de caja rediseñado"""
    empleado_id = request.session.get('empleado_id')
    if not empleado_id:
        return redirect('login')
    
    with connections['default'].cursor() as cursor:
        # Verificar si el empleado tiene una caja abierta
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT cc.id as corte_id, cc.fecha_apertura, cc.monto_inicial,
                   c.id as caja_id, c.nombre as caja_nombre, 
                   CONCAT(e.nombre, ' ', e.apellidos) as empleado_apertura
            FROM cortes_caja cc
            JOIN cajas c ON cc.caja_id = c.id
            JOIN empleados e ON cc.empleado_id = e.id
            WHERE cc.empleado_id = %s AND cc.estatus = 'abierto'
            LIMIT 1
        ''', [empleado_id])
        
        resultado = dictfetchall(cursor)
        
        if not resultado:
            # No hay caja abierta
            return render(request, 'caja/modulo_caja.html', {
                'caja': None,
                'corte': None,
                'tickets': [],
                'totales': {},
                'totales_metodos': []
            })
        
        corte = resultado[0]
        caja = {
            'id': corte['caja_id'],
            'nombre': corte['caja_nombre']
        }
        
        # Obtener tickets del día para este corte
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT 
                o.id,
                o.codigo_orden,
                IFNULL(CONCAT(c.nombre," ",c.apellidos," ",ifnull(o.nombre_tk,"")),'N/A') AS cliente,
                ts.nombre AS tipo_servicio,
                ts.id AS tipo_servicio_id,
                m.numero AS mesa_numero,
                o.fecha_apertura,
                CASE 
                    WHEN o.estatus = 'cerrada' THEN 'pagada'
                    ELSE o.estatus
                END AS estatus,
                o.estatus_preparacion,
                o.estatus_entrega,
                o.total,
                CONCAT(e.nombre, ' ', e.apellidos) AS colaborador,
                IF(o.programado=1,'Programado','') AS programado,
                o.fecha_programado
            FROM ordenes o
            JOIN tipos_servicio ts ON o.tipo_servicio_id = ts.id
            LEFT JOIN mesas m ON o.mesa_id = m.id
            LEFT JOIN clientes c ON c.id = o.cliente_id
            JOIN empleados e ON o.empleado_id = e.id
            WHERE o.estatus = 'por_cobrar'
            OR o.corte_caja_id = %s
            ORDER BY o.fecha_apertura DESC
        ''', [corte['corte_id']])
        
        tickets = dictfetchall(cursor)
        
        # Obtener totales por método de pago
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT mp.nombre, mp.id as metodo_id, SUM(p.monto) as total
            FROM pagos p
            JOIN metodos_pago mp ON p.metodo_pago_id = mp.id
            JOIN ordenes o ON p.orden_id = o.id
            WHERE o.corte_caja_id = %s 
              AND p.estatus = 'completado'
              AND o.estatus = 'cerrada'
            GROUP BY mp.id
            ORDER BY mp.nombre
        ''', [corte['corte_id']])
        
        totales_metodos = dictfetchall(cursor)
        
        # Obtener totales generales
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT 
                COUNT(*) as total_tickets,
                SUM(CASE WHEN estatus = 'abierta' THEN 1 ELSE 0 END) as tickets_abiertos,
                SUM(CASE WHEN estatus = 'cerrada' THEN 1 ELSE 0 END) as tickets_pagados,
                SUM(CASE WHEN estatus = 'cancelada' THEN 1 ELSE 0 END) as tickets_cancelados,
                IFNULL(SUM(CASE WHEN estatus = 'cerrada' THEN total ELSE 0 END), 0) as total_ventas
            FROM ordenes
            WHERE corte_caja_id = %s
        ''', [corte['corte_id']])
        
        totales = dictfetchall(cursor)[0]
        
        # Calcular totales por tipo de servicio
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT 
                ts.id AS tipo_servicio_id,
                ts.nombre AS tipo_servicio,
                COUNT(o.id) AS cantidad,
                IFNULL(SUM(CASE WHEN o.estatus = 'cerrada' THEN o.total ELSE 0 END), 0) AS total_ventas
            FROM ordenes o
            JOIN tipos_servicio ts ON o.tipo_servicio_id = ts.id
            WHERE o.corte_caja_id = %s OR o.estatus = 'abierta'
            GROUP BY ts.id
        ''', [corte['corte_id']])
        
        totales_por_tipo = dictfetchall(cursor)
        
        # Calcular total en caja (efectivo inicial + ventas en efectivo)
        total_efectivo = 0
        for metodo in totales_metodos:
            if metodo['nombre'].lower() == 'efectivo':
                total_efectivo = float(metodo['total'])
                break
        
        totales['total_caja'] = float(corte['monto_inicial']) + total_efectivo
        
        # Formatear montos para mostrar
        corte['monto_inicial'] = float(corte['monto_inicial'])
        
        for ticket in tickets:
            ticket['total'] = float(ticket['total'])
            
        for metodo in totales_metodos:
            metodo['total'] = float(metodo['total'])
            
        for total_tipo in totales_por_tipo:
            total_tipo['total_ventas'] = float(total_tipo['total_ventas'])
    
    return render(request, 'caja/modulo_caja.html', {
        'caja': caja,
        'corte': corte,
        'tickets': tickets,
        'totales': totales,
        'totales_metodos': totales_metodos,
        'totales_por_tipo': totales_por_tipo
    })


@login_required
@grupos_permitidos(['Administradores','Cajeros'])
def obtener_pre_ticket(request, orden_id):
    try:
        with connections['pagoda'].cursor() as cursor:
            # Obtener datos básicos de la orden
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT
                    o.codigo_orden,
                    CONCAT(IFNULL(c.nombre, ''), ' ', IFNULL(c.apellidos, ''), ' ', IFNULL(o.nombre_tk, '')) as cliente
                FROM ordenes o
                LEFT JOIN clientes c ON o.cliente_id = c.id
                WHERE o.id = %s AND o.tipo_servicio_id = 2 AND o.estatus <> 'cerrada'
            ''', [orden_id])
            
            orden = dictfetchone(cursor)
            
            if not orden:
                return HttpResponse("<script>alert('Orden no encontrada'); window.close();</script>")
            
            # Obtener productos de la orden
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT 
                    p.nombre as producto, 
                    (od.cantidad - IFNULL(od.cancelado, 0)) as cantidad
                FROM orden_detalles od
                JOIN productos p ON od.producto_id = p.id
                WHERE od.orden_id = %s AND (od.cantidad - IFNULL(od.cancelado, 0)) > 0
                ORDER BY p.nombre
            ''', [orden_id])
            
            productos = dictfetchall(cursor)
            
            # Generar HTML del ticket
            html = """
            <!DOCTYPE html>
            <html>
            <head>
                <title>Pre-Ticket #{}</title>
                <style>
                    body {{ font-family: 'Courier New', monospace; font-size: 12px; width: 80mm; margin: 0; padding: 10px; }}
                    .header {{ text-align: center; margin-bottom: 10px; font-weight: bold; }}
                    .ticket-title {{ font-size: 14px; text-align: center; margin: 5px 0; border-top: 1px dashed #000; border-bottom: 1px dashed #000; padding: 5px 0; }}
                    .customer {{ margin-bottom: 10px; }}
                    table {{ width: 100%; border-collapse: collapse; }}
                    th, td {{ text-align: left; padding: 3px 0; }}
                    tr.item td {{ border-bottom: 1px dotted #ccc; }}
                    .quantity {{ text-align: right; width: 40px; padding-right: 10px; }}
                    .footer {{ margin-top: 10px; text-align: center; font-size: 10px; }}
                </style>
                <script>
                    window.onload = function() {{
                        window.print();
                        // Cerrar después de imprimir o después de 5 segundos
                        window.addEventListener('afterprint', function() {{ 
                            window.close(); 
                        }});
                        setTimeout(function() {{ window.close(); }}, 5000);
                    }}
                </script>
            </head>
            <body>
                <div class="header">RÁPIDOS</div>
                <div class="ticket-title">CONTROL DE ENTREGAS  #{}</div>
                <div class="customer">
                    <strong>Cliente:</strong> {}<br>
                    <strong>Fecha:</strong> {}
                </div>
                <table>
                    <thead>
                        <tr>
                            <th class="quantity">CANT</th>
                            <th>PRODUCTO</th>
                        </tr>
                    </thead>
                    <tbody>
            """.format(orden['codigo_orden'], orden['codigo_orden'], orden['cliente'].strip(), datetime.now().strftime("%d/%m/%Y %H:%M:%S"))
            
            # Añadir productos
            for producto in productos:
                html += """
                        <tr class="item">
                            <td class="quantity">{}</td>
                            <td>{}</td>
                        </tr>
                """.format(producto['cantidad'], producto['producto'])
            
            # Cerrar HTML
            html += """
                    </tbody>
                </table>
                <div class="footer">
                    --- Control interno - No válido como ticket ---<br>
                    Impreso: {}
                </div>
            </body>
            </html>
            """.format(datetime.now().strftime("%H:%M:%S"))
            
            return HttpResponse(html)
    
    except Exception as e:
        return HttpResponse("<script>alert('Error: {}'); window.close();</script>".format(str(e)))

@login_required
@grupos_permitidos(['Administradores','Cajeros'])
def liquidacion_repartidores(request):
    """Vista para liquidación de pedidos a domicilio"""
    empleado_id = request.session.get('empleado_id')
    if not empleado_id:
        return redirect('login')
    
    # Parámetros de filtro
    fecha = request.GET.get('fecha', datetime.now().strftime('%Y-%m-%d'))
    corte_id = request.GET.get('corte_id', None)
    
    with connections['pagoda'].cursor() as cursor:
        # Verificar si el empleado tiene una caja abierta para poder hacer liquidaciones
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT cc.id as corte_id
            FROM cortes_caja cc
            WHERE cc.empleado_id = %s AND cc.estatus = 'abierto'
            LIMIT 1
        ''', [empleado_id])
        
        corte_actual = dictfetchone(cursor)
        if not corte_actual:
            messages.error(request, "Debe abrir una caja para poder realizar liquidaciones.")
            return redirect('modulo_caja')
        
        corte_id = corte_actual['corte_id']
        
        # Obtener todos los repartidores activos
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT 
                re.id as repartidor_id, 
                CONCAT(e.nombre, ' ', e.apellidos) as nombre,
                e.estatus
            FROM repartidores re
            INNER JOIN empleados e on e.id = re.empleado_id
            AND e.estatus = 'activo'
            ORDER BY e.nombre
        ''')
        
        repartidores = dictfetchall(cursor)
        
        # Para cada repartidor, obtener sus tickets de domicilio
        for repartidor in repartidores:
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT 
                    o.id,
                    o.codigo_orden,
                    IFNULL(CONCAT(c.nombre, ' ', c.apellidos), 'N/A') as cliente,
                    (SELECT CONCAT(calle, ' ', numero_exterior, ', ', colonia)
                     FROM direcciones_cliente
                     WHERE id = o.direccion_entrega_id) as direccion_entrega,
                    o.fecha_apertura,
                    o.estatus,
                    o.total,
                    COALESCE((SELECT SUM(monto) 
                             FROM pagos 
                             WHERE orden_id = o.id 
                             AND metodo_pago_id = 4
                             AND estatus = 'completado'), 0) as pago_transferencia,
                    COALESCE((SELECT SUM(monto) 
                             FROM pagos 
                             WHERE orden_id = o.id 
                             AND metodo_pago_id = 6
                             AND estatus = 'completado'), 0) as pago_credito,
                    COALESCE((SELECT SUM(monto) 
                             FROM pagos 
                             WHERE orden_id = o.id 
                             AND metodo_pago_id = 1
                             AND estatus = 'completado'), 0) as pago_efectivo
                FROM ordenes o
                LEFT JOIN clientes c ON o.cliente_id = c.id
                WHERE o.repartidor_id = %s
                AND o.tipo_servicio_id = 3
                AND (o.estatus = 'cerrada' OR o.estatus = 'por_cobrar')
                AND DATE(o.fecha_apertura) = %s
            ''', [repartidor['repartidor_id'], fecha])
            
            tickets = dictfetchall(cursor)
            
            # Calcular totales por repartidor
            total_transferencias = 0
            credito_comprobado = 0   # Crédito ya pagado en tickets cerrados
            credito_a_comprobar = 0  # Crédito en tickets por cobrar
            efectivo_comprobado = 0  # Efectivo ya pagado en tickets cerrados
            efectivo_a_liquidar = 0  # Efectivo pendiente en tickets por cobrar
            
            for ticket in tickets:
                total_transferencias += float(ticket['pago_transferencia'])
                
                if ticket['estatus'] == 'cerrada':
                    # Para tickets cerrados: contar pagos como comprobados
                    credito_comprobado += float(ticket['pago_credito'])
                    efectivo_comprobado += float(ticket['pago_efectivo'])
                else:  # por_cobrar
                    # Para tickets por cobrar:
                    # 1. El crédito a comprobar es lo que ya está registrado como pagado en crédito
                    credito_a_comprobar += float(ticket['pago_credito'])
                    
                    # 2. Efectivo a liquidar es el total menos otros pagos (transferencia y crédito)
                    otros_pagos = float(ticket['pago_transferencia']) + float(ticket['pago_credito'])
                    efectivo_a_liquidar += float(ticket['total']) - otros_pagos
            
            # Almacenar los datos calculados de forma separada
            repartidor['tickets'] = tickets
            repartidor['total_tickets'] = len(tickets)
            repartidor['total_transferencias'] = total_transferencias
            repartidor['credito_comprobado'] = credito_comprobado
            repartidor['credito_a_comprobar'] = credito_a_comprobar
            repartidor['efectivo_comprobado'] = efectivo_comprobado
            repartidor['efectivo_a_liquidar'] = efectivo_a_liquidar
        
        # Obtener tickets sin asignar a repartidor
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT 
                o.id,
                o.codigo_orden,
                IFNULL(CONCAT(c.nombre, ' ', c.apellidos), 'N/A') as cliente,
                (SELECT CONCAT(calle, ' ', numero_exterior, ', ', colonia)
                 FROM direcciones_cliente
                 WHERE id = o.direccion_entrega_id) as direccion_entrega,
                o.fecha_apertura,
                o.estatus,
                o.total,
                COALESCE((SELECT SUM(monto) 
                         FROM pagos 
                         WHERE orden_id = o.id 
                         AND metodo_pago_id = 4
                         AND estatus = 'completado'), 0) as pago_transferencia,
                COALESCE((SELECT SUM(monto) 
                         FROM pagos 
                         WHERE orden_id = o.id 
                         AND metodo_pago_id = 6
                         AND estatus = 'completado'), 0) as pago_credito,
                COALESCE((SELECT SUM(monto) 
                         FROM pagos 
                         WHERE orden_id = o.id 
                         AND metodo_pago_id = 1
                         AND estatus = 'completado'), 0) as pago_efectivo
            FROM ordenes o
            LEFT JOIN clientes c ON o.cliente_id = c.id
            WHERE o.tipo_servicio_id = 3
            AND (o.repartidor_id IS NULL OR o.repartidor_id = 0)
            AND (o.estatus = 'cerrada' OR o.estatus = 'por_cobrar')
            AND DATE(o.fecha_apertura) = %s
        ''', [fecha])
        
        tickets_sin_asignar = dictfetchall(cursor)
        
        # Calcular totales para tickets sin asignar
        total_transferencias_sin_asignar = 0
        credito_comprobado_sin_asignar = 0
        credito_a_comprobar_sin_asignar = 0
        efectivo_comprobado_sin_asignar = 0
        efectivo_a_liquidar_sin_asignar = 0
        
        for ticket in tickets_sin_asignar:
            total_transferencias_sin_asignar += float(ticket['pago_transferencia'])
            
            if ticket['estatus'] == 'cerrada':
                # Para tickets cerrados: contar pagos como comprobados
                credito_comprobado_sin_asignar += float(ticket['pago_credito'])
                efectivo_comprobado_sin_asignar += float(ticket['pago_efectivo'])
            else:  # por_cobrar
                # Para tickets por cobrar:
                credito_a_comprobar_sin_asignar += float(ticket['pago_credito'])
                
                otros_pagos = float(ticket['pago_transferencia']) + float(ticket['pago_credito'])
                efectivo_a_liquidar_sin_asignar += float(ticket['total']) - otros_pagos
        
        # Calcular totales globales
        total_tickets = sum(r['total_tickets'] for r in repartidores) + len(tickets_sin_asignar)
        total_transferencias = sum(r['total_transferencias'] for r in repartidores) + total_transferencias_sin_asignar
        total_credito_comprobado = sum(r['credito_comprobado'] for r in repartidores) + credito_comprobado_sin_asignar
        total_credito_a_comprobar = sum(r['credito_a_comprobar'] for r in repartidores) + credito_a_comprobar_sin_asignar
        total_efectivo_comprobado = sum(r['efectivo_comprobado'] for r in repartidores) + efectivo_comprobado_sin_asignar
        total_efectivo_a_liquidar = sum(r['efectivo_a_liquidar'] for r in repartidores) + efectivo_a_liquidar_sin_asignar
        total_ventas = total_transferencias + total_credito_comprobado + total_credito_a_comprobar + total_efectivo_comprobado + total_efectivo_a_liquidar
    
    return render(request, 'caja/liquidacion_repartidores.html', {
        'repartidores': repartidores,
        'tickets_sin_asignar': tickets_sin_asignar,
        'total_sin_asignar': len(tickets_sin_asignar),
        'total_transferencias_sin_asignar': total_transferencias_sin_asignar,
        'credito_comprobado_sin_asignar': credito_comprobado_sin_asignar,
        'credito_a_comprobar_sin_asignar': credito_a_comprobar_sin_asignar,
        'efectivo_comprobado_sin_asignar': efectivo_comprobado_sin_asignar,
        'efectivo_a_liquidar_sin_asignar': efectivo_a_liquidar_sin_asignar,
        'fecha': fecha,
        'total_tickets': total_tickets,
        'total_transferencias': total_transferencias,
        'total_credito_comprobado': total_credito_comprobado,
        'total_credito_a_comprobar': total_credito_a_comprobar,
        'total_efectivo_comprobado': total_efectivo_comprobado,
        'total_efectivo_a_liquidar': total_efectivo_a_liquidar,
        'total_ventas': total_ventas,
        'corte_id': corte_id
    })



@login_required
def liquidar_repartidor(request, repartidor_id):
    """Función para liquidar todos los tickets de un repartidor"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    empleado_id = request.session.get('empleado_id')
    fecha = request.POST.get('fecha', datetime.now().strftime('%Y-%m-%d'))
    corte_id = request.POST.get('corte_id')
    
    if not corte_id:
        return JsonResponse({'error': 'No hay un corte de caja abierto'}, status=400)
    
    with connections['pagoda'].cursor() as cursor:
        # Verificar que el corte esté abierto
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT id FROM cortes_caja
            WHERE id = %s AND estatus = 'abierto'
        ''', [corte_id])
        
        if cursor.rowcount == 0:
            return JsonResponse({'error': 'El corte de caja no está abierto'}, status=400)
        
        # Obtener los tickets a liquidar
        if repartidor_id == 'sin_asignar':
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT o.id, o.total, o.codigo_orden
                FROM ordenes o
                WHERE (o.repartidor_id IS NULL OR o.repartidor_id = 0)
                AND o.tipo_servicio_id = 3
                AND o.estatus = 'por_cobrar'
                AND DATE(o.fecha_apertura) = %s
            ''', [fecha])
        else:
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT o.id, o.total, o.codigo_orden
                FROM ordenes o
                WHERE o.repartidor_id = %s
                AND o.tipo_servicio_id = 3
                AND o.estatus = 'por_cobrar'
                AND DATE(o.fecha_apertura) = %s
            ''', [repartidor_id, fecha])
        
        tickets = dictfetchall(cursor)
        
        if not tickets:
            return JsonResponse({'success': False, 'message': 'No hay tickets pendientes para liquidar'})
        
        # Iniciar transacción
        with transaction.atomic():
            for ticket in tickets:
                ticket_id = ticket['id']
                total = float(ticket['total'])
                
                # Obtener pagos previos que no son en efectivo
                cursor.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT COALESCE(SUM(monto), 0) as pagos_previos
                    FROM pagos
                    WHERE orden_id = %s
                    AND metodo_pago_id != 1
                    AND estatus = 'completado'
                ''', [ticket_id])
                
                result = cursor.fetchone()
                pagos_previos = float(result[0]) if result and result[0] else 0
                
                # Calcular monto por liquidar en efectivo
                monto_efectivo = total - pagos_previos
                
                if monto_efectivo > 0:
                    # Registrar pago en efectivo
                    cursor.execute('''
                        INSERT INTO pagos (
                            orden_id, metodo_pago_id, monto, fecha_pago, 
                            empleado_id, referencia, estatus, corte_caja_id
                        ) VALUES (
                            %s, 1, %s, NOW(), %s, 'Liquidación de repartidor', 'completado', %s
                        )
                    ''', [ticket_id, monto_efectivo, empleado_id, corte_id])
                
                # Actualizar estado del ticket a cerrado
                cursor.execute('''
                    UPDATE ordenes
                    SET estatus = 'cerrada', fecha_cierre = NOW()
                    WHERE id = %s
                ''', [ticket_id])
        
        # Obtener nombre del repartidor para el mensaje
        if repartidor_id == 'sin_asignar':
            nombre_repartidor = "tickets sin asignar"
        else:
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT CONCAT(nombre, ' ', apellidos) as nombre
                FROM empleados
                WHERE id = %s
            ''', [repartidor_id])
            
            result = cursor.fetchone()
            nombre_repartidor = result[0] if result else "repartidor"
    
    return JsonResponse({
        'success': True, 
        'message': f'Se han liquidado {len(tickets)} tickets de {nombre_repartidor}',
        'tickets_liquidados': len(tickets)
    })


@csrf_exempt
@login_required
def get_max_position(request, ruta_id):
    """API para obtener la posición máxima actual en una ruta"""
    if request.method != 'GET':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        with connections['pagoda'].cursor() as cursor:
            # Obtener la posición máxima actual
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT COALESCE(MAX(posicion_en_bloque), 0) as max_position
                FROM ordenes 
                WHERE bloque_ruta_id = %s
            ''', [ruta_id])
            
            result = dictfetchone(cursor)
            max_position = result['max_position'] if result else 0
            
            return JsonResponse({
                'success': True,
                'max_position': max_position
            })
            
    except Exception as e:
        print(f"ERROR EN GET MAX POSITION: {str(e)}")
        return JsonResponse({'error': str(e)}, status=500)
    
@csrf_exempt
@login_required
def incrementar_posiciones(request):
    """API para incrementar todas las posiciones en una ruta"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        ruta_id = data.get('ruta_id')
        
        if not ruta_id:
            return JsonResponse({'error': 'ID de ruta es obligatorio'}, status=400)
        
        with connections['pagoda'].cursor() as cursor:
            # Incrementar todas las posiciones en 1
            cursor.execute('''
                UPDATE ordenes
                SET posicion_en_bloque = posicion_en_bloque + 1
                WHERE bloque_ruta_id = %s
            ''', [ruta_id])
            
            return JsonResponse({
                'success': True,
                'affected_rows': cursor.rowcount
            })
            
    except Exception as e:
        print(f"ERROR EN INCREMENTAR POSICIONES: {str(e)}")
        return JsonResponse({'error': str(e)}, status=500)

@csrf_exempt
@login_required
def reordenar_pedidos(request):
    """API para reordenar los pedidos dentro de una ruta"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        ruta_id = data.get('ruta_id')
        orden_id = data.get('orden_id')
        nueva_posicion = data.get('nueva_posicion')
        
        if not ruta_id or not orden_id or nueva_posicion is None:
            return JsonResponse({'error': 'Faltan parámetros requeridos'}, status=400)
        
        with connections['pagoda'].cursor() as cursor:
            # Primero obtenemos la posición actual del pedido
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT posicion_en_bloque
                FROM ordenes
                WHERE id = %s AND bloque_ruta_id = %s
            ''', [orden_id, ruta_id])
            
            result = dictfetchone(cursor)
            if not result:
                return JsonResponse({'error': 'El pedido no pertenece a esta ruta'}, status=400)
            
            posicion_actual = result['posicion_en_bloque']
            
            # Si la posición no cambia, no hacemos nada
            if posicion_actual == nueva_posicion:
                return JsonResponse({'success': True, 'message': 'La posición no ha cambiado'})
            
            # Reordenar los pedidos afectados
            if nueva_posicion < posicion_actual:
                # Moviendo hacia arriba - incrementamos las posiciones de los que están entre la nueva y la actual
                cursor.execute('''
                    UPDATE ordenes
                    SET posicion_en_bloque = posicion_en_bloque + 1
                    WHERE bloque_ruta_id = %s
                    AND posicion_en_bloque >= %s
                    AND posicion_en_bloque < %s
                ''', [ruta_id, nueva_posicion, posicion_actual])
            else:
                # Moviendo hacia abajo - decrementamos las posiciones de los que están entre la actual y la nueva
                cursor.execute('''
                    UPDATE ordenes
                    SET posicion_en_bloque = posicion_en_bloque - 1
                    WHERE bloque_ruta_id = %s
                    AND posicion_en_bloque > %s
                    AND posicion_en_bloque <= %s
                ''', [ruta_id, posicion_actual, nueva_posicion])
            
            # Finalmente actualizamos la posición del pedido que estamos moviendo
            cursor.execute('''
                UPDATE ordenes
                SET posicion_en_bloque = %s
                WHERE id = %s
            ''', [nueva_posicion, orden_id])
            
            return JsonResponse({
                'success': True,
                'message': 'Pedidos reordenados correctamente'
            })
            
    except Exception as e:
        print(f"ERROR EN REORDENAR PEDIDOS: {str(e)}")
        return JsonResponse({'error': str(e)}, status=500)

@csrf_exempt
@login_required
def mover_orden_en_ruta(request):
    """API para mover una orden a una nueva posición dentro de una ruta garantizando posiciones únicas"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        orden_id = data.get('orden_id')
        ruta_id = data.get('ruta_id')
        nueva_posicion = data.get('nueva_posicion')
        
        if not orden_id or not ruta_id or nueva_posicion is None:
            return JsonResponse({'error': 'Faltan parámetros necesarios'}, status=400)
        
        with connections['pagoda'].cursor() as cursor:
            # Verificar si la ruta está abierta
            cursor.execute('SET STATEMENT max_statement_time = 25 FOR SELECT activo FROM bloques_ruta WHERE id = %s', [ruta_id])
            ruta = dictfetchone(cursor)
            
            if not ruta:
                return JsonResponse({'error': 'Ruta no encontrada'}, status=404)
            
            if ruta['activo'] != 0:
                return JsonResponse({
                    'error': 'No se puede modificar el orden en una ruta que ya está en proceso de entrega'
                }, status=400)
            
            # Obtener la posición actual de la orden
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT posicion_en_bloque 
                FROM ordenes 
                WHERE id = %s AND bloque_ruta_id = %s
            ''', [orden_id, ruta_id])
            
            resultado = dictfetchone(cursor)
            if not resultado:
                return JsonResponse({'error': 'La orden no pertenece a esta ruta'}, status=400)
            
            posicion_actual = resultado['posicion_en_bloque']
            
            # Si no hay cambio en la posición, no hacer nada
            if posicion_actual == nueva_posicion:
                return JsonResponse({
                    'success': True,
                    'mensaje': 'La posición no ha cambiado',
                    'orden_id': orden_id,
                    'ruta_id': ruta_id
                })
            
            # Ajustar las posiciones de las otras órdenes
            print('actualizando')
            if nueva_posicion < posicion_actual:
                # Moviendo hacia arriba - incrementar posiciones entre la nueva y la actual
                cursor.execute('''
                    UPDATE ordenes
                    SET posicion_en_bloque = posicion_en_bloque + 1
                    WHERE bloque_ruta_id = %s
                    AND posicion_en_bloque >= %s
                    AND posicion_en_bloque < %s
                ''', [ruta_id, nueva_posicion, posicion_actual])
            else:
                # Moviendo hacia abajo - decrementar posiciones entre la actual y la nueva
                cursor.execute('''
                    UPDATE ordenes
                    SET posicion_en_bloque = posicion_en_bloque - 1
                    WHERE bloque_ruta_id = %s
                    AND posicion_en_bloque > %s
                    AND posicion_en_bloque <= %s
                ''', [ruta_id, posicion_actual, nueva_posicion])
            
            # Finalmente actualizar la posición de la orden movida
            cursor.execute('''
                UPDATE ordenes
                SET posicion_en_bloque = %s
                WHERE id = %s
            ''', [nueva_posicion, orden_id])
            
            return JsonResponse({
                'success': True,
                'mensaje': 'Posición actualizada correctamente',
                'orden_id': orden_id,
                'ruta_id': ruta_id,
                'posicion': nueva_posicion
            })
            
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Formato JSON inválido'}, status=400)
    except Exception as e:
        print(f"ERROR EN MOVER ORDEN: {str(e)}")
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def obtener_posicion_orden(request, orden_id):
    """API para obtener la posición actual de una orden"""
    if request.method != 'GET':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        with connections['pagoda'].cursor() as cursor:
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT posicion_en_bloque, bloque_ruta_id
                FROM ordenes
                WHERE id = %s
            ''', [orden_id])
            
            resultado = dictfetchone(cursor)
            if not resultado:
                return JsonResponse({'error': 'Orden no encontrada'}, status=404)
            
            return JsonResponse({
                'success': True,
                'posicion': resultado['posicion_en_bloque'],
                'ruta_id': resultado['bloque_ruta_id']
            })
            
    except Exception as e:
        print(f"ERROR EN OBTENER POSICIÓN ORDEN: {str(e)}")
        return JsonResponse({'error': str(e)}, status=500)

@csrf_exempt
@login_required
def guardar_orden_completo(request):
    """API para guardar el orden completo de todas las órdenes en una ruta"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        ruta_id = data.get('ruta_id')
        orden_ids = data.get('orden_ids', [])
        
        if not ruta_id or not orden_ids:
            return JsonResponse({'error': 'Se requiere ID de ruta y lista de órdenes'}, status=400)
        
        with connections['pagoda'].cursor() as cursor:
            # Verificar si la ruta está activa
            cursor.execute('SET STATEMENT max_statement_time = 25 FOR SELECT activo FROM bloques_ruta WHERE id = %s', [ruta_id])
            ruta = dictfetchone(cursor)
            
            if not ruta:
                return JsonResponse({'error': 'Ruta no encontrada'}, status=404)
            
            if ruta['activo'] != 0:
                return JsonResponse({
                    'error': 'No se puede modificar el orden en una ruta que ya está en proceso de entrega'
                }, status=400)
            
            # Primero ponemos todas las posiciones en un valor temporal alto 
            # para evitar conflictos con constraints de unicidad
            cursor.execute('''
                UPDATE ordenes
                SET posicion_en_bloque = posicion_en_bloque + 10000
                WHERE bloque_ruta_id = %s
            ''', [ruta_id])
            
            # Ahora asignamos las nuevas posiciones secuencialmente
            for i, orden_id in enumerate(orden_ids, 1):  # Empezamos desde 1
                cursor.execute('''
                    UPDATE ordenes
                    SET posicion_en_bloque = %s
                    WHERE id = %s AND bloque_ruta_id = %s
                ''', [i, orden_id, ruta_id])
            
            # Verificar que todas las órdenes se actualizaron correctamente
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT id, codigo_orden, posicion_en_bloque
                FROM ordenes
                WHERE bloque_ruta_id = %s
                ORDER BY posicion_en_bloque
            ''', [ruta_id])
            
            ordenes_actualizadas = dictfetchall(cursor)
            
            return JsonResponse({
                'success': True,
                'mensaje': 'Orden actualizado correctamente',
                'ordenes': ordenes_actualizadas
            })
    
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Formato JSON inválido'}, status=400)
    except Exception as e:
        print(f"ERROR EN GUARDAR ORDEN COMPLETO: {str(e)}")
        return JsonResponse({'error': str(e)}, status=500)

# tus_app/views.py
from django.shortcuts import render
from django.contrib.auth.decorators import login_required
from .decorators import grupos_permitidos
from .models import Productos, OrdenDetalles
from django.db.models import Sum, F, Q, Case, When, Value, BooleanField, IntegerField, Subquery, OuterRef
from django.db.models.functions import Coalesce
from django.utils import timezone

@login_required
@grupos_permitidos(['Administradores', 'Cocineros'])
def lista_inventarios(request):
    """Vista principal de inventarios, refactorizada con el ORM de Django."""

    # 1. Subconsulta para calcular el stock 'comprometido'.
    #    Corregido: Se cambió filter(..., preparado__ne=2) por .exclude(preparado=2)
    subquery_comprometido = OrdenDetalles.objects.filter(
        producto=OuterRef('pk')
    ).exclude(
        preparado=2
    ).values('producto').annotate(
        total=Sum(F('cantidad') - F('cancelado'))
    ).values('total')

    # 2. Consulta principal
    productos_qs = Productos.objects.filter(
        control_inventario=True
    ).select_related('categoria').annotate(
        # 3. Anotaciones para los cálculos
        comprometido=Coalesce(
            Subquery(subquery_comprometido), 0, output_field=IntegerField()
        ),
        validado_hoy=Case(
            When(fecha_validado__date=timezone.now().date(), then=Value(True)),
            default=Value(False),
            output_field=BooleanField()
        )
    ).annotate(
        debe_de_haber=F('stock_actual') + F('comprometido')
    ).order_by('categoria__nombre', 'nombre')

    return render(request, 'inventarios/lista.html', {'productos': productos_qs})

@login_required
@grupos_permitidos(['Administradores'])
@csrf_exempt
def actualizar_stock(request):
    """Actualizar stock validado y stock actual usando el ORM de Django."""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
        
    try:
        data = json.loads(request.body)
        producto_id = data.get('producto_id')
        stock_validado = data.get('stock_validado')
        pin = data.get('pin')
        
        if not all([producto_id, stock_validado, pin]):
            return JsonResponse({'error': 'Faltan parámetros requeridos'}, status=400)
        
        stock_validado = int(float(stock_validado))
        
        # 1. Verificar PIN de acceso con el ORM
        empleado_id = request.session.get('empleado_id')
        if not empleado_id or not Empleado.objects.filter(id=empleado_id, pin_acceso=pin, estatus='activo').exists():
            return JsonResponse({'success': False, 'error': 'PIN incorrecto o no autorizado'}, status=401)
        
        # Usamos una transacción atómica para asegurar la integridad de los datos.
        # O todo se guarda correctamente, o no se guarda nada.
        with transaction.atomic():
            # Obtenemos el producto para asegurar que existe antes de continuar
            producto = Productos.objects.get(id=producto_id)
            
            # 2. Verificar si ya fue validado hoy con el ORM
            if producto.fecha_validado and producto.fecha_validado.date() == timezone.now().date():
                return JsonResponse({'success': False, 'error': 'Este producto ya fue verificado hoy.'}, status=400)
            
            # 3. Obtener el 'comprometido' con el ORM (misma lógica que en la vista de lista)
            comprometido_data = OrdenDetalles.objects.filter(
                producto=producto
            ).exclude(
                preparado=2
            ).aggregate(
                total=Coalesce(Sum(F('cantidad') - F('cancelado')), 0)
            )
            comprometido = comprometido_data['total']
            
            # 4. Calcular el nuevo stock disponible
            nuevo_disponible = stock_validado - comprometido
            
            # 5. Actualizar el producto con el ORM
            # Usamos .update() que es más eficiente que obtener y luego guardar.
            Productos.objects.filter(id=producto_id).update(
                stock_validado=stock_validado,
                stock_actual=nuevo_disponible,
                fecha_validado=timezone.now(), # Usamos timezone.now() para la fecha y hora
                actualizado_en=timezone.now()
            )
            
            # 6. Registrar el movimiento de inventario con el ORM
            InventarioMovimiento.objects.create(
                producto=producto,
                tipo_movimiento='ajuste',
                cantidad=stock_validado,
                descripcion=f'Verificación física: {stock_validado} unidades.',
                empleado_id=empleado_id
            )

        return JsonResponse({
            'success': True, 
            'mensaje': 'Inventario verificado correctamente',
            'nuevo_disponible': nuevo_disponible
        })
        
    except Productos.DoesNotExist:
        return JsonResponse({'error': 'Producto no encontrado'}, status=404)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Formato JSON inválido'}, status=400)
    except Exception as e:
        return JsonResponse({'error': f'Ocurrió un error inesperado: {str(e)}'}, status=500)

@login_required
@require_POST
@grupos_permitidos(['Administradores'])
def restablecer_inventario(request):
    """Restablecer todo el stock actual al stock inicial"""
    
    # Verificar PIN
    pin = request.POST.get('pin')
    if not pin:
        messages.error(request, 'Se requiere PIN para esta operación')
        return redirect('lista_inventarios')
        
    empleado_id = request.session['empleado_id']
    
    # Verificar PIN
    with connections['pagoda'].cursor() as cursor:
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT id
            FROM empleados
            WHERE id = %s AND pin_acceso = %s AND estatus = 'activo'
        ''', [empleado_id, pin])
        
        empleado = cursor.fetchone()
        
        if not empleado:
            messages.error(request, 'PIN incorrecto o no autorizado')
            return redirect('lista_inventarios')
    
    try:
        with connections['pagoda'].cursor() as cursor:
            # Primero obtener todos los productos que se van a actualizar y que realmente tienen diferencia
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT id, nombre, stock_actual, stock_inicial
                FROM productos 
                WHERE control_inventario = 1 
                AND stock_actual != stock_inicial
            ''')
            productos_a_actualizar = dictfetchall(cursor)
            
            # Actualizar todos los productos
            cursor.execute('''
                UPDATE productos 
                SET stock_actual = stock_inicial,
                    stock_validado = NULL,  -- Reiniciamos validación
                    fecha_validado = NULL,  -- Reiniciamos fecha de validación
                    actualizado_en = NOW()
                WHERE control_inventario = 1
            ''')
            
            # Registrar un movimiento por cada producto que cambió
            for producto in productos_a_actualizar:
                diferencia = float(producto['stock_inicial']) - float(producto['stock_actual'])
                tipo_movimiento = 'entrada' if diferencia > 0 else 'salida'
                
                cursor.execute('''
                    INSERT INTO inventario_movimientos (
                        producto_id, 
                        tipo_movimiento, 
                        cantidad, 
                        descripcion,
                        empleado_id
                    ) VALUES (%s, %s, %s, %s, %s)
                ''', [
                    producto['id'],
                    tipo_movimiento,
                    abs(diferencia),
                    f'Restablecimiento a stock inicial: de {producto["stock_actual"]} a {producto["stock_inicial"]}',
                    empleado[0]
                ])
            
            cantidad_actualizada = len(productos_a_actualizar)
            if cantidad_actualizada > 0:
                messages.success(request, f'Inventario restablecido correctamente. {cantidad_actualizada} productos actualizados.')
            else:
                messages.info(request, 'No había productos que necesitaran actualización.')
                
        return redirect('lista_inventarios')
    except Exception as e:
        messages.error(request, f'Error al restablecer inventario: {str(e)}')
        return redirect('lista_inventarios')

@login_required
def historial_inventario(request, producto_id):
    """Ver historial de movimientos de un producto"""
    with connections['pagoda'].cursor() as cursor:
        cursor.execute('''
            SET STATEMENT max_statement_time = 25 FOR SELECT 
                p.nombre as producto,
                im.tipo_movimiento,
                im.cantidad,
                im.descripcion,
                im.creado_en,
                im.empleado_id
            FROM inventario_movimientos im
            INNER JOIN productos p ON p.id = im.producto_id
            WHERE im.producto_id = %s
            ORDER BY im.creado_en DESC
            LIMIT 50
        ''', [producto_id])
        movimientos = dictfetchall(cursor)
    
    # Obtener los usernames desde la BD django
    with connections['pagoda'].cursor() as cursor_django:
        for movimiento in movimientos:
            if movimiento['empleado_id']:
                cursor_django.execute('''
                    SET STATEMENT max_statement_time = 25 FOR SELECT username, first_name, last_name 
                    FROM auth_user 
                    WHERE id = %s
                ''', [movimiento['empleado_id']])
                result = cursor_django.fetchone()
                if result:
                    username, first_name, last_name = result
                    # Puedes usar solo username o nombre completo
                    movimiento['usuario'] = f"{first_name} {last_name}".strip() or username
                else:
                    movimiento['usuario'] = 'Usuario no encontrado'
            else:
                movimiento['usuario'] = 'Sistema'
    
    return render(request, 'inventarios/historial.html', {
        'movimientos': movimientos,
        'producto_id': producto_id
    })

@csrf_exempt
@login_required
def verificar_pin_django(request):
    """Verificar PIN del empleado antes de procesar una acción"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Método no permitido'}, status=405)
    
    try:
        data = json.loads(request.body)
        pin = data.get('pin')
        
        if not pin:
            return JsonResponse({'error': 'PIN requerido'}, status=400)
        
        # Verificar si el PIN corresponde al empleado en sesión
        with connections['pagoda'].cursor() as cursor:
            cursor.execute('''
                SET STATEMENT max_statement_time = 25 FOR SELECT id
                FROM empleados
                WHERE id = %s AND pin_acceso = %s AND estatus = 'activo'
            ''', [request.session['empleado_id'], pin])
            
            empleado = cursor.fetchone()
            
            if not empleado:
                return JsonResponse({
                    'success': False,
                    'error': 'PIN incorrecto o no autorizado'
                }, status=401)
            
            return JsonResponse({
                'success': True,
                'empleado_id': empleado[0]
            })
            
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Formato JSON inválido'}, status=400)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)
